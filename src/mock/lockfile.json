{
  "packageName": "@yarnpkg/lockfile",
  "packageVersion": "1.1.0",
  "request": "@yarnpkg/lockfile",
  "resolved": "index.js",
  "files": {
    "index.js": "module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 14);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"path\");\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.__esModule = true;\n\nvar _promise = __webpack_require__(173);\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function (fn) {\n  return function () {\n    var gen = fn.apply(this, arguments);\n    return new _promise2.default(function (resolve, reject) {\n      function step(key, arg) {\n        try {\n          var info = gen[key](arg);\n          var value = info.value;\n        } catch (error) {\n          reject(error);\n          return;\n        }\n\n        if (info.done) {\n          resolve(value);\n        } else {\n          return _promise2.default.resolve(value).then(function (value) {\n            step(\"next\", value);\n          }, function (err) {\n            step(\"throw\", err);\n          });\n        }\n      }\n\n      return step(\"next\");\n    });\n  };\n};\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"util\");\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"fs\");\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nclass MessageError extends Error {\n  constructor(msg, code) {\n    super(msg);\n    this.code = code;\n  }\n\n}\n\nexports.MessageError = MessageError;\nclass ProcessSpawnError extends MessageError {\n  constructor(msg, code, process) {\n    super(msg, code);\n    this.process = process;\n  }\n\n}\n\nexports.ProcessSpawnError = ProcessSpawnError;\nclass SecurityError extends MessageError {}\n\nexports.SecurityError = SecurityError;\nclass ProcessTermError extends MessageError {}\n\nexports.ProcessTermError = ProcessTermError;\nclass ResponseError extends Error {\n  constructor(msg, responseCode) {\n    super(msg);\n    this.responseCode = responseCode;\n  }\n\n}\nexports.ResponseError = ResponseError;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getFirstSuitableFolder = exports.readFirstAvailableStream = exports.makeTempDir = exports.hardlinksWork = exports.writeFilePreservingEol = exports.getFileSizeOnDisk = exports.walk = exports.symlink = exports.find = exports.readJsonAndFile = exports.readJson = exports.readFileAny = exports.hardlinkBulk = exports.copyBulk = exports.unlink = exports.glob = exports.link = exports.chmod = exports.lstat = exports.exists = exports.mkdirp = exports.stat = exports.access = exports.rename = exports.readdir = exports.realpath = exports.readlink = exports.writeFile = exports.open = exports.readFileBuffer = exports.lockQueue = exports.constants = undefined;\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(1));\n}\n\nlet buildActionsForCopy = (() => {\n  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (queue, events, possibleExtraneous, reporter) {\n\n    //\n    let build = (() => {\n      var _ref5 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (data) {\n        const src = data.src,\n              dest = data.dest,\n              type = data.type;\n\n        const onFresh = data.onFresh || noop;\n        const onDone = data.onDone || noop;\n\n        // TODO https://github.com/yarnpkg/yarn/issues/3751\n        // related to bundled dependencies handling\n        if (files.has(dest.toLowerCase())) {\n          reporter.verbose(`The case-insensitive file ${dest} shouldn't be copied twice in one bulk copy`);\n        } else {\n          files.add(dest.toLowerCase());\n        }\n\n        if (type === 'symlink') {\n          yield mkdirp((_path || _load_path()).default.dirname(dest));\n          onFresh();\n          actions.symlink.push({\n            dest,\n            linkname: src\n          });\n          onDone();\n          return;\n        }\n\n        if (events.ignoreBasenames.indexOf((_path || _load_path()).default.basename(src)) >= 0) {\n          // ignored file\n          return;\n        }\n\n        const srcStat = yield lstat(src);\n        let srcFiles;\n\n        if (srcStat.isDirectory()) {\n          srcFiles = yield readdir(src);\n        }\n\n        let destStat;\n        try {\n          // try accessing the destination\n          destStat = yield lstat(dest);\n        } catch (e) {\n          // proceed if destination doesn't exist, otherwise error\n          if (e.code !== 'ENOENT') {\n            throw e;\n          }\n        }\n\n        // if destination exists\n        if (destStat) {\n          const bothSymlinks = srcStat.isSymbolicLink() && destStat.isSymbolicLink();\n          const bothFolders = srcStat.isDirectory() && destStat.isDirectory();\n          const bothFiles = srcStat.isFile() && destStat.isFile();\n\n          // EINVAL access errors sometimes happen which shouldn't because node shouldn't be giving\n          // us modes that aren't valid. investigate this, it's generally safe to proceed.\n\n          /* if (srcStat.mode !== destStat.mode) {\n            try {\n              await access(dest, srcStat.mode);\n            } catch (err) {}\n          } */\n\n          if (bothFiles && artifactFiles.has(dest)) {\n            // this file gets changed during build, likely by a custom install script. Don't bother checking it.\n            onDone();\n            reporter.verbose(reporter.lang('verboseFileSkipArtifact', src));\n            return;\n          }\n\n          if (bothFiles && srcStat.size === destStat.size && (0, (_fsNormalized || _load_fsNormalized()).fileDatesEqual)(srcStat.mtime, destStat.mtime)) {\n            // we can safely assume this is the same file\n            onDone();\n            reporter.verbose(reporter.lang('verboseFileSkip', src, dest, srcStat.size, +srcStat.mtime));\n            return;\n          }\n\n          if (bothSymlinks) {\n            const srcReallink = yield readlink(src);\n            if (srcReallink === (yield readlink(dest))) {\n              // if both symlinks are the same then we can continue on\n              onDone();\n              reporter.verbose(reporter.lang('verboseFileSkipSymlink', src, dest, srcReallink));\n              return;\n            }\n          }\n\n          if (bothFolders) {\n            // mark files that aren't in this folder as possibly extraneous\n            const destFiles = yield readdir(dest);\n            invariant(srcFiles, 'src files not initialised');\n\n            for (var _iterator4 = destFiles, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {\n              var _ref6;\n\n              if (_isArray4) {\n                if (_i4 >= _iterator4.length) break;\n                _ref6 = _iterator4[_i4++];\n              } else {\n                _i4 = _iterator4.next();\n                if (_i4.done) break;\n                _ref6 = _i4.value;\n              }\n\n              const file = _ref6;\n\n              if (srcFiles.indexOf(file) < 0) {\n                const loc = (_path || _load_path()).default.join(dest, file);\n                possibleExtraneous.add(loc);\n\n                if ((yield lstat(loc)).isDirectory()) {\n                  for (var _iterator5 = yield readdir(loc), _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {\n                    var _ref7;\n\n                    if (_isArray5) {\n                      if (_i5 >= _iterator5.length) break;\n                      _ref7 = _iterator5[_i5++];\n                    } else {\n                      _i5 = _iterator5.next();\n                      if (_i5.done) break;\n                      _ref7 = _i5.value;\n                    }\n\n                    const file = _ref7;\n\n                    possibleExtraneous.add((_path || _load_path()).default.join(loc, file));\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if (destStat && destStat.isSymbolicLink()) {\n          yield (0, (_fsNormalized || _load_fsNormalized()).unlink)(dest);\n          destStat = null;\n        }\n\n        if (srcStat.isSymbolicLink()) {\n          onFresh();\n          const linkname = yield readlink(src);\n          actions.symlink.push({\n            dest,\n            linkname\n          });\n          onDone();\n        } else if (srcStat.isDirectory()) {\n          if (!destStat) {\n            reporter.verbose(reporter.lang('verboseFileFolder', dest));\n            yield mkdirp(dest);\n          }\n\n          const destParts = dest.split((_path || _load_path()).default.sep);\n          while (destParts.length) {\n            files.add(destParts.join((_path || _load_path()).default.sep).toLowerCase());\n            destParts.pop();\n          }\n\n          // push all files to queue\n          invariant(srcFiles, 'src files not initialised');\n          let remaining = srcFiles.length;\n          if (!remaining) {\n            onDone();\n          }\n          for (var _iterator6 = srcFiles, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {\n            var _ref8;\n\n            if (_isArray6) {\n              if (_i6 >= _iterator6.length) break;\n              _ref8 = _iterator6[_i6++];\n            } else {\n              _i6 = _iterator6.next();\n              if (_i6.done) break;\n              _ref8 = _i6.value;\n            }\n\n            const file = _ref8;\n\n            queue.push({\n              dest: (_path || _load_path()).default.join(dest, file),\n              onFresh,\n              onDone: function (_onDone) {\n                function onDone() {\n                  return _onDone.apply(this, arguments);\n                }\n\n                onDone.toString = function () {\n                  return _onDone.toString();\n                };\n\n                return onDone;\n              }(function () {\n                if (--remaining === 0) {\n                  onDone();\n                }\n              }),\n              src: (_path || _load_path()).default.join(src, file)\n            });\n          }\n        } else if (srcStat.isFile()) {\n          onFresh();\n          actions.file.push({\n            src,\n            dest,\n            atime: srcStat.atime,\n            mtime: srcStat.mtime,\n            mode: srcStat.mode\n          });\n          onDone();\n        } else {\n          throw new Error(`unsure how to copy this: ${src}`);\n        }\n      });\n\n      return function build(_x5) {\n        return _ref5.apply(this, arguments);\n      };\n    })();\n\n    const artifactFiles = new Set(events.artifactFiles || []);\n    const files = new Set();\n\n    // initialise events\n    for (var _iterator = queue, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref2 = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref2 = _i.value;\n      }\n\n      const item = _ref2;\n\n      const onDone = item.onDone;\n      item.onDone = function () {\n        events.onProgress(item.dest);\n        if (onDone) {\n          onDone();\n        }\n      };\n    }\n    events.onStart(queue.length);\n\n    // start building actions\n    const actions = {\n      file: [],\n      symlink: [],\n      link: []\n    };\n\n    // custom concurrency logic as we're always executing stacks of CONCURRENT_QUEUE_ITEMS queue items\n    // at a time due to the requirement to push items onto the queue\n    while (queue.length) {\n      const items = queue.splice(0, CONCURRENT_QUEUE_ITEMS);\n      yield Promise.all(items.map(build));\n    }\n\n    // simulate the existence of some files to prevent considering them extraneous\n    for (var _iterator2 = artifactFiles, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref3;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref3 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref3 = _i2.value;\n      }\n\n      const file = _ref3;\n\n      if (possibleExtraneous.has(file)) {\n        reporter.verbose(reporter.lang('verboseFilePhantomExtraneous', file));\n        possibleExtraneous.delete(file);\n      }\n    }\n\n    for (var _iterator3 = possibleExtraneous, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n      var _ref4;\n\n      if (_isArray3) {\n        if (_i3 >= _iterator3.length) break;\n        _ref4 = _iterator3[_i3++];\n      } else {\n        _i3 = _iterator3.next();\n        if (_i3.done) break;\n        _ref4 = _i3.value;\n      }\n\n      const loc = _ref4;\n\n      if (files.has(loc.toLowerCase())) {\n        possibleExtraneous.delete(loc);\n      }\n    }\n\n    return actions;\n  });\n\n  return function buildActionsForCopy(_x, _x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n})();\n\nlet buildActionsForHardlink = (() => {\n  var _ref9 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (queue, events, possibleExtraneous, reporter) {\n\n    //\n    let build = (() => {\n      var _ref13 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (data) {\n        const src = data.src,\n              dest = data.dest;\n\n        const onFresh = data.onFresh || noop;\n        const onDone = data.onDone || noop;\n        if (files.has(dest.toLowerCase())) {\n          // Fixes issue https://github.com/yarnpkg/yarn/issues/2734\n          // When bulk hardlinking we have A -> B structure that we want to hardlink to A1 -> B1,\n          // package-linker passes that modules A1 and B1 need to be hardlinked,\n          // the recursive linking algorithm of A1 ends up scheduling files in B1 to be linked twice which will case\n          // an exception.\n          onDone();\n          return;\n        }\n        files.add(dest.toLowerCase());\n\n        if (events.ignoreBasenames.indexOf((_path || _load_path()).default.basename(src)) >= 0) {\n          // ignored file\n          return;\n        }\n\n        const srcStat = yield lstat(src);\n        let srcFiles;\n\n        if (srcStat.isDirectory()) {\n          srcFiles = yield readdir(src);\n        }\n\n        const destExists = yield exists(dest);\n        if (destExists) {\n          const destStat = yield lstat(dest);\n\n          const bothSymlinks = srcStat.isSymbolicLink() && destStat.isSymbolicLink();\n          const bothFolders = srcStat.isDirectory() && destStat.isDirectory();\n          const bothFiles = srcStat.isFile() && destStat.isFile();\n\n          if (srcStat.mode !== destStat.mode) {\n            try {\n              yield access(dest, srcStat.mode);\n            } catch (err) {\n              // EINVAL access errors sometimes happen which shouldn't because node shouldn't be giving\n              // us modes that aren't valid. investigate this, it's generally safe to proceed.\n              reporter.verbose(err);\n            }\n          }\n\n          if (bothFiles && artifactFiles.has(dest)) {\n            // this file gets changed during build, likely by a custom install script. Don't bother checking it.\n            onDone();\n            reporter.verbose(reporter.lang('verboseFileSkipArtifact', src));\n            return;\n          }\n\n          // correct hardlink\n          if (bothFiles && srcStat.ino !== null && srcStat.ino === destStat.ino) {\n            onDone();\n            reporter.verbose(reporter.lang('verboseFileSkip', src, dest, srcStat.ino));\n            return;\n          }\n\n          if (bothSymlinks) {\n            const srcReallink = yield readlink(src);\n            if (srcReallink === (yield readlink(dest))) {\n              // if both symlinks are the same then we can continue on\n              onDone();\n              reporter.verbose(reporter.lang('verboseFileSkipSymlink', src, dest, srcReallink));\n              return;\n            }\n          }\n\n          if (bothFolders) {\n            // mark files that aren't in this folder as possibly extraneous\n            const destFiles = yield readdir(dest);\n            invariant(srcFiles, 'src files not initialised');\n\n            for (var _iterator10 = destFiles, _isArray10 = Array.isArray(_iterator10), _i10 = 0, _iterator10 = _isArray10 ? _iterator10 : _iterator10[Symbol.iterator]();;) {\n              var _ref14;\n\n              if (_isArray10) {\n                if (_i10 >= _iterator10.length) break;\n                _ref14 = _iterator10[_i10++];\n              } else {\n                _i10 = _iterator10.next();\n                if (_i10.done) break;\n                _ref14 = _i10.value;\n              }\n\n              const file = _ref14;\n\n              if (srcFiles.indexOf(file) < 0) {\n                const loc = (_path || _load_path()).default.join(dest, file);\n                possibleExtraneous.add(loc);\n\n                if ((yield lstat(loc)).isDirectory()) {\n                  for (var _iterator11 = yield readdir(loc), _isArray11 = Array.isArray(_iterator11), _i11 = 0, _iterator11 = _isArray11 ? _iterator11 : _iterator11[Symbol.iterator]();;) {\n                    var _ref15;\n\n                    if (_isArray11) {\n                      if (_i11 >= _iterator11.length) break;\n                      _ref15 = _iterator11[_i11++];\n                    } else {\n                      _i11 = _iterator11.next();\n                      if (_i11.done) break;\n                      _ref15 = _i11.value;\n                    }\n\n                    const file = _ref15;\n\n                    possibleExtraneous.add((_path || _load_path()).default.join(loc, file));\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if (srcStat.isSymbolicLink()) {\n          onFresh();\n          const linkname = yield readlink(src);\n          actions.symlink.push({\n            dest,\n            linkname\n          });\n          onDone();\n        } else if (srcStat.isDirectory()) {\n          reporter.verbose(reporter.lang('verboseFileFolder', dest));\n          yield mkdirp(dest);\n\n          const destParts = dest.split((_path || _load_path()).default.sep);\n          while (destParts.length) {\n            files.add(destParts.join((_path || _load_path()).default.sep).toLowerCase());\n            destParts.pop();\n          }\n\n          // push all files to queue\n          invariant(srcFiles, 'src files not initialised');\n          let remaining = srcFiles.length;\n          if (!remaining) {\n            onDone();\n          }\n          for (var _iterator12 = srcFiles, _isArray12 = Array.isArray(_iterator12), _i12 = 0, _iterator12 = _isArray12 ? _iterator12 : _iterator12[Symbol.iterator]();;) {\n            var _ref16;\n\n            if (_isArray12) {\n              if (_i12 >= _iterator12.length) break;\n              _ref16 = _iterator12[_i12++];\n            } else {\n              _i12 = _iterator12.next();\n              if (_i12.done) break;\n              _ref16 = _i12.value;\n            }\n\n            const file = _ref16;\n\n            queue.push({\n              onFresh,\n              src: (_path || _load_path()).default.join(src, file),\n              dest: (_path || _load_path()).default.join(dest, file),\n              onDone: function (_onDone2) {\n                function onDone() {\n                  return _onDone2.apply(this, arguments);\n                }\n\n                onDone.toString = function () {\n                  return _onDone2.toString();\n                };\n\n                return onDone;\n              }(function () {\n                if (--remaining === 0) {\n                  onDone();\n                }\n              })\n            });\n          }\n        } else if (srcStat.isFile()) {\n          onFresh();\n          actions.link.push({\n            src,\n            dest,\n            removeDest: destExists\n          });\n          onDone();\n        } else {\n          throw new Error(`unsure how to copy this: ${src}`);\n        }\n      });\n\n      return function build(_x10) {\n        return _ref13.apply(this, arguments);\n      };\n    })();\n\n    const artifactFiles = new Set(events.artifactFiles || []);\n    const files = new Set();\n\n    // initialise events\n    for (var _iterator7 = queue, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator]();;) {\n      var _ref10;\n\n      if (_isArray7) {\n        if (_i7 >= _iterator7.length) break;\n        _ref10 = _iterator7[_i7++];\n      } else {\n        _i7 = _iterator7.next();\n        if (_i7.done) break;\n        _ref10 = _i7.value;\n      }\n\n      const item = _ref10;\n\n      const onDone = item.onDone || noop;\n      item.onDone = function () {\n        events.onProgress(item.dest);\n        onDone();\n      };\n    }\n    events.onStart(queue.length);\n\n    // start building actions\n    const actions = {\n      file: [],\n      symlink: [],\n      link: []\n    };\n\n    // custom concurrency logic as we're always executing stacks of CONCURRENT_QUEUE_ITEMS queue items\n    // at a time due to the requirement to push items onto the queue\n    while (queue.length) {\n      const items = queue.splice(0, CONCURRENT_QUEUE_ITEMS);\n      yield Promise.all(items.map(build));\n    }\n\n    // simulate the existence of some files to prevent considering them extraneous\n    for (var _iterator8 = artifactFiles, _isArray8 = Array.isArray(_iterator8), _i8 = 0, _iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator]();;) {\n      var _ref11;\n\n      if (_isArray8) {\n        if (_i8 >= _iterator8.length) break;\n        _ref11 = _iterator8[_i8++];\n      } else {\n        _i8 = _iterator8.next();\n        if (_i8.done) break;\n        _ref11 = _i8.value;\n      }\n\n      const file = _ref11;\n\n      if (possibleExtraneous.has(file)) {\n        reporter.verbose(reporter.lang('verboseFilePhantomExtraneous', file));\n        possibleExtraneous.delete(file);\n      }\n    }\n\n    for (var _iterator9 = possibleExtraneous, _isArray9 = Array.isArray(_iterator9), _i9 = 0, _iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator]();;) {\n      var _ref12;\n\n      if (_isArray9) {\n        if (_i9 >= _iterator9.length) break;\n        _ref12 = _iterator9[_i9++];\n      } else {\n        _i9 = _iterator9.next();\n        if (_i9.done) break;\n        _ref12 = _i9.value;\n      }\n\n      const loc = _ref12;\n\n      if (files.has(loc.toLowerCase())) {\n        possibleExtraneous.delete(loc);\n      }\n    }\n\n    return actions;\n  });\n\n  return function buildActionsForHardlink(_x6, _x7, _x8, _x9) {\n    return _ref9.apply(this, arguments);\n  };\n})();\n\nlet copyBulk = exports.copyBulk = (() => {\n  var _ref17 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (queue, reporter, _events) {\n    const events = {\n      onStart: _events && _events.onStart || noop,\n      onProgress: _events && _events.onProgress || noop,\n      possibleExtraneous: _events ? _events.possibleExtraneous : new Set(),\n      ignoreBasenames: _events && _events.ignoreBasenames || [],\n      artifactFiles: _events && _events.artifactFiles || []\n    };\n\n    const actions = yield buildActionsForCopy(queue, events, events.possibleExtraneous, reporter);\n    events.onStart(actions.file.length + actions.symlink.length + actions.link.length);\n\n    const fileActions = actions.file;\n\n    const currentlyWriting = new Map();\n\n    yield (_promise || _load_promise()).queue(fileActions, (() => {\n      var _ref18 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (data) {\n        let writePromise;\n        while (writePromise = currentlyWriting.get(data.dest)) {\n          yield writePromise;\n        }\n\n        reporter.verbose(reporter.lang('verboseFileCopy', data.src, data.dest));\n        const copier = (0, (_fsNormalized || _load_fsNormalized()).copyFile)(data, function () {\n          return currentlyWriting.delete(data.dest);\n        });\n        currentlyWriting.set(data.dest, copier);\n        events.onProgress(data.dest);\n        return copier;\n      });\n\n      return function (_x14) {\n        return _ref18.apply(this, arguments);\n      };\n    })(), CONCURRENT_QUEUE_ITEMS);\n\n    // we need to copy symlinks last as they could reference files we were copying\n    const symlinkActions = actions.symlink;\n    yield (_promise || _load_promise()).queue(symlinkActions, function (data) {\n      const linkname = (_path || _load_path()).default.resolve((_path || _load_path()).default.dirname(data.dest), data.linkname);\n      reporter.verbose(reporter.lang('verboseFileSymlink', data.dest, linkname));\n      return symlink(linkname, data.dest);\n    });\n  });\n\n  return function copyBulk(_x11, _x12, _x13) {\n    return _ref17.apply(this, arguments);\n  };\n})();\n\nlet hardlinkBulk = exports.hardlinkBulk = (() => {\n  var _ref19 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (queue, reporter, _events) {\n    const events = {\n      onStart: _events && _events.onStart || noop,\n      onProgress: _events && _events.onProgress || noop,\n      possibleExtraneous: _events ? _events.possibleExtraneous : new Set(),\n      artifactFiles: _events && _events.artifactFiles || [],\n      ignoreBasenames: []\n    };\n\n    const actions = yield buildActionsForHardlink(queue, events, events.possibleExtraneous, reporter);\n    events.onStart(actions.file.length + actions.symlink.length + actions.link.length);\n\n    const fileActions = actions.link;\n\n    yield (_promise || _load_promise()).queue(fileActions, (() => {\n      var _ref20 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (data) {\n        reporter.verbose(reporter.lang('verboseFileLink', data.src, data.dest));\n        if (data.removeDest) {\n          yield (0, (_fsNormalized || _load_fsNormalized()).unlink)(data.dest);\n        }\n        yield link(data.src, data.dest);\n      });\n\n      return function (_x18) {\n        return _ref20.apply(this, arguments);\n      };\n    })(), CONCURRENT_QUEUE_ITEMS);\n\n    // we need to copy symlinks last as they could reference files we were copying\n    const symlinkActions = actions.symlink;\n    yield (_promise || _load_promise()).queue(symlinkActions, function (data) {\n      const linkname = (_path || _load_path()).default.resolve((_path || _load_path()).default.dirname(data.dest), data.linkname);\n      reporter.verbose(reporter.lang('verboseFileSymlink', data.dest, linkname));\n      return symlink(linkname, data.dest);\n    });\n  });\n\n  return function hardlinkBulk(_x15, _x16, _x17) {\n    return _ref19.apply(this, arguments);\n  };\n})();\n\nlet readFileAny = exports.readFileAny = (() => {\n  var _ref21 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (files) {\n    for (var _iterator13 = files, _isArray13 = Array.isArray(_iterator13), _i13 = 0, _iterator13 = _isArray13 ? _iterator13 : _iterator13[Symbol.iterator]();;) {\n      var _ref22;\n\n      if (_isArray13) {\n        if (_i13 >= _iterator13.length) break;\n        _ref22 = _iterator13[_i13++];\n      } else {\n        _i13 = _iterator13.next();\n        if (_i13.done) break;\n        _ref22 = _i13.value;\n      }\n\n      const file = _ref22;\n\n      if (yield exists(file)) {\n        return readFile(file);\n      }\n    }\n    return null;\n  });\n\n  return function readFileAny(_x19) {\n    return _ref21.apply(this, arguments);\n  };\n})();\n\nlet readJson = exports.readJson = (() => {\n  var _ref23 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (loc) {\n    return (yield readJsonAndFile(loc)).object;\n  });\n\n  return function readJson(_x20) {\n    return _ref23.apply(this, arguments);\n  };\n})();\n\nlet readJsonAndFile = exports.readJsonAndFile = (() => {\n  var _ref24 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (loc) {\n    const file = yield readFile(loc);\n    try {\n      return {\n        object: (0, (_map || _load_map()).default)(JSON.parse(stripBOM(file))),\n        content: file\n      };\n    } catch (err) {\n      err.message = `${loc}: ${err.message}`;\n      throw err;\n    }\n  });\n\n  return function readJsonAndFile(_x21) {\n    return _ref24.apply(this, arguments);\n  };\n})();\n\nlet find = exports.find = (() => {\n  var _ref25 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (filename, dir) {\n    const parts = dir.split((_path || _load_path()).default.sep);\n\n    while (parts.length) {\n      const loc = parts.concat(filename).join((_path || _load_path()).default.sep);\n\n      if (yield exists(loc)) {\n        return loc;\n      } else {\n        parts.pop();\n      }\n    }\n\n    return false;\n  });\n\n  return function find(_x22, _x23) {\n    return _ref25.apply(this, arguments);\n  };\n})();\n\nlet symlink = exports.symlink = (() => {\n  var _ref26 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (src, dest) {\n    try {\n      const stats = yield lstat(dest);\n      if (stats.isSymbolicLink()) {\n        const resolved = yield realpath(dest);\n        if (resolved === src) {\n          return;\n        }\n      }\n    } catch (err) {\n      if (err.code !== 'ENOENT') {\n        throw err;\n      }\n    }\n    // We use rimraf for unlink which never throws an ENOENT on missing target\n    yield (0, (_fsNormalized || _load_fsNormalized()).unlink)(dest);\n\n    if (process.platform === 'win32') {\n      // use directory junctions if possible on win32, this requires absolute paths\n      yield fsSymlink(src, dest, 'junction');\n    } else {\n      // use relative paths otherwise which will be retained if the directory is moved\n      let relative;\n      try {\n        relative = (_path || _load_path()).default.relative((_fs || _load_fs()).default.realpathSync((_path || _load_path()).default.dirname(dest)), (_fs || _load_fs()).default.realpathSync(src));\n      } catch (err) {\n        if (err.code !== 'ENOENT') {\n          throw err;\n        }\n        relative = (_path || _load_path()).default.relative((_path || _load_path()).default.dirname(dest), src);\n      }\n      // When path.relative returns an empty string for the current directory, we should instead use\n      // '.', which is a valid fs.symlink target.\n      yield fsSymlink(relative || '.', dest);\n    }\n  });\n\n  return function symlink(_x24, _x25) {\n    return _ref26.apply(this, arguments);\n  };\n})();\n\nlet walk = exports.walk = (() => {\n  var _ref27 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (dir, relativeDir, ignoreBasenames = new Set()) {\n    let files = [];\n\n    let filenames = yield readdir(dir);\n    if (ignoreBasenames.size) {\n      filenames = filenames.filter(function (name) {\n        return !ignoreBasenames.has(name);\n      });\n    }\n\n    for (var _iterator14 = filenames, _isArray14 = Array.isArray(_iterator14), _i14 = 0, _iterator14 = _isArray14 ? _iterator14 : _iterator14[Symbol.iterator]();;) {\n      var _ref28;\n\n      if (_isArray14) {\n        if (_i14 >= _iterator14.length) break;\n        _ref28 = _iterator14[_i14++];\n      } else {\n        _i14 = _iterator14.next();\n        if (_i14.done) break;\n        _ref28 = _i14.value;\n      }\n\n      const name = _ref28;\n\n      const relative = relativeDir ? (_path || _load_path()).default.join(relativeDir, name) : name;\n      const loc = (_path || _load_path()).default.join(dir, name);\n      const stat = yield lstat(loc);\n\n      files.push({\n        relative,\n        basename: name,\n        absolute: loc,\n        mtime: +stat.mtime\n      });\n\n      if (stat.isDirectory()) {\n        files = files.concat((yield walk(loc, relative, ignoreBasenames)));\n      }\n    }\n\n    return files;\n  });\n\n  return function walk(_x26, _x27) {\n    return _ref27.apply(this, arguments);\n  };\n})();\n\nlet getFileSizeOnDisk = exports.getFileSizeOnDisk = (() => {\n  var _ref29 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (loc) {\n    const stat = yield lstat(loc);\n    const size = stat.size,\n          blockSize = stat.blksize;\n\n\n    return Math.ceil(size / blockSize) * blockSize;\n  });\n\n  return function getFileSizeOnDisk(_x28) {\n    return _ref29.apply(this, arguments);\n  };\n})();\n\nlet getEolFromFile = (() => {\n  var _ref30 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (path) {\n    if (!(yield exists(path))) {\n      return undefined;\n    }\n\n    const buffer = yield readFileBuffer(path);\n\n    for (let i = 0; i < buffer.length; ++i) {\n      if (buffer[i] === cr) {\n        return '\\r\\n';\n      }\n      if (buffer[i] === lf) {\n        return '\\n';\n      }\n    }\n    return undefined;\n  });\n\n  return function getEolFromFile(_x29) {\n    return _ref30.apply(this, arguments);\n  };\n})();\n\nlet writeFilePreservingEol = exports.writeFilePreservingEol = (() => {\n  var _ref31 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (path, data) {\n    const eol = (yield getEolFromFile(path)) || (_os || _load_os()).default.EOL;\n    if (eol !== '\\n') {\n      data = data.replace(/\\n/g, eol);\n    }\n    yield writeFile(path, data);\n  });\n\n  return function writeFilePreservingEol(_x30, _x31) {\n    return _ref31.apply(this, arguments);\n  };\n})();\n\nlet hardlinksWork = exports.hardlinksWork = (() => {\n  var _ref32 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (dir) {\n    const filename = 'test-file' + Math.random();\n    const file = (_path || _load_path()).default.join(dir, filename);\n    const fileLink = (_path || _load_path()).default.join(dir, filename + '-link');\n    try {\n      yield writeFile(file, 'test');\n      yield link(file, fileLink);\n    } catch (err) {\n      return false;\n    } finally {\n      yield (0, (_fsNormalized || _load_fsNormalized()).unlink)(file);\n      yield (0, (_fsNormalized || _load_fsNormalized()).unlink)(fileLink);\n    }\n    return true;\n  });\n\n  return function hardlinksWork(_x32) {\n    return _ref32.apply(this, arguments);\n  };\n})();\n\n// not a strict polyfill for Node's fs.mkdtemp\n\n\nlet makeTempDir = exports.makeTempDir = (() => {\n  var _ref33 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (prefix) {\n    const dir = (_path || _load_path()).default.join((_os || _load_os()).default.tmpdir(), `yarn-${prefix || ''}-${Date.now()}-${Math.random()}`);\n    yield (0, (_fsNormalized || _load_fsNormalized()).unlink)(dir);\n    yield mkdirp(dir);\n    return dir;\n  });\n\n  return function makeTempDir(_x33) {\n    return _ref33.apply(this, arguments);\n  };\n})();\n\nlet readFirstAvailableStream = exports.readFirstAvailableStream = (() => {\n  var _ref34 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (paths) {\n    for (var _iterator15 = paths, _isArray15 = Array.isArray(_iterator15), _i15 = 0, _iterator15 = _isArray15 ? _iterator15 : _iterator15[Symbol.iterator]();;) {\n      var _ref35;\n\n      if (_isArray15) {\n        if (_i15 >= _iterator15.length) break;\n        _ref35 = _iterator15[_i15++];\n      } else {\n        _i15 = _iterator15.next();\n        if (_i15.done) break;\n        _ref35 = _i15.value;\n      }\n\n      const path = _ref35;\n\n      try {\n        const fd = yield open(path, 'r');\n        return (_fs || _load_fs()).default.createReadStream(path, { fd });\n      } catch (err) {\n        // Try the next one\n      }\n    }\n    return null;\n  });\n\n  return function readFirstAvailableStream(_x34) {\n    return _ref34.apply(this, arguments);\n  };\n})();\n\nlet getFirstSuitableFolder = exports.getFirstSuitableFolder = (() => {\n  var _ref36 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (paths, mode = constants.W_OK | constants.X_OK) {\n    const result = {\n      skipped: [],\n      folder: null\n    };\n\n    for (var _iterator16 = paths, _isArray16 = Array.isArray(_iterator16), _i16 = 0, _iterator16 = _isArray16 ? _iterator16 : _iterator16[Symbol.iterator]();;) {\n      var _ref37;\n\n      if (_isArray16) {\n        if (_i16 >= _iterator16.length) break;\n        _ref37 = _iterator16[_i16++];\n      } else {\n        _i16 = _iterator16.next();\n        if (_i16.done) break;\n        _ref37 = _i16.value;\n      }\n\n      const folder = _ref37;\n\n      try {\n        yield mkdirp(folder);\n        yield access(folder, mode);\n\n        result.folder = folder;\n\n        return result;\n      } catch (error) {\n        result.skipped.push({\n          error,\n          folder\n        });\n      }\n    }\n    return result;\n  });\n\n  return function getFirstSuitableFolder(_x35) {\n    return _ref36.apply(this, arguments);\n  };\n})();\n\nexports.copy = copy;\nexports.readFile = readFile;\nexports.readFileRaw = readFileRaw;\nexports.normalizeOS = normalizeOS;\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireDefault(__webpack_require__(3));\n}\n\nvar _glob;\n\nfunction _load_glob() {\n  return _glob = _interopRequireDefault(__webpack_require__(75));\n}\n\nvar _os;\n\nfunction _load_os() {\n  return _os = _interopRequireDefault(__webpack_require__(36));\n}\n\nvar _path;\n\nfunction _load_path() {\n  return _path = _interopRequireDefault(__webpack_require__(0));\n}\n\nvar _blockingQueue;\n\nfunction _load_blockingQueue() {\n  return _blockingQueue = _interopRequireDefault(__webpack_require__(84));\n}\n\nvar _promise;\n\nfunction _load_promise() {\n  return _promise = _interopRequireWildcard(__webpack_require__(40));\n}\n\nvar _promise2;\n\nfunction _load_promise2() {\n  return _promise2 = __webpack_require__(40);\n}\n\nvar _map;\n\nfunction _load_map() {\n  return _map = _interopRequireDefault(__webpack_require__(20));\n}\n\nvar _fsNormalized;\n\nfunction _load_fsNormalized() {\n  return _fsNormalized = __webpack_require__(164);\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst constants = exports.constants = typeof (_fs || _load_fs()).default.constants !== 'undefined' ? (_fs || _load_fs()).default.constants : {\n  R_OK: (_fs || _load_fs()).default.R_OK,\n  W_OK: (_fs || _load_fs()).default.W_OK,\n  X_OK: (_fs || _load_fs()).default.X_OK\n};\n\nconst lockQueue = exports.lockQueue = new (_blockingQueue || _load_blockingQueue()).default('fs lock');\n\nconst readFileBuffer = exports.readFileBuffer = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.readFile);\nconst open = exports.open = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.open);\nconst writeFile = exports.writeFile = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.writeFile);\nconst readlink = exports.readlink = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.readlink);\nconst realpath = exports.realpath = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.realpath);\nconst readdir = exports.readdir = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.readdir);\nconst rename = exports.rename = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.rename);\nconst access = exports.access = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.access);\nconst stat = exports.stat = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.stat);\nconst mkdirp = exports.mkdirp = (0, (_promise2 || _load_promise2()).promisify)(__webpack_require__(116));\nconst exists = exports.exists = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.exists, true);\nconst lstat = exports.lstat = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.lstat);\nconst chmod = exports.chmod = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.chmod);\nconst link = exports.link = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.link);\nconst glob = exports.glob = (0, (_promise2 || _load_promise2()).promisify)((_glob || _load_glob()).default);\nexports.unlink = (_fsNormalized || _load_fsNormalized()).unlink;\n\n// fs.copyFile uses the native file copying instructions on the system, performing much better\n// than any JS-based solution and consumes fewer resources. Repeated testing to fine tune the\n// concurrency level revealed 128 as the sweet spot on a quad-core, 16 CPU Intel system with SSD.\n\nconst CONCURRENT_QUEUE_ITEMS = (_fs || _load_fs()).default.copyFile ? 128 : 4;\n\nconst fsSymlink = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.symlink);\nconst invariant = __webpack_require__(7);\nconst stripBOM = __webpack_require__(122);\n\nconst noop = () => {};\n\nfunction copy(src, dest, reporter) {\n  return copyBulk([{ src, dest }], reporter);\n}\n\nfunction _readFile(loc, encoding) {\n  return new Promise((resolve, reject) => {\n    (_fs || _load_fs()).default.readFile(loc, encoding, function (err, content) {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(content);\n      }\n    });\n  });\n}\n\nfunction readFile(loc) {\n  return _readFile(loc, 'utf8').then(normalizeOS);\n}\n\nfunction readFileRaw(loc) {\n  return _readFile(loc, 'binary');\n}\n\nfunction normalizeOS(body) {\n  return body.replace(/\\r\\n/g, '\\n');\n}\n\nconst cr = '\\r'.charCodeAt(0);\nconst lf = '\\n'.charCodeAt(0);\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPathKey = getPathKey;\nconst os = __webpack_require__(36);\nconst path = __webpack_require__(0);\nconst userHome = __webpack_require__(45).default;\n\nvar _require = __webpack_require__(171);\n\nconst getCacheDir = _require.getCacheDir,\n      getConfigDir = _require.getConfigDir,\n      getDataDir = _require.getDataDir;\n\nconst isWebpackBundle = __webpack_require__(227);\n\nconst DEPENDENCY_TYPES = exports.DEPENDENCY_TYPES = ['devDependencies', 'dependencies', 'optionalDependencies', 'peerDependencies'];\nconst RESOLUTIONS = exports.RESOLUTIONS = 'resolutions';\nconst MANIFEST_FIELDS = exports.MANIFEST_FIELDS = [RESOLUTIONS, ...DEPENDENCY_TYPES];\n\nconst SUPPORTED_NODE_VERSIONS = exports.SUPPORTED_NODE_VERSIONS = '^4.8.0 || ^5.7.0 || ^6.2.2 || >=8.0.0';\n\nconst YARN_REGISTRY = exports.YARN_REGISTRY = 'https://registry.yarnpkg.com';\n\nconst YARN_DOCS = exports.YARN_DOCS = 'https://yarnpkg.com/en/docs/cli/';\nconst YARN_INSTALLER_SH = exports.YARN_INSTALLER_SH = 'https://yarnpkg.com/install.sh';\nconst YARN_INSTALLER_MSI = exports.YARN_INSTALLER_MSI = 'https://yarnpkg.com/latest.msi';\n\nconst SELF_UPDATE_VERSION_URL = exports.SELF_UPDATE_VERSION_URL = 'https://yarnpkg.com/latest-version';\n\n// cache version, bump whenever we make backwards incompatible changes\nconst CACHE_VERSION = exports.CACHE_VERSION = 2;\n\n// lockfile version, bump whenever we make backwards incompatible changes\nconst LOCKFILE_VERSION = exports.LOCKFILE_VERSION = 1;\n\n// max amount of network requests to perform concurrently\nconst NETWORK_CONCURRENCY = exports.NETWORK_CONCURRENCY = 8;\n\n// HTTP timeout used when downloading packages\nconst NETWORK_TIMEOUT = exports.NETWORK_TIMEOUT = 30 * 1000; // in milliseconds\n\n// max amount of child processes to execute concurrently\nconst CHILD_CONCURRENCY = exports.CHILD_CONCURRENCY = 5;\n\nconst REQUIRED_PACKAGE_KEYS = exports.REQUIRED_PACKAGE_KEYS = ['name', 'version', '_uid'];\n\nfunction getPreferredCacheDirectories() {\n  const preferredCacheDirectories = [getCacheDir()];\n\n  if (process.getuid) {\n    // $FlowFixMe: process.getuid exists, dammit\n    preferredCacheDirectories.push(path.join(os.tmpdir(), `.yarn-cache-${process.getuid()}`));\n  }\n\n  preferredCacheDirectories.push(path.join(os.tmpdir(), `.yarn-cache`));\n\n  return preferredCacheDirectories;\n}\n\nconst PREFERRED_MODULE_CACHE_DIRECTORIES = exports.PREFERRED_MODULE_CACHE_DIRECTORIES = getPreferredCacheDirectories();\nconst CONFIG_DIRECTORY = exports.CONFIG_DIRECTORY = getConfigDir();\nconst DATA_DIRECTORY = exports.DATA_DIRECTORY = getDataDir();\nconst LINK_REGISTRY_DIRECTORY = exports.LINK_REGISTRY_DIRECTORY = path.join(DATA_DIRECTORY, 'link');\nconst GLOBAL_MODULE_DIRECTORY = exports.GLOBAL_MODULE_DIRECTORY = path.join(DATA_DIRECTORY, 'global');\n\nconst NODE_BIN_PATH = exports.NODE_BIN_PATH = process.execPath;\nconst YARN_BIN_PATH = exports.YARN_BIN_PATH = getYarnBinPath();\n\n// Webpack needs to be configured with node.__dirname/__filename = false\nfunction getYarnBinPath() {\n  if (isWebpackBundle) {\n    return __filename;\n  } else {\n    return path.join(__dirname, '..', 'bin', 'yarn.js');\n  }\n}\n\nconst NODE_MODULES_FOLDER = exports.NODE_MODULES_FOLDER = 'node_modules';\nconst NODE_PACKAGE_JSON = exports.NODE_PACKAGE_JSON = 'package.json';\n\nconst POSIX_GLOBAL_PREFIX = exports.POSIX_GLOBAL_PREFIX = `${process.env.DESTDIR || ''}/usr/local`;\nconst FALLBACK_GLOBAL_PREFIX = exports.FALLBACK_GLOBAL_PREFIX = path.join(userHome, '.yarn');\n\nconst META_FOLDER = exports.META_FOLDER = '.yarn-meta';\nconst INTEGRITY_FILENAME = exports.INTEGRITY_FILENAME = '.yarn-integrity';\nconst LOCKFILE_FILENAME = exports.LOCKFILE_FILENAME = 'yarn.lock';\nconst METADATA_FILENAME = exports.METADATA_FILENAME = '.yarn-metadata.json';\nconst TARBALL_FILENAME = exports.TARBALL_FILENAME = '.yarn-tarball.tgz';\nconst CLEAN_FILENAME = exports.CLEAN_FILENAME = '.yarnclean';\n\nconst NPM_LOCK_FILENAME = exports.NPM_LOCK_FILENAME = 'package-lock.json';\nconst NPM_SHRINKWRAP_FILENAME = exports.NPM_SHRINKWRAP_FILENAME = 'npm-shrinkwrap.json';\n\nconst DEFAULT_INDENT = exports.DEFAULT_INDENT = '  ';\nconst SINGLE_INSTANCE_PORT = exports.SINGLE_INSTANCE_PORT = 31997;\nconst SINGLE_INSTANCE_FILENAME = exports.SINGLE_INSTANCE_FILENAME = '.yarn-single-instance';\n\nconst ENV_PATH_KEY = exports.ENV_PATH_KEY = getPathKey(process.platform, process.env);\n\nfunction getPathKey(platform, env) {\n  let pathKey = 'PATH';\n\n  // windows calls its path \"Path\" usually, but this is not guaranteed.\n  if (platform === 'win32') {\n    pathKey = 'Path';\n\n    for (const key in env) {\n      if (key.toLowerCase() === 'path') {\n        pathKey = key;\n      }\n    }\n  }\n\n  return pathKey;\n}\n\nconst VERSION_COLOR_SCHEME = exports.VERSION_COLOR_SCHEME = {\n  major: 'red',\n  premajor: 'red',\n  minor: 'yellow',\n  preminor: 'yellow',\n  patch: 'green',\n  prepatch: 'green',\n  prerelease: 'red',\n  unchanged: 'white',\n  unknown: 'red'\n};\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar NODE_ENV = process.env.NODE_ENV;\n\nvar invariant = function(condition, format, a, b, c, d, e, f) {\n  if (NODE_ENV !== 'production') {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  }\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error(\n        'Minified exception occurred; use the non-minified dev environment ' +\n        'for the full error message and additional helpful warnings.'\n      );\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(\n        format.replace(/%s/g, function() { return args[argIndex++]; })\n      );\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n};\n\nmodule.exports = invariant;\n\n\n/***/ }),\n/* 8 */,\n/* 9 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"crypto\");\n\n/***/ }),\n/* 10 */,\n/* 11 */\n/***/ (function(module, exports) {\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self\n  // eslint-disable-next-line no-new-func\n  : Function('return this')();\nif (typeof __g == 'number') __g = global; // eslint-disable-line no-undef\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sortAlpha = sortAlpha;\nexports.entries = entries;\nexports.removePrefix = removePrefix;\nexports.removeSuffix = removeSuffix;\nexports.addSuffix = addSuffix;\nexports.hyphenate = hyphenate;\nexports.camelCase = camelCase;\nexports.compareSortedArrays = compareSortedArrays;\nexports.sleep = sleep;\nconst _camelCase = __webpack_require__(176);\n\nfunction sortAlpha(a, b) {\n  // sort alphabetically in a deterministic way\n  const shortLen = Math.min(a.length, b.length);\n  for (let i = 0; i < shortLen; i++) {\n    const aChar = a.charCodeAt(i);\n    const bChar = b.charCodeAt(i);\n    if (aChar !== bChar) {\n      return aChar - bChar;\n    }\n  }\n  return a.length - b.length;\n}\n\nfunction entries(obj) {\n  const entries = [];\n  if (obj) {\n    for (const key in obj) {\n      entries.push([key, obj[key]]);\n    }\n  }\n  return entries;\n}\n\nfunction removePrefix(pattern, prefix) {\n  if (pattern.startsWith(prefix)) {\n    pattern = pattern.slice(prefix.length);\n  }\n\n  return pattern;\n}\n\nfunction removeSuffix(pattern, suffix) {\n  if (pattern.endsWith(suffix)) {\n    return pattern.slice(0, -suffix.length);\n  }\n\n  return pattern;\n}\n\nfunction addSuffix(pattern, suffix) {\n  if (!pattern.endsWith(suffix)) {\n    return pattern + suffix;\n  }\n\n  return pattern;\n}\n\nfunction hyphenate(str) {\n  return str.replace(/[A-Z]/g, match => {\n    return '-' + match.charAt(0).toLowerCase();\n  });\n}\n\nfunction camelCase(str) {\n  if (/[A-Z]/.test(str)) {\n    return null;\n  } else {\n    return _camelCase(str);\n  }\n}\n\nfunction compareSortedArrays(array1, array2) {\n  if (array1.length !== array2.length) {\n    return false;\n  }\n  for (let i = 0, len = array1.length; i < len; i++) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction sleep(ms) {\n  return new Promise(resolve => {\n    setTimeout(resolve, ms);\n  });\n}\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar store = __webpack_require__(107)('wks');\nvar uid = __webpack_require__(111);\nvar Symbol = __webpack_require__(11).Symbol;\nvar USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function (name) {\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.stringify = exports.parse = undefined;\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(1));\n}\n\nvar _parse;\n\nfunction _load_parse() {\n  return _parse = __webpack_require__(81);\n}\n\nObject.defineProperty(exports, 'parse', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_parse || _load_parse()).default;\n  }\n});\n\nvar _stringify;\n\nfunction _load_stringify() {\n  return _stringify = __webpack_require__(150);\n}\n\nObject.defineProperty(exports, 'stringify', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_stringify || _load_stringify()).default;\n  }\n});\nexports.implodeEntry = implodeEntry;\nexports.explodeEntry = explodeEntry;\n\nvar _misc;\n\nfunction _load_misc() {\n  return _misc = __webpack_require__(12);\n}\n\nvar _normalizePattern;\n\nfunction _load_normalizePattern() {\n  return _normalizePattern = __webpack_require__(29);\n}\n\nvar _parse2;\n\nfunction _load_parse2() {\n  return _parse2 = _interopRequireDefault(__webpack_require__(81));\n}\n\nvar _constants;\n\nfunction _load_constants() {\n  return _constants = __webpack_require__(6);\n}\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireWildcard(__webpack_require__(5));\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst invariant = __webpack_require__(7);\n\nconst path = __webpack_require__(0);\nconst ssri = __webpack_require__(55);\n\nfunction getName(pattern) {\n  return (0, (_normalizePattern || _load_normalizePattern()).normalizePattern)(pattern).name;\n}\n\nfunction blankObjectUndefined(obj) {\n  return obj && Object.keys(obj).length ? obj : undefined;\n}\n\nfunction keyForRemote(remote) {\n  return remote.resolved || (remote.reference && remote.hash ? `${remote.reference}#${remote.hash}` : null);\n}\n\nfunction serializeIntegrity(integrity) {\n  // We need this because `Integrity.toString()` does not use sorting to ensure a stable string output\n  // See https://git.io/vx2Hy\n  return integrity.toString().split(' ').sort().join(' ');\n}\n\nfunction implodeEntry(pattern, obj) {\n  const inferredName = getName(pattern);\n  const integrity = obj.integrity ? serializeIntegrity(obj.integrity) : '';\n  const imploded = {\n    name: inferredName === obj.name ? undefined : obj.name,\n    version: obj.version,\n    uid: obj.uid === obj.version ? undefined : obj.uid,\n    resolved: obj.resolved,\n    registry: obj.registry === 'npm' ? undefined : obj.registry,\n    dependencies: blankObjectUndefined(obj.dependencies),\n    optionalDependencies: blankObjectUndefined(obj.optionalDependencies),\n    permissions: blankObjectUndefined(obj.permissions),\n    prebuiltVariants: blankObjectUndefined(obj.prebuiltVariants)\n  };\n  if (integrity) {\n    imploded.integrity = integrity;\n  }\n  return imploded;\n}\n\nfunction explodeEntry(pattern, obj) {\n  obj.optionalDependencies = obj.optionalDependencies || {};\n  obj.dependencies = obj.dependencies || {};\n  obj.uid = obj.uid || obj.version;\n  obj.permissions = obj.permissions || {};\n  obj.registry = obj.registry || 'npm';\n  obj.name = obj.name || getName(pattern);\n  const integrity = obj.integrity;\n  if (integrity && integrity.isIntegrity) {\n    obj.integrity = ssri.parse(integrity);\n  }\n  return obj;\n}\n\nclass Lockfile {\n  constructor({ cache, source, parseResultType } = {}) {\n    this.source = source || '';\n    this.cache = cache;\n    this.parseResultType = parseResultType;\n  }\n\n  // source string if the `cache` was parsed\n\n\n  // if true, we're parsing an old yarn file and need to update integrity fields\n  hasEntriesExistWithoutIntegrity() {\n    if (!this.cache) {\n      return false;\n    }\n\n    for (const key in this.cache) {\n      // $FlowFixMe - `this.cache` is clearly defined at this point\n      if (!/^.*@(file:|http)/.test(key) && this.cache[key] && !this.cache[key].integrity) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  static fromDirectory(dir, reporter) {\n    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n      // read the manifest in this directory\n      const lockfileLoc = path.join(dir, (_constants || _load_constants()).LOCKFILE_FILENAME);\n\n      let lockfile;\n      let rawLockfile = '';\n      let parseResult;\n\n      if (yield (_fs || _load_fs()).exists(lockfileLoc)) {\n        rawLockfile = yield (_fs || _load_fs()).readFile(lockfileLoc);\n        parseResult = (0, (_parse2 || _load_parse2()).default)(rawLockfile, lockfileLoc);\n\n        if (reporter) {\n          if (parseResult.type === 'merge') {\n            reporter.info(reporter.lang('lockfileMerged'));\n          } else if (parseResult.type === 'conflict') {\n            reporter.warn(reporter.lang('lockfileConflict'));\n          }\n        }\n\n        lockfile = parseResult.object;\n      } else if (reporter) {\n        reporter.info(reporter.lang('noLockfileFound'));\n      }\n\n      return new Lockfile({ cache: lockfile, source: rawLockfile, parseResultType: parseResult && parseResult.type });\n    })();\n  }\n\n  getLocked(pattern) {\n    const cache = this.cache;\n    if (!cache) {\n      return undefined;\n    }\n\n    const shrunk = pattern in cache && cache[pattern];\n\n    if (typeof shrunk === 'string') {\n      return this.getLocked(shrunk);\n    } else if (shrunk) {\n      explodeEntry(pattern, shrunk);\n      return shrunk;\n    }\n\n    return undefined;\n  }\n\n  removePattern(pattern) {\n    const cache = this.cache;\n    if (!cache) {\n      return;\n    }\n    delete cache[pattern];\n  }\n\n  getLockfile(patterns) {\n    const lockfile = {};\n    const seen = new Map();\n\n    // order by name so that lockfile manifest is assigned to the first dependency with this manifest\n    // the others that have the same remoteKey will just refer to the first\n    // ordering allows for consistency in lockfile when it is serialized\n    const sortedPatternsKeys = Object.keys(patterns).sort((_misc || _load_misc()).sortAlpha);\n\n    for (var _iterator = sortedPatternsKeys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      const pattern = _ref;\n\n      const pkg = patterns[pattern];\n      const remote = pkg._remote,\n            ref = pkg._reference;\n\n      invariant(ref, 'Package is missing a reference');\n      invariant(remote, 'Package is missing a remote');\n\n      const remoteKey = keyForRemote(remote);\n      const seenPattern = remoteKey && seen.get(remoteKey);\n      if (seenPattern) {\n        // no point in duplicating it\n        lockfile[pattern] = seenPattern;\n\n        // if we're relying on our name being inferred and two of the patterns have\n        // different inferred names then we need to set it\n        if (!seenPattern.name && getName(pattern) !== pkg.name) {\n          seenPattern.name = pkg.name;\n        }\n        continue;\n      }\n      const obj = implodeEntry(pattern, {\n        name: pkg.name,\n        version: pkg.version,\n        uid: pkg._uid,\n        resolved: remote.resolved,\n        integrity: remote.integrity,\n        registry: remote.registry,\n        dependencies: pkg.dependencies,\n        peerDependencies: pkg.peerDependencies,\n        optionalDependencies: pkg.optionalDependencies,\n        permissions: ref.permissions,\n        prebuiltVariants: pkg.prebuiltVariants\n      });\n\n      lockfile[pattern] = obj;\n\n      if (remoteKey) {\n        seen.set(remoteKey, obj);\n      }\n    }\n\n    return lockfile;\n  }\n}\nexports.default = Lockfile;\n\n/***/ }),\n/* 15 */,\n/* 16 */,\n/* 17 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"stream\");\n\n/***/ }),\n/* 18 */,\n/* 19 */,\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = nullify;\nfunction nullify(obj = {}) {\n  if (Array.isArray(obj)) {\n    for (var _iterator = obj, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      const item = _ref;\n\n      nullify(item);\n    }\n  } else if (obj !== null && typeof obj === 'object' || typeof obj === 'function') {\n    Object.setPrototypeOf(obj, null);\n\n    // for..in can only be applied to 'object', not 'function'\n    if (typeof obj === 'object') {\n      for (const key in obj) {\n        nullify(obj[key]);\n      }\n    }\n  }\n\n  return obj;\n}\n\n/***/ }),\n/* 21 */,\n/* 22 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"assert\");\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports) {\n\nvar core = module.exports = { version: '2.5.7' };\nif (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\n\n\n/***/ }),\n/* 24 */,\n/* 25 */,\n/* 26 */,\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(34);\nmodule.exports = function (it) {\n  if (!isObject(it)) throw TypeError(it + ' is not an object!');\n  return it;\n};\n\n\n/***/ }),\n/* 28 */,\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.normalizePattern = normalizePattern;\n\n/**\n * Explode and normalize a pattern into its name and range.\n */\n\nfunction normalizePattern(pattern) {\n  let hasVersion = false;\n  let range = 'latest';\n  let name = pattern;\n\n  // if we're a scope then remove the @ and add it back later\n  let isScoped = false;\n  if (name[0] === '@') {\n    isScoped = true;\n    name = name.slice(1);\n  }\n\n  // take first part as the name\n  const parts = name.split('@');\n  if (parts.length > 1) {\n    name = parts.shift();\n    range = parts.join('@');\n\n    if (range) {\n      hasVersion = true;\n    } else {\n      range = '*';\n    }\n  }\n\n  // add back @ scope suffix\n  if (isScoped) {\n    name = `@${name}`;\n  }\n\n  return { name, range, hasVersion };\n}\n\n/***/ }),\n/* 30 */,\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar dP = __webpack_require__(50);\nvar createDesc = __webpack_require__(106);\nmodule.exports = __webpack_require__(33) ? function (object, key, value) {\n  return dP.f(object, key, createDesc(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* eslint-disable node/no-deprecated-api */\nvar buffer = __webpack_require__(63)\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// Thank's IE8 for his funny defineProperty\nmodule.exports = !__webpack_require__(85)(function () {\n  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;\n});\n\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports) {\n\nmodule.exports = function (it) {\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports) {\n\nmodule.exports = {};\n\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"os\");\n\n/***/ }),\n/* 37 */,\n/* 38 */,\n/* 39 */,\n/* 40 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.wait = wait;\nexports.promisify = promisify;\nexports.queue = queue;\nfunction wait(delay) {\n  return new Promise(resolve => {\n    setTimeout(resolve, delay);\n  });\n}\n\nfunction promisify(fn, firstData) {\n  return function (...args) {\n    return new Promise(function (resolve, reject) {\n      args.push(function (err, ...result) {\n        let res = result;\n\n        if (result.length <= 1) {\n          res = result[0];\n        }\n\n        if (firstData) {\n          res = err;\n          err = null;\n        }\n\n        if (err) {\n          reject(err);\n        } else {\n          resolve(res);\n        }\n      });\n\n      fn.apply(null, args);\n    });\n  };\n}\n\nfunction queue(arr, promiseProducer, concurrency = Infinity) {\n  concurrency = Math.min(concurrency, arr.length);\n\n  // clone\n  arr = arr.slice();\n\n  const results = [];\n  let total = arr.length;\n  if (!total) {\n    return Promise.resolve(results);\n  }\n\n  return new Promise((resolve, reject) => {\n    for (let i = 0; i < concurrency; i++) {\n      next();\n    }\n\n    function next() {\n      const item = arr.shift();\n      const promise = promiseProducer(item);\n\n      promise.then(function (result) {\n        results.push(result);\n\n        total--;\n        if (total === 0) {\n          resolve(results);\n        } else {\n          if (arr.length) {\n            next();\n          }\n        }\n      }, reject);\n    }\n  });\n}\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(11);\nvar core = __webpack_require__(23);\nvar ctx = __webpack_require__(48);\nvar hide = __webpack_require__(31);\nvar has = __webpack_require__(49);\nvar PROTOTYPE = 'prototype';\n\nvar $export = function (type, name, source) {\n  var IS_FORCED = type & $export.F;\n  var IS_GLOBAL = type & $export.G;\n  var IS_STATIC = type & $export.S;\n  var IS_PROTO = type & $export.P;\n  var IS_BIND = type & $export.B;\n  var IS_WRAP = type & $export.W;\n  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});\n  var expProto = exports[PROTOTYPE];\n  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];\n  var key, own, out;\n  if (IS_GLOBAL) source = name;\n  for (key in source) {\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    if (own && has(exports, key)) continue;\n    // export native or passed\n    out = own ? target[key] : source[key];\n    // prevent global pollution for namespaces\n    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n    // bind timers to global for call from export context\n    : IS_BIND && own ? ctx(out, global)\n    // wrap global constructors for prevent change them in library\n    : IS_WRAP && target[key] == out ? (function (C) {\n      var F = function (a, b, c) {\n        if (this instanceof C) {\n          switch (arguments.length) {\n            case 0: return new C();\n            case 1: return new C(a);\n            case 2: return new C(a, b);\n          } return new C(a, b, c);\n        } return C.apply(this, arguments);\n      };\n      F[PROTOTYPE] = C[PROTOTYPE];\n      return F;\n    // make static versions for prototype methods\n    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n    if (IS_PROTO) {\n      (exports.virtual || (exports.virtual = {}))[key] = out;\n      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);\n    }\n  }\n};\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library`\nmodule.exports = $export;\n\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports, __webpack_require__) {\n\ntry {\n  var util = __webpack_require__(2);\n  if (typeof util.inherits !== 'function') throw '';\n  module.exports = util.inherits;\n} catch (e) {\n  module.exports = __webpack_require__(224);\n}\n\n\n/***/ }),\n/* 43 */,\n/* 44 */,\n/* 45 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.home = undefined;\n\nvar _rootUser;\n\nfunction _load_rootUser() {\n  return _rootUser = _interopRequireDefault(__webpack_require__(169));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst path = __webpack_require__(0);\n\nconst home = exports.home = __webpack_require__(36).homedir();\n\nconst userHomeDir = (_rootUser || _load_rootUser()).default ? path.resolve('/usr/local/share') : home;\n\nexports.default = userHomeDir;\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports) {\n\nmodule.exports = function (it) {\n  if (typeof it != 'function') throw TypeError(it + ' is not a function!');\n  return it;\n};\n\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports) {\n\nvar toString = {}.toString;\n\nmodule.exports = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// optional / simple context binding\nvar aFunction = __webpack_require__(46);\nmodule.exports = function (fn, that, length) {\n  aFunction(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n\n\n/***/ }),\n/* 49 */\n/***/ (function(module, exports) {\n\nvar hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function (it, key) {\n  return hasOwnProperty.call(it, key);\n};\n\n\n/***/ }),\n/* 50 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar anObject = __webpack_require__(27);\nvar IE8_DOM_DEFINE = __webpack_require__(184);\nvar toPrimitive = __webpack_require__(201);\nvar dP = Object.defineProperty;\n\nexports.f = __webpack_require__(33) ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return dP(O, P, Attributes);\n  } catch (e) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\n\n/***/ }),\n/* 51 */,\n/* 52 */,\n/* 53 */,\n/* 54 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"events\");\n\n/***/ }),\n/* 55 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nconst Buffer = __webpack_require__(32).Buffer\n\nconst crypto = __webpack_require__(9)\nconst Transform = __webpack_require__(17).Transform\n\nconst SPEC_ALGORITHMS = ['sha256', 'sha384', 'sha512']\n\nconst BASE64_REGEX = /^[a-z0-9+/]+(?:=?=?)$/i\nconst SRI_REGEX = /^([^-]+)-([^?]+)([?\\S*]*)$/\nconst STRICT_SRI_REGEX = /^([^-]+)-([A-Za-z0-9+/=]{44,88})(\\?[\\x21-\\x7E]*)*$/\nconst VCHAR_REGEX = /^[\\x21-\\x7E]+$/\n\nclass Hash {\n  get isHash () { return true }\n  constructor (hash, opts) {\n    const strict = !!(opts && opts.strict)\n    this.source = hash.trim()\n    // 3.1. Integrity metadata (called \"Hash\" by ssri)\n    // https://w3c.github.io/webappsec-subresource-integrity/#integrity-metadata-description\n    const match = this.source.match(\n      strict\n      ? STRICT_SRI_REGEX\n      : SRI_REGEX\n    )\n    if (!match) { return }\n    if (strict && !SPEC_ALGORITHMS.some(a => a === match[1])) { return }\n    this.algorithm = match[1]\n    this.digest = match[2]\n\n    const rawOpts = match[3]\n    this.options = rawOpts ? rawOpts.slice(1).split('?') : []\n  }\n  hexDigest () {\n    return this.digest && Buffer.from(this.digest, 'base64').toString('hex')\n  }\n  toJSON () {\n    return this.toString()\n  }\n  toString (opts) {\n    if (opts && opts.strict) {\n      // Strict mode enforces the standard as close to the foot of the\n      // letter as it can.\n      if (!(\n        // The spec has very restricted productions for algorithms.\n        // https://www.w3.org/TR/CSP2/#source-list-syntax\n        SPEC_ALGORITHMS.some(x => x === this.algorithm) &&\n        // Usually, if someone insists on using a \"different\" base64, we\n        // leave it as-is, since there's multiple standards, and the\n        // specified is not a URL-safe variant.\n        // https://www.w3.org/TR/CSP2/#base64_value\n        this.digest.match(BASE64_REGEX) &&\n        // Option syntax is strictly visual chars.\n        // https://w3c.github.io/webappsec-subresource-integrity/#grammardef-option-expression\n        // https://tools.ietf.org/html/rfc5234#appendix-B.1\n        (this.options || []).every(opt => opt.match(VCHAR_REGEX))\n      )) {\n        return ''\n      }\n    }\n    const options = this.options && this.options.length\n    ? `?${this.options.join('?')}`\n    : ''\n    return `${this.algorithm}-${this.digest}${options}`\n  }\n}\n\nclass Integrity {\n  get isIntegrity () { return true }\n  toJSON () {\n    return this.toString()\n  }\n  toString (opts) {\n    opts = opts || {}\n    let sep = opts.sep || ' '\n    if (opts.strict) {\n      // Entries must be separated by whitespace, according to spec.\n      sep = sep.replace(/\\S+/g, ' ')\n    }\n    return Object.keys(this).map(k => {\n      return this[k].map(hash => {\n        return Hash.prototype.toString.call(hash, opts)\n      }).filter(x => x.length).join(sep)\n    }).filter(x => x.length).join(sep)\n  }\n  concat (integrity, opts) {\n    const other = typeof integrity === 'string'\n    ? integrity\n    : stringify(integrity, opts)\n    return parse(`${this.toString(opts)} ${other}`, opts)\n  }\n  hexDigest () {\n    return parse(this, {single: true}).hexDigest()\n  }\n  match (integrity, opts) {\n    const other = parse(integrity, opts)\n    const algo = other.pickAlgorithm(opts)\n    return (\n      this[algo] &&\n      other[algo] &&\n      this[algo].find(hash =>\n        other[algo].find(otherhash =>\n          hash.digest === otherhash.digest\n        )\n      )\n    ) || false\n  }\n  pickAlgorithm (opts) {\n    const pickAlgorithm = (opts && opts.pickAlgorithm) || getPrioritizedHash\n    const keys = Object.keys(this)\n    if (!keys.length) {\n      throw new Error(`No algorithms available for ${\n        JSON.stringify(this.toString())\n      }`)\n    }\n    return keys.reduce((acc, algo) => {\n      return pickAlgorithm(acc, algo) || acc\n    })\n  }\n}\n\nmodule.exports.parse = parse\nfunction parse (sri, opts) {\n  opts = opts || {}\n  if (typeof sri === 'string') {\n    return _parse(sri, opts)\n  } else if (sri.algorithm && sri.digest) {\n    const fullSri = new Integrity()\n    fullSri[sri.algorithm] = [sri]\n    return _parse(stringify(fullSri, opts), opts)\n  } else {\n    return _parse(stringify(sri, opts), opts)\n  }\n}\n\nfunction _parse (integrity, opts) {\n  // 3.4.3. Parse metadata\n  // https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n  if (opts.single) {\n    return new Hash(integrity, opts)\n  }\n  return integrity.trim().split(/\\s+/).reduce((acc, string) => {\n    const hash = new Hash(string, opts)\n    if (hash.algorithm && hash.digest) {\n      const algo = hash.algorithm\n      if (!acc[algo]) { acc[algo] = [] }\n      acc[algo].push(hash)\n    }\n    return acc\n  }, new Integrity())\n}\n\nmodule.exports.stringify = stringify\nfunction stringify (obj, opts) {\n  if (obj.algorithm && obj.digest) {\n    return Hash.prototype.toString.call(obj, opts)\n  } else if (typeof obj === 'string') {\n    return stringify(parse(obj, opts), opts)\n  } else {\n    return Integrity.prototype.toString.call(obj, opts)\n  }\n}\n\nmodule.exports.fromHex = fromHex\nfunction fromHex (hexDigest, algorithm, opts) {\n  const optString = (opts && opts.options && opts.options.length)\n  ? `?${opts.options.join('?')}`\n  : ''\n  return parse(\n    `${algorithm}-${\n      Buffer.from(hexDigest, 'hex').toString('base64')\n    }${optString}`, opts\n  )\n}\n\nmodule.exports.fromData = fromData\nfunction fromData (data, opts) {\n  opts = opts || {}\n  const algorithms = opts.algorithms || ['sha512']\n  const optString = opts.options && opts.options.length\n  ? `?${opts.options.join('?')}`\n  : ''\n  return algorithms.reduce((acc, algo) => {\n    const digest = crypto.createHash(algo).update(data).digest('base64')\n    const hash = new Hash(\n      `${algo}-${digest}${optString}`,\n       opts\n    )\n    if (hash.algorithm && hash.digest) {\n      const algo = hash.algorithm\n      if (!acc[algo]) { acc[algo] = [] }\n      acc[algo].push(hash)\n    }\n    return acc\n  }, new Integrity())\n}\n\nmodule.exports.fromStream = fromStream\nfunction fromStream (stream, opts) {\n  opts = opts || {}\n  const P = opts.Promise || Promise\n  const istream = integrityStream(opts)\n  return new P((resolve, reject) => {\n    stream.pipe(istream)\n    stream.on('error', reject)\n    istream.on('error', reject)\n    let sri\n    istream.on('integrity', s => { sri = s })\n    istream.on('end', () => resolve(sri))\n    istream.on('data', () => {})\n  })\n}\n\nmodule.exports.checkData = checkData\nfunction checkData (data, sri, opts) {\n  opts = opts || {}\n  sri = parse(sri, opts)\n  if (!Object.keys(sri).length) {\n    if (opts.error) {\n      throw Object.assign(\n        new Error('No valid integrity hashes to check against'), {\n          code: 'EINTEGRITY'\n        }\n      )\n    } else {\n      return false\n    }\n  }\n  const algorithm = sri.pickAlgorithm(opts)\n  const digest = crypto.createHash(algorithm).update(data).digest('base64')\n  const newSri = parse({algorithm, digest})\n  const match = newSri.match(sri, opts)\n  if (match || !opts.error) {\n    return match\n  } else if (typeof opts.size === 'number' && (data.length !== opts.size)) {\n    const err = new Error(`data size mismatch when checking ${sri}.\\n  Wanted: ${opts.size}\\n  Found: ${data.length}`)\n    err.code = 'EBADSIZE'\n    err.found = data.length\n    err.expected = opts.size\n    err.sri = sri\n    throw err\n  } else {\n    const err = new Error(`Integrity checksum failed when using ${algorithm}: Wanted ${sri}, but got ${newSri}. (${data.length} bytes)`)\n    err.code = 'EINTEGRITY'\n    err.found = newSri\n    err.expected = sri\n    err.algorithm = algorithm\n    err.sri = sri\n    throw err\n  }\n}\n\nmodule.exports.checkStream = checkStream\nfunction checkStream (stream, sri, opts) {\n  opts = opts || {}\n  const P = opts.Promise || Promise\n  const checker = integrityStream(Object.assign({}, opts, {\n    integrity: sri\n  }))\n  return new P((resolve, reject) => {\n    stream.pipe(checker)\n    stream.on('error', reject)\n    checker.on('error', reject)\n    let sri\n    checker.on('verified', s => { sri = s })\n    checker.on('end', () => resolve(sri))\n    checker.on('data', () => {})\n  })\n}\n\nmodule.exports.integrityStream = integrityStream\nfunction integrityStream (opts) {\n  opts = opts || {}\n  // For verification\n  const sri = opts.integrity && parse(opts.integrity, opts)\n  const goodSri = sri && Object.keys(sri).length\n  const algorithm = goodSri && sri.pickAlgorithm(opts)\n  const digests = goodSri && sri[algorithm]\n  // Calculating stream\n  const algorithms = Array.from(\n    new Set(\n      (opts.algorithms || ['sha512'])\n      .concat(algorithm ? [algorithm] : [])\n    )\n  )\n  const hashes = algorithms.map(crypto.createHash)\n  let streamSize = 0\n  const stream = new Transform({\n    transform (chunk, enc, cb) {\n      streamSize += chunk.length\n      hashes.forEach(h => h.update(chunk, enc))\n      cb(null, chunk, enc)\n    }\n  }).on('end', () => {\n    const optString = (opts.options && opts.options.length)\n    ? `?${opts.options.join('?')}`\n    : ''\n    const newSri = parse(hashes.map((h, i) => {\n      return `${algorithms[i]}-${h.digest('base64')}${optString}`\n    }).join(' '), opts)\n    // Integrity verification mode\n    const match = goodSri && newSri.match(sri, opts)\n    if (typeof opts.size === 'number' && streamSize !== opts.size) {\n      const err = new Error(`stream size mismatch when checking ${sri}.\\n  Wanted: ${opts.size}\\n  Found: ${streamSize}`)\n      err.code = 'EBADSIZE'\n      err.found = streamSize\n      err.expected = opts.size\n      err.sri = sri\n      stream.emit('error', err)\n    } else if (opts.integrity && !match) {\n      const err = new Error(`${sri} integrity checksum failed when using ${algorithm}: wanted ${digests} but got ${newSri}. (${streamSize} bytes)`)\n      err.code = 'EINTEGRITY'\n      err.found = newSri\n      err.expected = digests\n      err.algorithm = algorithm\n      err.sri = sri\n      stream.emit('error', err)\n    } else {\n      stream.emit('size', streamSize)\n      stream.emit('integrity', newSri)\n      match && stream.emit('verified', match)\n    }\n  })\n  return stream\n}\n\nmodule.exports.create = createIntegrity\nfunction createIntegrity (opts) {\n  opts = opts || {}\n  const algorithms = opts.algorithms || ['sha512']\n  const optString = opts.options && opts.options.length\n  ? `?${opts.options.join('?')}`\n  : ''\n\n  const hashes = algorithms.map(crypto.createHash)\n\n  return {\n    update: function (chunk, enc) {\n      hashes.forEach(h => h.update(chunk, enc))\n      return this\n    },\n    digest: function (enc) {\n      const integrity = algorithms.reduce((acc, algo) => {\n        const digest = hashes.shift().digest('base64')\n        const hash = new Hash(\n          `${algo}-${digest}${optString}`,\n          opts\n        )\n        if (hash.algorithm && hash.digest) {\n          const algo = hash.algorithm\n          if (!acc[algo]) { acc[algo] = [] }\n          acc[algo].push(hash)\n        }\n        return acc\n      }, new Integrity())\n\n      return integrity\n    }\n  }\n}\n\nconst NODE_HASHES = new Set(crypto.getHashes())\n\n// This is a Best Effort™ at a reasonable priority for hash algos\nconst DEFAULT_PRIORITY = [\n  'md5', 'whirlpool', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512',\n  // TODO - it's unclear _which_ of these Node will actually use as its name\n  //        for the algorithm, so we guesswork it based on the OpenSSL names.\n  'sha3',\n  'sha3-256', 'sha3-384', 'sha3-512',\n  'sha3_256', 'sha3_384', 'sha3_512'\n].filter(algo => NODE_HASHES.has(algo))\n\nfunction getPrioritizedHash (algo1, algo2) {\n  return DEFAULT_PRIORITY.indexOf(algo1.toLowerCase()) >= DEFAULT_PRIORITY.indexOf(algo2.toLowerCase())\n  ? algo1\n  : algo2\n}\n\n\n/***/ }),\n/* 56 */,\n/* 57 */,\n/* 58 */,\n/* 59 */,\n/* 60 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = minimatch\nminimatch.Minimatch = Minimatch\n\nvar path = { sep: '/' }\ntry {\n  path = __webpack_require__(0)\n} catch (er) {}\n\nvar GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}\nvar expand = __webpack_require__(175)\n\nvar plTypes = {\n  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},\n  '?': { open: '(?:', close: ')?' },\n  '+': { open: '(?:', close: ')+' },\n  '*': { open: '(?:', close: ')*' },\n  '@': { open: '(?:', close: ')' }\n}\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nvar qmark = '[^/]'\n\n// * => any number of characters\nvar star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nvar twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nvar twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?'\n\n// characters that need to be escaped in RegExp.\nvar reSpecials = charSet('().*{}+?[]^$\\\\!')\n\n// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet (s) {\n  return s.split('').reduce(function (set, c) {\n    set[c] = true\n    return set\n  }, {})\n}\n\n// normalizes slashes.\nvar slashSplit = /\\/+/\n\nminimatch.filter = filter\nfunction filter (pattern, options) {\n  options = options || {}\n  return function (p, i, list) {\n    return minimatch(p, pattern, options)\n  }\n}\n\nfunction ext (a, b) {\n  a = a || {}\n  b = b || {}\n  var t = {}\n  Object.keys(b).forEach(function (k) {\n    t[k] = b[k]\n  })\n  Object.keys(a).forEach(function (k) {\n    t[k] = a[k]\n  })\n  return t\n}\n\nminimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return minimatch\n\n  var orig = minimatch\n\n  var m = function minimatch (p, pattern, options) {\n    return orig.minimatch(p, pattern, ext(def, options))\n  }\n\n  m.Minimatch = function Minimatch (pattern, options) {\n    return new orig.Minimatch(pattern, ext(def, options))\n  }\n\n  return m\n}\n\nMinimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return Minimatch\n  return minimatch.defaults(def).Minimatch\n}\n\nfunction minimatch (p, pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  // \"\" only matches \"\"\n  if (pattern.trim() === '') return p === ''\n\n  return new Minimatch(pattern, options).match(p)\n}\n\nfunction Minimatch (pattern, options) {\n  if (!(this instanceof Minimatch)) {\n    return new Minimatch(pattern, options)\n  }\n\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n  pattern = pattern.trim()\n\n  // windows support: need to use /, not \\\n  if (path.sep !== '/') {\n    pattern = pattern.split(path.sep).join('/')\n  }\n\n  this.options = options\n  this.set = []\n  this.pattern = pattern\n  this.regexp = null\n  this.negate = false\n  this.comment = false\n  this.empty = false\n\n  // make the set of regexps etc.\n  this.make()\n}\n\nMinimatch.prototype.debug = function () {}\n\nMinimatch.prototype.make = make\nfunction make () {\n  // don't do it more than once.\n  if (this._made) return\n\n  var pattern = this.pattern\n  var options = this.options\n\n  // empty patterns and comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    this.comment = true\n    return\n  }\n  if (!pattern) {\n    this.empty = true\n    return\n  }\n\n  // step 1: figure out negation, etc.\n  this.parseNegate()\n\n  // step 2: expand braces\n  var set = this.globSet = this.braceExpand()\n\n  if (options.debug) this.debug = console.error\n\n  this.debug(this.pattern, set)\n\n  // step 3: now we have a set, so turn each one into a series of path-portion\n  // matching patterns.\n  // These will be regexps, except in the case of \"**\", which is\n  // set to the GLOBSTAR object for globstar behavior,\n  // and will not contain any / characters\n  set = this.globParts = set.map(function (s) {\n    return s.split(slashSplit)\n  })\n\n  this.debug(this.pattern, set)\n\n  // glob --> regexps\n  set = set.map(function (s, si, set) {\n    return s.map(this.parse, this)\n  }, this)\n\n  this.debug(this.pattern, set)\n\n  // filter out everything that didn't compile properly.\n  set = set.filter(function (s) {\n    return s.indexOf(false) === -1\n  })\n\n  this.debug(this.pattern, set)\n\n  this.set = set\n}\n\nMinimatch.prototype.parseNegate = parseNegate\nfunction parseNegate () {\n  var pattern = this.pattern\n  var negate = false\n  var options = this.options\n  var negateOffset = 0\n\n  if (options.nonegate) return\n\n  for (var i = 0, l = pattern.length\n    ; i < l && pattern.charAt(i) === '!'\n    ; i++) {\n    negate = !negate\n    negateOffset++\n  }\n\n  if (negateOffset) this.pattern = pattern.substr(negateOffset)\n  this.negate = negate\n}\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = function (pattern, options) {\n  return braceExpand(pattern, options)\n}\n\nMinimatch.prototype.braceExpand = braceExpand\n\nfunction braceExpand (pattern, options) {\n  if (!options) {\n    if (this instanceof Minimatch) {\n      options = this.options\n    } else {\n      options = {}\n    }\n  }\n\n  pattern = typeof pattern === 'undefined'\n    ? this.pattern : pattern\n\n  if (typeof pattern === 'undefined') {\n    throw new TypeError('undefined pattern')\n  }\n\n  if (options.nobrace ||\n    !pattern.match(/\\{.*\\}/)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse = parse\nvar SUBPARSE = {}\nfunction parse (pattern, isSub) {\n  if (pattern.length > 1024 * 64) {\n    throw new TypeError('pattern is too long')\n  }\n\n  var options = this.options\n\n  // shortcuts\n  if (!options.noglobstar && pattern === '**') return GLOBSTAR\n  if (pattern === '') return ''\n\n  var re = ''\n  var hasMagic = !!options.nocase\n  var escaping = false\n  // ? => one single character\n  var patternListStack = []\n  var negativeLists = []\n  var stateChar\n  var inClass = false\n  var reClassStart = -1\n  var classStart = -1\n  // . and .. never match anything that doesn't start with .,\n  // even when options.dot is set.\n  var patternStart = pattern.charAt(0) === '.' ? '' // anything\n  // not (start or / followed by . or .. followed by / or end)\n  : options.dot ? '(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))'\n  : '(?!\\\\.)'\n  var self = this\n\n  function clearStateChar () {\n    if (stateChar) {\n      // we had some state-tracking character\n      // that wasn't consumed by this pass.\n      switch (stateChar) {\n        case '*':\n          re += star\n          hasMagic = true\n        break\n        case '?':\n          re += qmark\n          hasMagic = true\n        break\n        default:\n          re += '\\\\' + stateChar\n        break\n      }\n      self.debug('clearStateChar %j %j', stateChar, re)\n      stateChar = false\n    }\n  }\n\n  for (var i = 0, len = pattern.length, c\n    ; (i < len) && (c = pattern.charAt(i))\n    ; i++) {\n    this.debug('%s\\t%s %s %j', pattern, i, re, c)\n\n    // skip over any that are escaped.\n    if (escaping && reSpecials[c]) {\n      re += '\\\\' + c\n      escaping = false\n      continue\n    }\n\n    switch (c) {\n      case '/':\n        // completely not allowed, even escaped.\n        // Should already be path-split by now.\n        return false\n\n      case '\\\\':\n        clearStateChar()\n        escaping = true\n      continue\n\n      // the various stateChar values\n      // for the \"extglob\" stuff.\n      case '?':\n      case '*':\n      case '+':\n      case '@':\n      case '!':\n        this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c)\n\n        // all of those are literals inside a class, except that\n        // the glob [!a] means [^a] in regexp\n        if (inClass) {\n          this.debug('  in class')\n          if (c === '!' && i === classStart + 1) c = '^'\n          re += c\n          continue\n        }\n\n        // if we already have a stateChar, then it means\n        // that there was something like ** or +? in there.\n        // Handle the stateChar, then proceed with this one.\n        self.debug('call clearStateChar %j', stateChar)\n        clearStateChar()\n        stateChar = c\n        // if extglob is disabled, then +(asdf|foo) isn't a thing.\n        // just clear the statechar *now*, rather than even diving into\n        // the patternList stuff.\n        if (options.noext) clearStateChar()\n      continue\n\n      case '(':\n        if (inClass) {\n          re += '('\n          continue\n        }\n\n        if (!stateChar) {\n          re += '\\\\('\n          continue\n        }\n\n        patternListStack.push({\n          type: stateChar,\n          start: i - 1,\n          reStart: re.length,\n          open: plTypes[stateChar].open,\n          close: plTypes[stateChar].close\n        })\n        // negation is (?:(?!js)[^/]*)\n        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'\n        this.debug('plType %j %j', stateChar, re)\n        stateChar = false\n      continue\n\n      case ')':\n        if (inClass || !patternListStack.length) {\n          re += '\\\\)'\n          continue\n        }\n\n        clearStateChar()\n        hasMagic = true\n        var pl = patternListStack.pop()\n        // negation is (?:(?!js)[^/]*)\n        // The others are (?:<pattern>)<type>\n        re += pl.close\n        if (pl.type === '!') {\n          negativeLists.push(pl)\n        }\n        pl.reEnd = re.length\n      continue\n\n      case '|':\n        if (inClass || !patternListStack.length || escaping) {\n          re += '\\\\|'\n          escaping = false\n          continue\n        }\n\n        clearStateChar()\n        re += '|'\n      continue\n\n      // these are mostly the same in regexp and glob\n      case '[':\n        // swallow any state-tracking char before the [\n        clearStateChar()\n\n        if (inClass) {\n          re += '\\\\' + c\n          continue\n        }\n\n        inClass = true\n        classStart = i\n        reClassStart = re.length\n        re += c\n      continue\n\n      case ']':\n        //  a right bracket shall lose its special\n        //  meaning and represent itself in\n        //  a bracket expression if it occurs\n        //  first in the list.  -- POSIX.2 2.8.3.2\n        if (i === classStart + 1 || !inClass) {\n          re += '\\\\' + c\n          escaping = false\n          continue\n        }\n\n        // handle the case where we left a class open.\n        // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n        if (inClass) {\n          // split where the last [ was, make sure we don't have\n          // an invalid re. if so, re-walk the contents of the\n          // would-be class to re-translate any characters that\n          // were passed through as-is\n          // TODO: It would probably be faster to determine this\n          // without a try/catch and a new RegExp, but it's tricky\n          // to do safely.  For now, this is safe and works.\n          var cs = pattern.substring(classStart + 1, i)\n          try {\n            RegExp('[' + cs + ']')\n          } catch (er) {\n            // not a valid class!\n            var sp = this.parse(cs, SUBPARSE)\n            re = re.substr(0, reClassStart) + '\\\\[' + sp[0] + '\\\\]'\n            hasMagic = hasMagic || sp[1]\n            inClass = false\n            continue\n          }\n        }\n\n        // finish up the class.\n        hasMagic = true\n        inClass = false\n        re += c\n      continue\n\n      default:\n        // swallow any state char that wasn't consumed\n        clearStateChar()\n\n        if (escaping) {\n          // no need\n          escaping = false\n        } else if (reSpecials[c]\n          && !(c === '^' && inClass)) {\n          re += '\\\\'\n        }\n\n        re += c\n\n    } // switch\n  } // for\n\n  // handle the case where we left a class open.\n  // \"[abc\" is valid, equivalent to \"\\[abc\"\n  if (inClass) {\n    // split where the last [ was, and escape it\n    // this is a huge pita.  We now have to re-walk\n    // the contents of the would-be class to re-translate\n    // any characters that were passed through as-is\n    cs = pattern.substr(classStart + 1)\n    sp = this.parse(cs, SUBPARSE)\n    re = re.substr(0, reClassStart) + '\\\\[' + sp[0]\n    hasMagic = hasMagic || sp[1]\n  }\n\n  // handle the case where we had a +( thing at the *end*\n  // of the pattern.\n  // each pattern list stack adds 3 chars, and we need to go through\n  // and escape any | chars that were passed through as-is for the regexp.\n  // Go through and escape them, taking care not to double-escape any\n  // | chars that were already escaped.\n  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n    var tail = re.slice(pl.reStart + pl.open.length)\n    this.debug('setting tail', re, pl)\n    // maybe some even number of \\, then maybe 1 \\, followed by a |\n    tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, function (_, $1, $2) {\n      if (!$2) {\n        // the | isn't already escaped, so escape it.\n        $2 = '\\\\'\n      }\n\n      // need to escape all those slashes *again*, without escaping the\n      // one that we need for escaping the | character.  As it works out,\n      // escaping an even number of slashes can be done by simply repeating\n      // it exactly after itself.  That's why this trick works.\n      //\n      // I am sorry that you have to see this.\n      return $1 + $1 + $2 + '|'\n    })\n\n    this.debug('tail=%j\\n   %s', tail, tail, pl, re)\n    var t = pl.type === '*' ? star\n      : pl.type === '?' ? qmark\n      : '\\\\' + pl.type\n\n    hasMagic = true\n    re = re.slice(0, pl.reStart) + t + '\\\\(' + tail\n  }\n\n  // handle trailing things that only matter at the very end.\n  clearStateChar()\n  if (escaping) {\n    // trailing \\\\\n    re += '\\\\\\\\'\n  }\n\n  // only need to apply the nodot start if the re starts with\n  // something that could conceivably capture a dot\n  var addPatternStart = false\n  switch (re.charAt(0)) {\n    case '.':\n    case '[':\n    case '(': addPatternStart = true\n  }\n\n  // Hack to work around lack of negative lookbehind in JS\n  // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n  // like 'a.xyz.yz' doesn't match.  So, the first negative\n  // lookahead, has to look ALL the way ahead, to the end of\n  // the pattern.\n  for (var n = negativeLists.length - 1; n > -1; n--) {\n    var nl = negativeLists[n]\n\n    var nlBefore = re.slice(0, nl.reStart)\n    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)\n    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)\n    var nlAfter = re.slice(nl.reEnd)\n\n    nlLast += nlAfter\n\n    // Handle nested stuff like *(*.js|!(*.json)), where open parens\n    // mean that we should *not* include the ) in the bit that is considered\n    // \"after\" the negated section.\n    var openParensBefore = nlBefore.split('(').length - 1\n    var cleanAfter = nlAfter\n    for (i = 0; i < openParensBefore; i++) {\n      cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '')\n    }\n    nlAfter = cleanAfter\n\n    var dollar = ''\n    if (nlAfter === '' && isSub !== SUBPARSE) {\n      dollar = '$'\n    }\n    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast\n    re = newRe\n  }\n\n  // if the re is not \"\" at this point, then we need to make sure\n  // it doesn't match against an empty path part.\n  // Otherwise a/* will match a/, which it should not.\n  if (re !== '' && hasMagic) {\n    re = '(?=.)' + re\n  }\n\n  if (addPatternStart) {\n    re = patternStart + re\n  }\n\n  // parsing just a piece of a larger pattern.\n  if (isSub === SUBPARSE) {\n    return [re, hasMagic]\n  }\n\n  // skip the regexp for non-magical patterns\n  // unescape anything in it, though, so that it'll be\n  // an exact match against a file etc.\n  if (!hasMagic) {\n    return globUnescape(pattern)\n  }\n\n  var flags = options.nocase ? 'i' : ''\n  try {\n    var regExp = new RegExp('^' + re + '$', flags)\n  } catch (er) {\n    // If it was an invalid regular expression, then it can't match\n    // anything.  This trick looks for a character after the end of\n    // the string, which is of course impossible, except in multi-line\n    // mode, but it's not a /m regex.\n    return new RegExp('$.')\n  }\n\n  regExp._glob = pattern\n  regExp._src = re\n\n  return regExp\n}\n\nminimatch.makeRe = function (pattern, options) {\n  return new Minimatch(pattern, options || {}).makeRe()\n}\n\nMinimatch.prototype.makeRe = makeRe\nfunction makeRe () {\n  if (this.regexp || this.regexp === false) return this.regexp\n\n  // at this point, this.set is a 2d array of partial\n  // pattern strings, or \"**\".\n  //\n  // It's better to use .match().  This function shouldn't\n  // be used, really, but it's pretty convenient sometimes,\n  // when you just want to work with a regex.\n  var set = this.set\n\n  if (!set.length) {\n    this.regexp = false\n    return this.regexp\n  }\n  var options = this.options\n\n  var twoStar = options.noglobstar ? star\n    : options.dot ? twoStarDot\n    : twoStarNoDot\n  var flags = options.nocase ? 'i' : ''\n\n  var re = set.map(function (pattern) {\n    return pattern.map(function (p) {\n      return (p === GLOBSTAR) ? twoStar\n      : (typeof p === 'string') ? regExpEscape(p)\n      : p._src\n    }).join('\\\\\\/')\n  }).join('|')\n\n  // must match entire pattern\n  // ending in a * or ** will make it less strict.\n  re = '^(?:' + re + ')$'\n\n  // can match anything, as long as it's not this.\n  if (this.negate) re = '^(?!' + re + ').*$'\n\n  try {\n    this.regexp = new RegExp(re, flags)\n  } catch (ex) {\n    this.regexp = false\n  }\n  return this.regexp\n}\n\nminimatch.match = function (list, pattern, options) {\n  options = options || {}\n  var mm = new Minimatch(pattern, options)\n  list = list.filter(function (f) {\n    return mm.match(f)\n  })\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\n\nMinimatch.prototype.match = match\nfunction match (f, partial) {\n  this.debug('match', f, this.pattern)\n  // short-circuit in the case of busted things.\n  // comments, etc.\n  if (this.comment) return false\n  if (this.empty) return f === ''\n\n  if (f === '/' && partial) return true\n\n  var options = this.options\n\n  // windows: need to use /, not \\\n  if (path.sep !== '/') {\n    f = f.split(path.sep).join('/')\n  }\n\n  // treat the test path as a set of pathparts.\n  f = f.split(slashSplit)\n  this.debug(this.pattern, 'split', f)\n\n  // just ONE of the pattern sets in this.set needs to match\n  // in order for it to be valid.  If negating, then just one\n  // match means that we have failed.\n  // Either way, return on the first hit.\n\n  var set = this.set\n  this.debug(this.pattern, 'set', set)\n\n  // Find the basename of the path by looking for the last non-empty segment\n  var filename\n  var i\n  for (i = f.length - 1; i >= 0; i--) {\n    filename = f[i]\n    if (filename) break\n  }\n\n  for (i = 0; i < set.length; i++) {\n    var pattern = set[i]\n    var file = f\n    if (options.matchBase && pattern.length === 1) {\n      file = [filename]\n    }\n    var hit = this.matchOne(file, pattern, partial)\n    if (hit) {\n      if (options.flipNegate) return true\n      return !this.negate\n    }\n  }\n\n  // didn't get any hits.  this is success if it's a negative\n  // pattern, failure otherwise.\n  if (options.flipNegate) return false\n  return this.negate\n}\n\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne = function (file, pattern, partial) {\n  var options = this.options\n\n  this.debug('matchOne',\n    { 'this': this, file: file, pattern: pattern })\n\n  this.debug('matchOne', file.length, pattern.length)\n\n  for (var fi = 0,\n      pi = 0,\n      fl = file.length,\n      pl = pattern.length\n      ; (fi < fl) && (pi < pl)\n      ; fi++, pi++) {\n    this.debug('matchOne loop')\n    var p = pattern[pi]\n    var f = file[fi]\n\n    this.debug(pattern, p, f)\n\n    // should be impossible.\n    // some invalid regexp stuff in the set.\n    if (p === false) return false\n\n    if (p === GLOBSTAR) {\n      this.debug('GLOBSTAR', [pattern, p, f])\n\n      // \"**\"\n      // a/**/b/**/c would match the following:\n      // a/b/x/y/z/c\n      // a/x/y/z/b/c\n      // a/b/x/b/x/c\n      // a/b/c\n      // To do this, take the rest of the pattern after\n      // the **, and see if it would match the file remainder.\n      // If so, return success.\n      // If not, the ** \"swallows\" a segment, and try again.\n      // This is recursively awful.\n      //\n      // a/**/b/**/c matching a/b/x/y/z/c\n      // - a matches a\n      // - doublestar\n      //   - matchOne(b/x/y/z/c, b/**/c)\n      //     - b matches b\n      //     - doublestar\n      //       - matchOne(x/y/z/c, c) -> no\n      //       - matchOne(y/z/c, c) -> no\n      //       - matchOne(z/c, c) -> no\n      //       - matchOne(c, c) yes, hit\n      var fr = fi\n      var pr = pi + 1\n      if (pr === pl) {\n        this.debug('** at the end')\n        // a ** at the end will just swallow the rest.\n        // We have found a match.\n        // however, it will not swallow /.x, unless\n        // options.dot is set.\n        // . and .. are *never* matched by **, for explosively\n        // exponential reasons.\n        for (; fi < fl; fi++) {\n          if (file[fi] === '.' || file[fi] === '..' ||\n            (!options.dot && file[fi].charAt(0) === '.')) return false\n        }\n        return true\n      }\n\n      // ok, let's see if we can swallow whatever we can.\n      while (fr < fl) {\n        var swallowee = file[fr]\n\n        this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n        // XXX remove this slice.  Just pass the start index.\n        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n          this.debug('globstar found match!', fr, fl, swallowee)\n          // found a match.\n          return true\n        } else {\n          // can't swallow \".\" or \"..\" ever.\n          // can only swallow \".foo\" when explicitly asked.\n          if (swallowee === '.' || swallowee === '..' ||\n            (!options.dot && swallowee.charAt(0) === '.')) {\n            this.debug('dot detected!', file, fr, pattern, pr)\n            break\n          }\n\n          // ** swallows a segment, and continue.\n          this.debug('globstar swallow a segment, and continue')\n          fr++\n        }\n      }\n\n      // no match was found.\n      // However, in partial mode, we can't say this is necessarily over.\n      // If there's more *pattern* left, then\n      if (partial) {\n        // ran out of file\n        this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n        if (fr === fl) return true\n      }\n      return false\n    }\n\n    // something other than **\n    // non-magic patterns just have to match exactly\n    // patterns with magic have been turned into regexps.\n    var hit\n    if (typeof p === 'string') {\n      if (options.nocase) {\n        hit = f.toLowerCase() === p.toLowerCase()\n      } else {\n        hit = f === p\n      }\n      this.debug('string match', p, f, hit)\n    } else {\n      hit = f.match(p)\n      this.debug('pattern match', p, f, hit)\n    }\n\n    if (!hit) return false\n  }\n\n  // Note: ending in / means that we'll get a final \"\"\n  // at the end of the pattern.  This can only match a\n  // corresponding \"\" at the end of the file.\n  // If the file ends in /, then it can only match a\n  // a pattern that ends in /, unless the pattern just\n  // doesn't have any more for it. But, a/b/ should *not*\n  // match \"a/b/*\", even though \"\" matches against the\n  // [^/]*? pattern, except in partial mode, where it might\n  // simply not be reached yet.\n  // However, a/b/ should still satisfy a/*\n\n  // now either we fell off the end of the pattern, or we're done.\n  if (fi === fl && pi === pl) {\n    // ran out of pattern and filename at the same time.\n    // an exact hit!\n    return true\n  } else if (fi === fl) {\n    // ran out of file, but still had pattern left.\n    // this is ok if we're doing the match as part of\n    // a glob fs traversal.\n    return partial\n  } else if (pi === pl) {\n    // ran out of pattern, still have file left.\n    // this is only acceptable if we're on the very last\n    // empty segment of a file with a trailing slash.\n    // a/* should match a/b/\n    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')\n    return emptyFileEnd\n  }\n\n  // should be unreachable.\n  throw new Error('wtf?')\n}\n\n// replace stuff like \\* with *\nfunction globUnescape (s) {\n  return s.replace(/\\\\(.)/g, '$1')\n}\n\nfunction regExpEscape (s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n}\n\n\n/***/ }),\n/* 61 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar wrappy = __webpack_require__(123)\nmodule.exports = wrappy(once)\nmodule.exports.strict = wrappy(onceStrict)\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n\n  Object.defineProperty(Function.prototype, 'onceStrict', {\n    value: function () {\n      return onceStrict(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n\nfunction onceStrict (fn) {\n  var f = function () {\n    if (f.called)\n      throw new Error(f.onceError)\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  var name = fn.name || 'Function wrapped with `once`'\n  f.onceError = name + \" shouldn't be called more than once\"\n  f.called = false\n  return f\n}\n\n\n/***/ }),\n/* 62 */,\n/* 63 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"buffer\");\n\n/***/ }),\n/* 64 */,\n/* 65 */,\n/* 66 */,\n/* 67 */\n/***/ (function(module, exports) {\n\n// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n\n\n/***/ }),\n/* 68 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(34);\nvar document = __webpack_require__(11).document;\n// typeof document.createElement is 'object' in old IE\nvar is = isObject(document) && isObject(document.createElement);\nmodule.exports = function (it) {\n  return is ? document.createElement(it) : {};\n};\n\n\n/***/ }),\n/* 69 */\n/***/ (function(module, exports) {\n\nmodule.exports = true;\n\n\n/***/ }),\n/* 70 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// 25.4.1.5 NewPromiseCapability(C)\nvar aFunction = __webpack_require__(46);\n\nfunction PromiseCapability(C) {\n  var resolve, reject;\n  this.promise = new C(function ($$resolve, $$reject) {\n    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');\n    resolve = $$resolve;\n    reject = $$reject;\n  });\n  this.resolve = aFunction(resolve);\n  this.reject = aFunction(reject);\n}\n\nmodule.exports.f = function (C) {\n  return new PromiseCapability(C);\n};\n\n\n/***/ }),\n/* 71 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar def = __webpack_require__(50).f;\nvar has = __webpack_require__(49);\nvar TAG = __webpack_require__(13)('toStringTag');\n\nmodule.exports = function (it, tag, stat) {\n  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });\n};\n\n\n/***/ }),\n/* 72 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar shared = __webpack_require__(107)('keys');\nvar uid = __webpack_require__(111);\nmodule.exports = function (key) {\n  return shared[key] || (shared[key] = uid(key));\n};\n\n\n/***/ }),\n/* 73 */\n/***/ (function(module, exports) {\n\n// 7.1.4 ToInteger\nvar ceil = Math.ceil;\nvar floor = Math.floor;\nmodule.exports = function (it) {\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n\n\n/***/ }),\n/* 74 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = __webpack_require__(131);\nvar defined = __webpack_require__(67);\nmodule.exports = function (it) {\n  return IObject(defined(it));\n};\n\n\n/***/ }),\n/* 75 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// Approach:\n//\n// 1. Get the minimatch set\n// 2. For each pattern in the set, PROCESS(pattern, false)\n// 3. Store matches per-set, then uniq them\n//\n// PROCESS(pattern, inGlobStar)\n// Get the first [n] items from pattern that are all strings\n// Join these together.  This is PREFIX.\n//   If there is no more remaining, then stat(PREFIX) and\n//   add to matches if it succeeds.  END.\n//\n// If inGlobStar and PREFIX is symlink and points to dir\n//   set ENTRIES = []\n// else readdir(PREFIX) as ENTRIES\n//   If fail, END\n//\n// with ENTRIES\n//   If pattern[n] is GLOBSTAR\n//     // handle the case where the globstar match is empty\n//     // by pruning it out, and testing the resulting pattern\n//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)\n//     // handle other cases.\n//     for ENTRY in ENTRIES (not dotfiles)\n//       // attach globstar + tail onto the entry\n//       // Mark that this entry is a globstar match\n//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)\n//\n//   else // not globstar\n//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)\n//       Test ENTRY against pattern[n]\n//       If fails, continue\n//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])\n//\n// Caveat:\n//   Cache all stats and readdirs results to minimize syscall.  Since all\n//   we ever care about is existence and directory-ness, we can just keep\n//   `true` for files, and [children,...] for directories, or `false` for\n//   things that don't exist.\n\nmodule.exports = glob\n\nvar fs = __webpack_require__(3)\nvar rp = __webpack_require__(114)\nvar minimatch = __webpack_require__(60)\nvar Minimatch = minimatch.Minimatch\nvar inherits = __webpack_require__(42)\nvar EE = __webpack_require__(54).EventEmitter\nvar path = __webpack_require__(0)\nvar assert = __webpack_require__(22)\nvar isAbsolute = __webpack_require__(76)\nvar globSync = __webpack_require__(218)\nvar common = __webpack_require__(115)\nvar alphasort = common.alphasort\nvar alphasorti = common.alphasorti\nvar setopts = common.setopts\nvar ownProp = common.ownProp\nvar inflight = __webpack_require__(223)\nvar util = __webpack_require__(2)\nvar childrenIgnored = common.childrenIgnored\nvar isIgnored = common.isIgnored\n\nvar once = __webpack_require__(61)\n\nfunction glob (pattern, options, cb) {\n  if (typeof options === 'function') cb = options, options = {}\n  if (!options) options = {}\n\n  if (options.sync) {\n    if (cb)\n      throw new TypeError('callback provided to sync glob')\n    return globSync(pattern, options)\n  }\n\n  return new Glob(pattern, options, cb)\n}\n\nglob.sync = globSync\nvar GlobSync = glob.GlobSync = globSync.GlobSync\n\n// old api surface\nglob.glob = glob\n\nfunction extend (origin, add) {\n  if (add === null || typeof add !== 'object') {\n    return origin\n  }\n\n  var keys = Object.keys(add)\n  var i = keys.length\n  while (i--) {\n    origin[keys[i]] = add[keys[i]]\n  }\n  return origin\n}\n\nglob.hasMagic = function (pattern, options_) {\n  var options = extend({}, options_)\n  options.noprocess = true\n\n  var g = new Glob(pattern, options)\n  var set = g.minimatch.set\n\n  if (!pattern)\n    return false\n\n  if (set.length > 1)\n    return true\n\n  for (var j = 0; j < set[0].length; j++) {\n    if (typeof set[0][j] !== 'string')\n      return true\n  }\n\n  return false\n}\n\nglob.Glob = Glob\ninherits(Glob, EE)\nfunction Glob (pattern, options, cb) {\n  if (typeof options === 'function') {\n    cb = options\n    options = null\n  }\n\n  if (options && options.sync) {\n    if (cb)\n      throw new TypeError('callback provided to sync glob')\n    return new GlobSync(pattern, options)\n  }\n\n  if (!(this instanceof Glob))\n    return new Glob(pattern, options, cb)\n\n  setopts(this, pattern, options)\n  this._didRealPath = false\n\n  // process each pattern in the minimatch set\n  var n = this.minimatch.set.length\n\n  // The matches are stored as {<filename>: true,...} so that\n  // duplicates are automagically pruned.\n  // Later, we do an Object.keys() on these.\n  // Keep them as a list so we can fill in when nonull is set.\n  this.matches = new Array(n)\n\n  if (typeof cb === 'function') {\n    cb = once(cb)\n    this.on('error', cb)\n    this.on('end', function (matches) {\n      cb(null, matches)\n    })\n  }\n\n  var self = this\n  this._processing = 0\n\n  this._emitQueue = []\n  this._processQueue = []\n  this.paused = false\n\n  if (this.noprocess)\n    return this\n\n  if (n === 0)\n    return done()\n\n  var sync = true\n  for (var i = 0; i < n; i ++) {\n    this._process(this.minimatch.set[i], i, false, done)\n  }\n  sync = false\n\n  function done () {\n    --self._processing\n    if (self._processing <= 0) {\n      if (sync) {\n        process.nextTick(function () {\n          self._finish()\n        })\n      } else {\n        self._finish()\n      }\n    }\n  }\n}\n\nGlob.prototype._finish = function () {\n  assert(this instanceof Glob)\n  if (this.aborted)\n    return\n\n  if (this.realpath && !this._didRealpath)\n    return this._realpath()\n\n  common.finish(this)\n  this.emit('end', this.found)\n}\n\nGlob.prototype._realpath = function () {\n  if (this._didRealpath)\n    return\n\n  this._didRealpath = true\n\n  var n = this.matches.length\n  if (n === 0)\n    return this._finish()\n\n  var self = this\n  for (var i = 0; i < this.matches.length; i++)\n    this._realpathSet(i, next)\n\n  function next () {\n    if (--n === 0)\n      self._finish()\n  }\n}\n\nGlob.prototype._realpathSet = function (index, cb) {\n  var matchset = this.matches[index]\n  if (!matchset)\n    return cb()\n\n  var found = Object.keys(matchset)\n  var self = this\n  var n = found.length\n\n  if (n === 0)\n    return cb()\n\n  var set = this.matches[index] = Object.create(null)\n  found.forEach(function (p, i) {\n    // If there's a problem with the stat, then it means that\n    // one or more of the links in the realpath couldn't be\n    // resolved.  just return the abs value in that case.\n    p = self._makeAbs(p)\n    rp.realpath(p, self.realpathCache, function (er, real) {\n      if (!er)\n        set[real] = true\n      else if (er.syscall === 'stat')\n        set[p] = true\n      else\n        self.emit('error', er) // srsly wtf right here\n\n      if (--n === 0) {\n        self.matches[index] = set\n        cb()\n      }\n    })\n  })\n}\n\nGlob.prototype._mark = function (p) {\n  return common.mark(this, p)\n}\n\nGlob.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f)\n}\n\nGlob.prototype.abort = function () {\n  this.aborted = true\n  this.emit('abort')\n}\n\nGlob.prototype.pause = function () {\n  if (!this.paused) {\n    this.paused = true\n    this.emit('pause')\n  }\n}\n\nGlob.prototype.resume = function () {\n  if (this.paused) {\n    this.emit('resume')\n    this.paused = false\n    if (this._emitQueue.length) {\n      var eq = this._emitQueue.slice(0)\n      this._emitQueue.length = 0\n      for (var i = 0; i < eq.length; i ++) {\n        var e = eq[i]\n        this._emitMatch(e[0], e[1])\n      }\n    }\n    if (this._processQueue.length) {\n      var pq = this._processQueue.slice(0)\n      this._processQueue.length = 0\n      for (var i = 0; i < pq.length; i ++) {\n        var p = pq[i]\n        this._processing--\n        this._process(p[0], p[1], p[2], p[3])\n      }\n    }\n  }\n}\n\nGlob.prototype._process = function (pattern, index, inGlobStar, cb) {\n  assert(this instanceof Glob)\n  assert(typeof cb === 'function')\n\n  if (this.aborted)\n    return\n\n  this._processing++\n  if (this.paused) {\n    this._processQueue.push([pattern, index, inGlobStar, cb])\n    return\n  }\n\n  //console.error('PROCESS %d', this._processing, pattern)\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0\n  while (typeof pattern[n] === 'string') {\n    n ++\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // see if there's anything else\n  var prefix\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index, cb)\n      return\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null\n      break\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/')\n      break\n  }\n\n  var remain = pattern.slice(n)\n\n  // get the list of entries.\n  var read\n  if (prefix === null)\n    read = '.'\n  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {\n    if (!prefix || !isAbsolute(prefix))\n      prefix = '/' + prefix\n    read = prefix\n  } else\n    read = prefix\n\n  var abs = this._makeAbs(read)\n\n  //if ignored, skip _processing\n  if (childrenIgnored(this, read))\n    return cb()\n\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR\n  if (isGlobStar)\n    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)\n  else\n    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)\n}\n\nGlob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n  var self = this\n  this._readdir(abs, inGlobStar, function (er, entries) {\n    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)\n  })\n}\n\nGlob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n\n  // if the abs isn't a dir, then nothing can match!\n  if (!entries)\n    return cb()\n\n  // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n  var pn = remain[0]\n  var negate = !!this.minimatch.negate\n  var rawGlob = pn._glob\n  var dotOk = this.dot || rawGlob.charAt(0) === '.'\n\n  var matchedEntries = []\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i]\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m\n      if (negate && !prefix) {\n        m = !e.match(pn)\n      } else {\n        m = e.match(pn)\n      }\n      if (m)\n        matchedEntries.push(e)\n    }\n  }\n\n  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)\n\n  var len = matchedEntries.length\n  // If there are no matched entries, then nothing matches.\n  if (len === 0)\n    return cb()\n\n  // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index])\n      this.matches[index] = Object.create(null)\n\n    for (var i = 0; i < len; i ++) {\n      var e = matchedEntries[i]\n      if (prefix) {\n        if (prefix !== '/')\n          e = prefix + '/' + e\n        else\n          e = prefix + e\n      }\n\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path.join(this.root, e)\n      }\n      this._emitMatch(index, e)\n    }\n    // This was the last one, and no stats were needed\n    return cb()\n  }\n\n  // now test all matched entries as stand-ins for that part\n  // of the pattern.\n  remain.shift()\n  for (var i = 0; i < len; i ++) {\n    var e = matchedEntries[i]\n    var newPattern\n    if (prefix) {\n      if (prefix !== '/')\n        e = prefix + '/' + e\n      else\n        e = prefix + e\n    }\n    this._process([e].concat(remain), index, inGlobStar, cb)\n  }\n  cb()\n}\n\nGlob.prototype._emitMatch = function (index, e) {\n  if (this.aborted)\n    return\n\n  if (isIgnored(this, e))\n    return\n\n  if (this.paused) {\n    this._emitQueue.push([index, e])\n    return\n  }\n\n  var abs = isAbsolute(e) ? e : this._makeAbs(e)\n\n  if (this.mark)\n    e = this._mark(e)\n\n  if (this.absolute)\n    e = abs\n\n  if (this.matches[index][e])\n    return\n\n  if (this.nodir) {\n    var c = this.cache[abs]\n    if (c === 'DIR' || Array.isArray(c))\n      return\n  }\n\n  this.matches[index][e] = true\n\n  var st = this.statCache[abs]\n  if (st)\n    this.emit('stat', e, st)\n\n  this.emit('match', e)\n}\n\nGlob.prototype._readdirInGlobStar = function (abs, cb) {\n  if (this.aborted)\n    return\n\n  // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n  if (this.follow)\n    return this._readdir(abs, false, cb)\n\n  var lstatkey = 'lstat\\0' + abs\n  var self = this\n  var lstatcb = inflight(lstatkey, lstatcb_)\n\n  if (lstatcb)\n    fs.lstat(abs, lstatcb)\n\n  function lstatcb_ (er, lstat) {\n    if (er && er.code === 'ENOENT')\n      return cb()\n\n    var isSym = lstat && lstat.isSymbolicLink()\n    self.symlinks[abs] = isSym\n\n    // If it's not a symlink or a dir, then it's definitely a regular file.\n    // don't bother doing a readdir in that case.\n    if (!isSym && lstat && !lstat.isDirectory()) {\n      self.cache[abs] = 'FILE'\n      cb()\n    } else\n      self._readdir(abs, false, cb)\n  }\n}\n\nGlob.prototype._readdir = function (abs, inGlobStar, cb) {\n  if (this.aborted)\n    return\n\n  cb = inflight('readdir\\0'+abs+'\\0'+inGlobStar, cb)\n  if (!cb)\n    return\n\n  //console.error('RD %j %j', +inGlobStar, abs)\n  if (inGlobStar && !ownProp(this.symlinks, abs))\n    return this._readdirInGlobStar(abs, cb)\n\n  if (ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n    if (!c || c === 'FILE')\n      return cb()\n\n    if (Array.isArray(c))\n      return cb(null, c)\n  }\n\n  var self = this\n  fs.readdir(abs, readdirCb(this, abs, cb))\n}\n\nfunction readdirCb (self, abs, cb) {\n  return function (er, entries) {\n    if (er)\n      self._readdirError(abs, er, cb)\n    else\n      self._readdirEntries(abs, entries, cb)\n  }\n}\n\nGlob.prototype._readdirEntries = function (abs, entries, cb) {\n  if (this.aborted)\n    return\n\n  // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i ++) {\n      var e = entries[i]\n      if (abs === '/')\n        e = abs + e\n      else\n        e = abs + '/' + e\n      this.cache[e] = true\n    }\n  }\n\n  this.cache[abs] = entries\n  return cb(null, entries)\n}\n\nGlob.prototype._readdirError = function (f, er, cb) {\n  if (this.aborted)\n    return\n\n  // handle errors, and cache the information\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n    case 'ENOTDIR': // totally normal. means it *does* exist.\n      var abs = this._makeAbs(f)\n      this.cache[abs] = 'FILE'\n      if (abs === this.cwdAbs) {\n        var error = new Error(er.code + ' invalid cwd ' + this.cwd)\n        error.path = this.cwd\n        error.code = er.code\n        this.emit('error', error)\n        this.abort()\n      }\n      break\n\n    case 'ENOENT': // not terribly unusual\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false\n      break\n\n    default: // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false\n      if (this.strict) {\n        this.emit('error', er)\n        // If the error is handled, then we abort\n        // if not, we threw out of here\n        this.abort()\n      }\n      if (!this.silent)\n        console.error('glob error', er)\n      break\n  }\n\n  return cb()\n}\n\nGlob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n  var self = this\n  this._readdir(abs, inGlobStar, function (er, entries) {\n    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)\n  })\n}\n\n\nGlob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n  //console.error('pgs2', prefix, remain[0], entries)\n\n  // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n  if (!entries)\n    return cb()\n\n  // test without the globstar, and with every child both below\n  // and replacing the globstar.\n  var remainWithoutGlobStar = remain.slice(1)\n  var gspref = prefix ? [ prefix ] : []\n  var noGlobStar = gspref.concat(remainWithoutGlobStar)\n\n  // the noGlobStar pattern exits the inGlobStar state\n  this._process(noGlobStar, index, false, cb)\n\n  var isSym = this.symlinks[abs]\n  var len = entries.length\n\n  // If it's a symlink, and we're in a globstar, then stop\n  if (isSym && inGlobStar)\n    return cb()\n\n  for (var i = 0; i < len; i++) {\n    var e = entries[i]\n    if (e.charAt(0) === '.' && !this.dot)\n      continue\n\n    // these two cases enter the inGlobStar state\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar)\n    this._process(instead, index, true, cb)\n\n    var below = gspref.concat(entries[i], remain)\n    this._process(below, index, true, cb)\n  }\n\n  cb()\n}\n\nGlob.prototype._processSimple = function (prefix, index, cb) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var self = this\n  this._stat(prefix, function (er, exists) {\n    self._processSimple2(prefix, index, er, exists, cb)\n  })\n}\nGlob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {\n\n  //console.error('ps2', prefix, exists)\n\n  if (!this.matches[index])\n    this.matches[index] = Object.create(null)\n\n  // If it doesn't exist, then just mark the lack of results\n  if (!exists)\n    return cb()\n\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix)\n    if (prefix.charAt(0) === '/') {\n      prefix = path.join(this.root, prefix)\n    } else {\n      prefix = path.resolve(this.root, prefix)\n      if (trail)\n        prefix += '/'\n    }\n  }\n\n  if (process.platform === 'win32')\n    prefix = prefix.replace(/\\\\/g, '/')\n\n  // Mark this as a match\n  this._emitMatch(index, prefix)\n  cb()\n}\n\n// Returns either 'DIR', 'FILE', or false\nGlob.prototype._stat = function (f, cb) {\n  var abs = this._makeAbs(f)\n  var needDir = f.slice(-1) === '/'\n\n  if (f.length > this.maxLength)\n    return cb()\n\n  if (!this.stat && ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n\n    if (Array.isArray(c))\n      c = 'DIR'\n\n    // It exists, but maybe not how we need it\n    if (!needDir || c === 'DIR')\n      return cb(null, c)\n\n    if (needDir && c === 'FILE')\n      return cb()\n\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n\n  var exists\n  var stat = this.statCache[abs]\n  if (stat !== undefined) {\n    if (stat === false)\n      return cb(null, stat)\n    else {\n      var type = stat.isDirectory() ? 'DIR' : 'FILE'\n      if (needDir && type === 'FILE')\n        return cb()\n      else\n        return cb(null, type, stat)\n    }\n  }\n\n  var self = this\n  var statcb = inflight('stat\\0' + abs, lstatcb_)\n  if (statcb)\n    fs.lstat(abs, statcb)\n\n  function lstatcb_ (er, lstat) {\n    if (lstat && lstat.isSymbolicLink()) {\n      // If it's a symlink, then treat it as the target, unless\n      // the target does not exist, then treat it as a file.\n      return fs.stat(abs, function (er, stat) {\n        if (er)\n          self._stat2(f, abs, null, lstat, cb)\n        else\n          self._stat2(f, abs, er, stat, cb)\n      })\n    } else {\n      self._stat2(f, abs, er, lstat, cb)\n    }\n  }\n}\n\nGlob.prototype._stat2 = function (f, abs, er, stat, cb) {\n  if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {\n    this.statCache[abs] = false\n    return cb()\n  }\n\n  var needDir = f.slice(-1) === '/'\n  this.statCache[abs] = stat\n\n  if (abs.slice(-1) === '/' && stat && !stat.isDirectory())\n    return cb(null, false, stat)\n\n  var c = true\n  if (stat)\n    c = stat.isDirectory() ? 'DIR' : 'FILE'\n  this.cache[abs] = this.cache[abs] || c\n\n  if (needDir && c === 'FILE')\n    return cb()\n\n  return cb(null, c, stat)\n}\n\n\n/***/ }),\n/* 76 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction posix(path) {\n\treturn path.charAt(0) === '/';\n}\n\nfunction win32(path) {\n\t// https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56\n\tvar splitDeviceRe = /^([a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+)?([\\\\\\/])?([\\s\\S]*?)$/;\n\tvar result = splitDeviceRe.exec(path);\n\tvar device = result[1] || '';\n\tvar isUnc = Boolean(device && device.charAt(1) !== ':');\n\n\t// UNC paths are always absolute\n\treturn Boolean(result[2] || isUnc);\n}\n\nmodule.exports = process.platform === 'win32' ? win32 : posix;\nmodule.exports.posix = posix;\nmodule.exports.win32 = win32;\n\n\n/***/ }),\n/* 77 */,\n/* 78 */,\n/* 79 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"tty\");\n\n/***/ }),\n/* 80 */,\n/* 81 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (str, fileLoc = 'lockfile') {\n  str = (0, (_stripBom || _load_stripBom()).default)(str);\n  return hasMergeConflicts(str) ? parseWithConflict(str, fileLoc) : { type: 'success', object: parse(str, fileLoc) };\n};\n\nvar _util;\n\nfunction _load_util() {\n  return _util = _interopRequireDefault(__webpack_require__(2));\n}\n\nvar _invariant;\n\nfunction _load_invariant() {\n  return _invariant = _interopRequireDefault(__webpack_require__(7));\n}\n\nvar _stripBom;\n\nfunction _load_stripBom() {\n  return _stripBom = _interopRequireDefault(__webpack_require__(122));\n}\n\nvar _constants;\n\nfunction _load_constants() {\n  return _constants = __webpack_require__(6);\n}\n\nvar _errors;\n\nfunction _load_errors() {\n  return _errors = __webpack_require__(4);\n}\n\nvar _map;\n\nfunction _load_map() {\n  return _map = _interopRequireDefault(__webpack_require__(20));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/* eslint quotes: 0 */\n\nconst VERSION_REGEX = /^yarn lockfile v(\\d+)$/;\n\nconst TOKEN_TYPES = {\n  boolean: 'BOOLEAN',\n  string: 'STRING',\n  identifier: 'IDENTIFIER',\n  eof: 'EOF',\n  colon: 'COLON',\n  newline: 'NEWLINE',\n  comment: 'COMMENT',\n  indent: 'INDENT',\n  invalid: 'INVALID',\n  number: 'NUMBER',\n  comma: 'COMMA'\n};\n\nconst VALID_PROP_VALUE_TOKENS = [TOKEN_TYPES.boolean, TOKEN_TYPES.string, TOKEN_TYPES.number];\n\nfunction isValidPropValueToken(token) {\n  return VALID_PROP_VALUE_TOKENS.indexOf(token.type) >= 0;\n}\n\nfunction* tokenise(input) {\n  let lastNewline = false;\n  let line = 1;\n  let col = 0;\n\n  function buildToken(type, value) {\n    return { line, col, type, value };\n  }\n\n  while (input.length) {\n    let chop = 0;\n\n    if (input[0] === '\\n' || input[0] === '\\r') {\n      chop++;\n      // If this is a \\r\\n line, ignore both chars but only add one new line\n      if (input[1] === '\\n') {\n        chop++;\n      }\n      line++;\n      col = 0;\n      yield buildToken(TOKEN_TYPES.newline);\n    } else if (input[0] === '#') {\n      chop++;\n\n      let val = '';\n      while (input[chop] !== '\\n') {\n        val += input[chop];\n        chop++;\n      }\n      yield buildToken(TOKEN_TYPES.comment, val);\n    } else if (input[0] === ' ') {\n      if (lastNewline) {\n        let indent = '';\n        for (let i = 0; input[i] === ' '; i++) {\n          indent += input[i];\n        }\n\n        if (indent.length % 2) {\n          throw new TypeError('Invalid number of spaces');\n        } else {\n          chop = indent.length;\n          yield buildToken(TOKEN_TYPES.indent, indent.length / 2);\n        }\n      } else {\n        chop++;\n      }\n    } else if (input[0] === '\"') {\n      let val = '';\n\n      for (let i = 0;; i++) {\n        const currentChar = input[i];\n        val += currentChar;\n\n        if (i > 0 && currentChar === '\"') {\n          const isEscaped = input[i - 1] === '\\\\' && input[i - 2] !== '\\\\';\n          if (!isEscaped) {\n            break;\n          }\n        }\n      }\n\n      chop = val.length;\n\n      try {\n        yield buildToken(TOKEN_TYPES.string, JSON.parse(val));\n      } catch (err) {\n        if (err instanceof SyntaxError) {\n          yield buildToken(TOKEN_TYPES.invalid);\n        } else {\n          throw err;\n        }\n      }\n    } else if (/^[0-9]/.test(input)) {\n      let val = '';\n      for (let i = 0; /^[0-9]$/.test(input[i]); i++) {\n        val += input[i];\n      }\n      chop = val.length;\n\n      yield buildToken(TOKEN_TYPES.number, +val);\n    } else if (/^true/.test(input)) {\n      yield buildToken(TOKEN_TYPES.boolean, true);\n      chop = 4;\n    } else if (/^false/.test(input)) {\n      yield buildToken(TOKEN_TYPES.boolean, false);\n      chop = 5;\n    } else if (input[0] === ':') {\n      yield buildToken(TOKEN_TYPES.colon);\n      chop++;\n    } else if (input[0] === ',') {\n      yield buildToken(TOKEN_TYPES.comma);\n      chop++;\n    } else if (/^[a-zA-Z\\/-]/g.test(input)) {\n      let name = '';\n      for (let i = 0; i < input.length; i++) {\n        const char = input[i];\n        if (char === ':' || char === ' ' || char === '\\n' || char === '\\r' || char === ',') {\n          break;\n        } else {\n          name += char;\n        }\n      }\n      chop = name.length;\n\n      yield buildToken(TOKEN_TYPES.string, name);\n    } else {\n      yield buildToken(TOKEN_TYPES.invalid);\n    }\n\n    if (!chop) {\n      // will trigger infinite recursion\n      yield buildToken(TOKEN_TYPES.invalid);\n    }\n\n    col += chop;\n    lastNewline = input[0] === '\\n' || input[0] === '\\r' && input[1] === '\\n';\n    input = input.slice(chop);\n  }\n\n  yield buildToken(TOKEN_TYPES.eof);\n}\n\nclass Parser {\n  constructor(input, fileLoc = 'lockfile') {\n    this.comments = [];\n    this.tokens = tokenise(input);\n    this.fileLoc = fileLoc;\n  }\n\n  onComment(token) {\n    const value = token.value;\n    (0, (_invariant || _load_invariant()).default)(typeof value === 'string', 'expected token value to be a string');\n\n    const comment = value.trim();\n\n    const versionMatch = comment.match(VERSION_REGEX);\n    if (versionMatch) {\n      const version = +versionMatch[1];\n      if (version > (_constants || _load_constants()).LOCKFILE_VERSION) {\n        throw new (_errors || _load_errors()).MessageError(`Can't install from a lockfile of version ${version} as you're on an old yarn version that only supports ` + `versions up to ${(_constants || _load_constants()).LOCKFILE_VERSION}. Run \\`$ yarn self-update\\` to upgrade to the latest version.`);\n      }\n    }\n\n    this.comments.push(comment);\n  }\n\n  next() {\n    const item = this.tokens.next();\n    (0, (_invariant || _load_invariant()).default)(item, 'expected a token');\n\n    const done = item.done,\n          value = item.value;\n\n    if (done || !value) {\n      throw new Error('No more tokens');\n    } else if (value.type === TOKEN_TYPES.comment) {\n      this.onComment(value);\n      return this.next();\n    } else {\n      return this.token = value;\n    }\n  }\n\n  unexpected(msg = 'Unexpected token') {\n    throw new SyntaxError(`${msg} ${this.token.line}:${this.token.col} in ${this.fileLoc}`);\n  }\n\n  expect(tokType) {\n    if (this.token.type === tokType) {\n      this.next();\n    } else {\n      this.unexpected();\n    }\n  }\n\n  eat(tokType) {\n    if (this.token.type === tokType) {\n      this.next();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  parse(indent = 0) {\n    const obj = (0, (_map || _load_map()).default)();\n\n    while (true) {\n      const propToken = this.token;\n\n      if (propToken.type === TOKEN_TYPES.newline) {\n        const nextToken = this.next();\n        if (!indent) {\n          // if we have 0 indentation then the next token doesn't matter\n          continue;\n        }\n\n        if (nextToken.type !== TOKEN_TYPES.indent) {\n          // if we have no indentation after a newline then we've gone down a level\n          break;\n        }\n\n        if (nextToken.value === indent) {\n          // all is good, the indent is on our level\n          this.next();\n        } else {\n          // the indentation is less than our level\n          break;\n        }\n      } else if (propToken.type === TOKEN_TYPES.indent) {\n        if (propToken.value === indent) {\n          this.next();\n        } else {\n          break;\n        }\n      } else if (propToken.type === TOKEN_TYPES.eof) {\n        break;\n      } else if (propToken.type === TOKEN_TYPES.string) {\n        // property key\n        const key = propToken.value;\n        (0, (_invariant || _load_invariant()).default)(key, 'Expected a key');\n\n        const keys = [key];\n        this.next();\n\n        // support multiple keys\n        while (this.token.type === TOKEN_TYPES.comma) {\n          this.next(); // skip comma\n\n          const keyToken = this.token;\n          if (keyToken.type !== TOKEN_TYPES.string) {\n            this.unexpected('Expected string');\n          }\n\n          const key = keyToken.value;\n          (0, (_invariant || _load_invariant()).default)(key, 'Expected a key');\n          keys.push(key);\n          this.next();\n        }\n\n        const valToken = this.token;\n\n        if (valToken.type === TOKEN_TYPES.colon) {\n          // object\n          this.next();\n\n          // parse object\n          const val = this.parse(indent + 1);\n\n          for (var _iterator = keys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n            var _ref;\n\n            if (_isArray) {\n              if (_i >= _iterator.length) break;\n              _ref = _iterator[_i++];\n            } else {\n              _i = _iterator.next();\n              if (_i.done) break;\n              _ref = _i.value;\n            }\n\n            const key = _ref;\n\n            obj[key] = val;\n          }\n\n          if (indent && this.token.type !== TOKEN_TYPES.indent) {\n            break;\n          }\n        } else if (isValidPropValueToken(valToken)) {\n          // plain value\n          for (var _iterator2 = keys, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n            var _ref2;\n\n            if (_isArray2) {\n              if (_i2 >= _iterator2.length) break;\n              _ref2 = _iterator2[_i2++];\n            } else {\n              _i2 = _iterator2.next();\n              if (_i2.done) break;\n              _ref2 = _i2.value;\n            }\n\n            const key = _ref2;\n\n            obj[key] = valToken.value;\n          }\n\n          this.next();\n        } else {\n          this.unexpected('Invalid value type');\n        }\n      } else {\n        this.unexpected(`Unknown token: ${(_util || _load_util()).default.inspect(propToken)}`);\n      }\n    }\n\n    return obj;\n  }\n}\n\nconst MERGE_CONFLICT_ANCESTOR = '|||||||';\nconst MERGE_CONFLICT_END = '>>>>>>>';\nconst MERGE_CONFLICT_SEP = '=======';\nconst MERGE_CONFLICT_START = '<<<<<<<';\n\n/**\n * Extract the two versions of the lockfile from a merge conflict.\n */\nfunction extractConflictVariants(str) {\n  const variants = [[], []];\n  const lines = str.split(/\\r?\\n/g);\n  let skip = false;\n\n  while (lines.length) {\n    const line = lines.shift();\n    if (line.startsWith(MERGE_CONFLICT_START)) {\n      // get the first variant\n      while (lines.length) {\n        const conflictLine = lines.shift();\n        if (conflictLine === MERGE_CONFLICT_SEP) {\n          skip = false;\n          break;\n        } else if (skip || conflictLine.startsWith(MERGE_CONFLICT_ANCESTOR)) {\n          skip = true;\n          continue;\n        } else {\n          variants[0].push(conflictLine);\n        }\n      }\n\n      // get the second variant\n      while (lines.length) {\n        const conflictLine = lines.shift();\n        if (conflictLine.startsWith(MERGE_CONFLICT_END)) {\n          break;\n        } else {\n          variants[1].push(conflictLine);\n        }\n      }\n    } else {\n      variants[0].push(line);\n      variants[1].push(line);\n    }\n  }\n\n  return [variants[0].join('\\n'), variants[1].join('\\n')];\n}\n\n/**\n * Check if a lockfile has merge conflicts.\n */\nfunction hasMergeConflicts(str) {\n  return str.includes(MERGE_CONFLICT_START) && str.includes(MERGE_CONFLICT_SEP) && str.includes(MERGE_CONFLICT_END);\n}\n\n/**\n * Parse the lockfile.\n */\nfunction parse(str, fileLoc) {\n  const parser = new Parser(str, fileLoc);\n  parser.next();\n  return parser.parse();\n}\n\n/**\n * Parse and merge the two variants in a conflicted lockfile.\n */\nfunction parseWithConflict(str, fileLoc) {\n  const variants = extractConflictVariants(str);\n  try {\n    return { type: 'merge', object: Object.assign({}, parse(variants[0], fileLoc), parse(variants[1], fileLoc)) };\n  } catch (err) {\n    if (err instanceof SyntaxError) {\n      return { type: 'conflict', object: {} };\n    } else {\n      throw err;\n    }\n  }\n}\n\n/***/ }),\n/* 82 */,\n/* 83 */,\n/* 84 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _map;\n\nfunction _load_map() {\n  return _map = _interopRequireDefault(__webpack_require__(20));\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst debug = __webpack_require__(212)('yarn');\n\nclass BlockingQueue {\n  constructor(alias, maxConcurrency = Infinity) {\n    this.concurrencyQueue = [];\n    this.maxConcurrency = maxConcurrency;\n    this.runningCount = 0;\n    this.warnedStuck = false;\n    this.alias = alias;\n    this.first = true;\n\n    this.running = (0, (_map || _load_map()).default)();\n    this.queue = (0, (_map || _load_map()).default)();\n\n    this.stuckTick = this.stuckTick.bind(this);\n  }\n\n  stillActive() {\n    if (this.stuckTimer) {\n      clearTimeout(this.stuckTimer);\n    }\n\n    this.stuckTimer = setTimeout(this.stuckTick, 5000);\n\n    // We need to check the existence of unref because of https://github.com/facebook/jest/issues/4559\n    // $FlowFixMe: Node's setInterval returns a Timeout, not a Number\n    this.stuckTimer.unref && this.stuckTimer.unref();\n  }\n\n  stuckTick() {\n    if (this.runningCount === 1) {\n      this.warnedStuck = true;\n      debug(`The ${JSON.stringify(this.alias)} blocking queue may be stuck. 5 seconds ` + `without any activity with 1 worker: ${Object.keys(this.running)[0]}`);\n    }\n  }\n\n  push(key, factory) {\n    if (this.first) {\n      this.first = false;\n    } else {\n      this.stillActive();\n    }\n\n    return new Promise((resolve, reject) => {\n      // we're already running so push ourselves to the queue\n      const queue = this.queue[key] = this.queue[key] || [];\n      queue.push({ factory, resolve, reject });\n\n      if (!this.running[key]) {\n        this.shift(key);\n      }\n    });\n  }\n\n  shift(key) {\n    if (this.running[key]) {\n      delete this.running[key];\n      this.runningCount--;\n\n      if (this.stuckTimer) {\n        clearTimeout(this.stuckTimer);\n        this.stuckTimer = null;\n      }\n\n      if (this.warnedStuck) {\n        this.warnedStuck = false;\n        debug(`${JSON.stringify(this.alias)} blocking queue finally resolved. Nothing to worry about.`);\n      }\n    }\n\n    const queue = this.queue[key];\n    if (!queue) {\n      return;\n    }\n\n    var _queue$shift = queue.shift();\n\n    const resolve = _queue$shift.resolve,\n          reject = _queue$shift.reject,\n          factory = _queue$shift.factory;\n\n    if (!queue.length) {\n      delete this.queue[key];\n    }\n\n    const next = () => {\n      this.shift(key);\n      this.shiftConcurrencyQueue();\n    };\n\n    const run = () => {\n      this.running[key] = true;\n      this.runningCount++;\n\n      factory().then(function (val) {\n        resolve(val);\n        next();\n        return null;\n      }).catch(function (err) {\n        reject(err);\n        next();\n      });\n    };\n\n    this.maybePushConcurrencyQueue(run);\n  }\n\n  maybePushConcurrencyQueue(run) {\n    if (this.runningCount < this.maxConcurrency) {\n      run();\n    } else {\n      this.concurrencyQueue.push(run);\n    }\n  }\n\n  shiftConcurrencyQueue() {\n    if (this.runningCount < this.maxConcurrency) {\n      const fn = this.concurrencyQueue.shift();\n      if (fn) {\n        fn();\n      }\n    }\n  }\n}\nexports.default = BlockingQueue;\n\n/***/ }),\n/* 85 */\n/***/ (function(module, exports) {\n\nmodule.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (e) {\n    return true;\n  }\n};\n\n\n/***/ }),\n/* 86 */,\n/* 87 */,\n/* 88 */,\n/* 89 */,\n/* 90 */,\n/* 91 */,\n/* 92 */,\n/* 93 */,\n/* 94 */,\n/* 95 */,\n/* 96 */,\n/* 97 */,\n/* 98 */,\n/* 99 */,\n/* 100 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// getting tag from 19.1.3.6 Object.prototype.toString()\nvar cof = __webpack_require__(47);\nvar TAG = __webpack_require__(13)('toStringTag');\n// ES3 wrong here\nvar ARG = cof(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (e) { /* empty */ }\n};\n\nmodule.exports = function (it) {\n  var O, T, B;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T\n    // builtinTag case\n    : ARG ? cof(O)\n    // ES3 arguments fallback\n    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n};\n\n\n/***/ }),\n/* 101 */\n/***/ (function(module, exports) {\n\n// IE 8- don't enum bug keys\nmodule.exports = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n\n\n/***/ }),\n/* 102 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar document = __webpack_require__(11).document;\nmodule.exports = document && document.documentElement;\n\n\n/***/ }),\n/* 103 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar LIBRARY = __webpack_require__(69);\nvar $export = __webpack_require__(41);\nvar redefine = __webpack_require__(197);\nvar hide = __webpack_require__(31);\nvar Iterators = __webpack_require__(35);\nvar $iterCreate = __webpack_require__(188);\nvar setToStringTag = __webpack_require__(71);\nvar getPrototypeOf = __webpack_require__(194);\nvar ITERATOR = __webpack_require__(13)('iterator');\nvar BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`\nvar FF_ITERATOR = '@@iterator';\nvar KEYS = 'keys';\nvar VALUES = 'values';\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function (kind) {\n    if (!BUGGY && kind in proto) return proto[kind];\n    switch (kind) {\n      case KEYS: return function keys() { return new Constructor(this, kind); };\n      case VALUES: return function values() { return new Constructor(this, kind); };\n    } return function entries() { return new Constructor(this, kind); };\n  };\n  var TAG = NAME + ' Iterator';\n  var DEF_VALUES = DEFAULT == VALUES;\n  var VALUES_BUG = false;\n  var proto = Base.prototype;\n  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];\n  var $default = $native || getMethod(DEFAULT);\n  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;\n  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;\n  var methods, key, IteratorPrototype;\n  // Fix native\n  if ($anyNative) {\n    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));\n    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {\n      // Set @@toStringTag to native iterators\n      setToStringTag(IteratorPrototype, TAG, true);\n      // fix for some old engines\n      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);\n    }\n  }\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if (DEF_VALUES && $native && $native.name !== VALUES) {\n    VALUES_BUG = true;\n    $default = function values() { return $native.call(this); };\n  }\n  // Define iterator\n  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG] = returnThis;\n  if (DEFAULT) {\n    methods = {\n      values: DEF_VALUES ? $default : getMethod(VALUES),\n      keys: IS_SET ? $default : getMethod(KEYS),\n      entries: $entries\n    };\n    if (FORCED) for (key in methods) {\n      if (!(key in proto)) redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n\n\n/***/ }),\n/* 104 */\n/***/ (function(module, exports) {\n\nmodule.exports = function (exec) {\n  try {\n    return { e: false, v: exec() };\n  } catch (e) {\n    return { e: true, v: e };\n  }\n};\n\n\n/***/ }),\n/* 105 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar anObject = __webpack_require__(27);\nvar isObject = __webpack_require__(34);\nvar newPromiseCapability = __webpack_require__(70);\n\nmodule.exports = function (C, x) {\n  anObject(C);\n  if (isObject(x) && x.constructor === C) return x;\n  var promiseCapability = newPromiseCapability.f(C);\n  var resolve = promiseCapability.resolve;\n  resolve(x);\n  return promiseCapability.promise;\n};\n\n\n/***/ }),\n/* 106 */\n/***/ (function(module, exports) {\n\nmodule.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\n\n/***/ }),\n/* 107 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar core = __webpack_require__(23);\nvar global = __webpack_require__(11);\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || (global[SHARED] = {});\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: core.version,\n  mode: __webpack_require__(69) ? 'pure' : 'global',\n  copyright: '© 2018 Denis Pushkarev (zloirock.ru)'\n});\n\n\n/***/ }),\n/* 108 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// 7.3.20 SpeciesConstructor(O, defaultConstructor)\nvar anObject = __webpack_require__(27);\nvar aFunction = __webpack_require__(46);\nvar SPECIES = __webpack_require__(13)('species');\nmodule.exports = function (O, D) {\n  var C = anObject(O).constructor;\n  var S;\n  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);\n};\n\n\n/***/ }),\n/* 109 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar ctx = __webpack_require__(48);\nvar invoke = __webpack_require__(185);\nvar html = __webpack_require__(102);\nvar cel = __webpack_require__(68);\nvar global = __webpack_require__(11);\nvar process = global.process;\nvar setTask = global.setImmediate;\nvar clearTask = global.clearImmediate;\nvar MessageChannel = global.MessageChannel;\nvar Dispatch = global.Dispatch;\nvar counter = 0;\nvar queue = {};\nvar ONREADYSTATECHANGE = 'onreadystatechange';\nvar defer, channel, port;\nvar run = function () {\n  var id = +this;\n  // eslint-disable-next-line no-prototype-builtins\n  if (queue.hasOwnProperty(id)) {\n    var fn = queue[id];\n    delete queue[id];\n    fn();\n  }\n};\nvar listener = function (event) {\n  run.call(event.data);\n};\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif (!setTask || !clearTask) {\n  setTask = function setImmediate(fn) {\n    var args = [];\n    var i = 1;\n    while (arguments.length > i) args.push(arguments[i++]);\n    queue[++counter] = function () {\n      // eslint-disable-next-line no-new-func\n      invoke(typeof fn == 'function' ? fn : Function(fn), args);\n    };\n    defer(counter);\n    return counter;\n  };\n  clearTask = function clearImmediate(id) {\n    delete queue[id];\n  };\n  // Node.js 0.8-\n  if (__webpack_require__(47)(process) == 'process') {\n    defer = function (id) {\n      process.nextTick(ctx(run, id, 1));\n    };\n  // Sphere (JS game engine) Dispatch API\n  } else if (Dispatch && Dispatch.now) {\n    defer = function (id) {\n      Dispatch.now(ctx(run, id, 1));\n    };\n  // Browsers with MessageChannel, includes WebWorkers\n  } else if (MessageChannel) {\n    channel = new MessageChannel();\n    port = channel.port2;\n    channel.port1.onmessage = listener;\n    defer = ctx(port.postMessage, port, 1);\n  // Browsers with postMessage, skip WebWorkers\n  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {\n    defer = function (id) {\n      global.postMessage(id + '', '*');\n    };\n    global.addEventListener('message', listener, false);\n  // IE8-\n  } else if (ONREADYSTATECHANGE in cel('script')) {\n    defer = function (id) {\n      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {\n        html.removeChild(this);\n        run.call(id);\n      };\n    };\n  // Rest old browsers\n  } else {\n    defer = function (id) {\n      setTimeout(ctx(run, id, 1), 0);\n    };\n  }\n}\nmodule.exports = {\n  set: setTask,\n  clear: clearTask\n};\n\n\n/***/ }),\n/* 110 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// 7.1.15 ToLength\nvar toInteger = __webpack_require__(73);\nvar min = Math.min;\nmodule.exports = function (it) {\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n\n\n/***/ }),\n/* 111 */\n/***/ (function(module, exports) {\n\nvar id = 0;\nvar px = Math.random();\nmodule.exports = function (key) {\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n\n\n/***/ }),\n/* 112 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = __webpack_require__(229);\n\n/**\n * Active `debug` instances.\n */\nexports.instances = [];\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  var prevTime;\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n  debug.destroy = destroy;\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  exports.instances.push(debug);\n\n  return debug;\n}\n\nfunction destroy () {\n  var index = exports.instances.indexOf(this);\n  if (index !== -1) {\n    exports.instances.splice(index, 1);\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var i;\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n\n  for (i = 0; i < exports.instances.length; i++) {\n    var instance = exports.instances[i];\n    instance.enabled = exports.enabled(instance.namespace);\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  if (name[name.length - 1] === '*') {\n    return true;\n  }\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n\n/***/ }),\n/* 113 */,\n/* 114 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = realpath\nrealpath.realpath = realpath\nrealpath.sync = realpathSync\nrealpath.realpathSync = realpathSync\nrealpath.monkeypatch = monkeypatch\nrealpath.unmonkeypatch = unmonkeypatch\n\nvar fs = __webpack_require__(3)\nvar origRealpath = fs.realpath\nvar origRealpathSync = fs.realpathSync\n\nvar version = process.version\nvar ok = /^v[0-5]\\./.test(version)\nvar old = __webpack_require__(217)\n\nfunction newError (er) {\n  return er && er.syscall === 'realpath' && (\n    er.code === 'ELOOP' ||\n    er.code === 'ENOMEM' ||\n    er.code === 'ENAMETOOLONG'\n  )\n}\n\nfunction realpath (p, cache, cb) {\n  if (ok) {\n    return origRealpath(p, cache, cb)\n  }\n\n  if (typeof cache === 'function') {\n    cb = cache\n    cache = null\n  }\n  origRealpath(p, cache, function (er, result) {\n    if (newError(er)) {\n      old.realpath(p, cache, cb)\n    } else {\n      cb(er, result)\n    }\n  })\n}\n\nfunction realpathSync (p, cache) {\n  if (ok) {\n    return origRealpathSync(p, cache)\n  }\n\n  try {\n    return origRealpathSync(p, cache)\n  } catch (er) {\n    if (newError(er)) {\n      return old.realpathSync(p, cache)\n    } else {\n      throw er\n    }\n  }\n}\n\nfunction monkeypatch () {\n  fs.realpath = realpath\n  fs.realpathSync = realpathSync\n}\n\nfunction unmonkeypatch () {\n  fs.realpath = origRealpath\n  fs.realpathSync = origRealpathSync\n}\n\n\n/***/ }),\n/* 115 */\n/***/ (function(module, exports, __webpack_require__) {\n\nexports.alphasort = alphasort\nexports.alphasorti = alphasorti\nexports.setopts = setopts\nexports.ownProp = ownProp\nexports.makeAbs = makeAbs\nexports.finish = finish\nexports.mark = mark\nexports.isIgnored = isIgnored\nexports.childrenIgnored = childrenIgnored\n\nfunction ownProp (obj, field) {\n  return Object.prototype.hasOwnProperty.call(obj, field)\n}\n\nvar path = __webpack_require__(0)\nvar minimatch = __webpack_require__(60)\nvar isAbsolute = __webpack_require__(76)\nvar Minimatch = minimatch.Minimatch\n\nfunction alphasorti (a, b) {\n  return a.toLowerCase().localeCompare(b.toLowerCase())\n}\n\nfunction alphasort (a, b) {\n  return a.localeCompare(b)\n}\n\nfunction setupIgnores (self, options) {\n  self.ignore = options.ignore || []\n\n  if (!Array.isArray(self.ignore))\n    self.ignore = [self.ignore]\n\n  if (self.ignore.length) {\n    self.ignore = self.ignore.map(ignoreMap)\n  }\n}\n\n// ignore patterns are always in dot:true mode.\nfunction ignoreMap (pattern) {\n  var gmatcher = null\n  if (pattern.slice(-3) === '/**') {\n    var gpattern = pattern.replace(/(\\/\\*\\*)+$/, '')\n    gmatcher = new Minimatch(gpattern, { dot: true })\n  }\n\n  return {\n    matcher: new Minimatch(pattern, { dot: true }),\n    gmatcher: gmatcher\n  }\n}\n\nfunction setopts (self, pattern, options) {\n  if (!options)\n    options = {}\n\n  // base-matching: just use globstar for that.\n  if (options.matchBase && -1 === pattern.indexOf(\"/\")) {\n    if (options.noglobstar) {\n      throw new Error(\"base matching requires globstar\")\n    }\n    pattern = \"**/\" + pattern\n  }\n\n  self.silent = !!options.silent\n  self.pattern = pattern\n  self.strict = options.strict !== false\n  self.realpath = !!options.realpath\n  self.realpathCache = options.realpathCache || Object.create(null)\n  self.follow = !!options.follow\n  self.dot = !!options.dot\n  self.mark = !!options.mark\n  self.nodir = !!options.nodir\n  if (self.nodir)\n    self.mark = true\n  self.sync = !!options.sync\n  self.nounique = !!options.nounique\n  self.nonull = !!options.nonull\n  self.nosort = !!options.nosort\n  self.nocase = !!options.nocase\n  self.stat = !!options.stat\n  self.noprocess = !!options.noprocess\n  self.absolute = !!options.absolute\n\n  self.maxLength = options.maxLength || Infinity\n  self.cache = options.cache || Object.create(null)\n  self.statCache = options.statCache || Object.create(null)\n  self.symlinks = options.symlinks || Object.create(null)\n\n  setupIgnores(self, options)\n\n  self.changedCwd = false\n  var cwd = process.cwd()\n  if (!ownProp(options, \"cwd\"))\n    self.cwd = cwd\n  else {\n    self.cwd = path.resolve(options.cwd)\n    self.changedCwd = self.cwd !== cwd\n  }\n\n  self.root = options.root || path.resolve(self.cwd, \"/\")\n  self.root = path.resolve(self.root)\n  if (process.platform === \"win32\")\n    self.root = self.root.replace(/\\\\/g, \"/\")\n\n  // TODO: is an absolute `cwd` supposed to be resolved against `root`?\n  // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')\n  self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd)\n  if (process.platform === \"win32\")\n    self.cwdAbs = self.cwdAbs.replace(/\\\\/g, \"/\")\n  self.nomount = !!options.nomount\n\n  // disable comments and negation in Minimatch.\n  // Note that they are not supported in Glob itself anyway.\n  options.nonegate = true\n  options.nocomment = true\n\n  self.minimatch = new Minimatch(pattern, options)\n  self.options = self.minimatch.options\n}\n\nfunction finish (self) {\n  var nou = self.nounique\n  var all = nou ? [] : Object.create(null)\n\n  for (var i = 0, l = self.matches.length; i < l; i ++) {\n    var matches = self.matches[i]\n    if (!matches || Object.keys(matches).length === 0) {\n      if (self.nonull) {\n        // do like the shell, and spit out the literal glob\n        var literal = self.minimatch.globSet[i]\n        if (nou)\n          all.push(literal)\n        else\n          all[literal] = true\n      }\n    } else {\n      // had matches\n      var m = Object.keys(matches)\n      if (nou)\n        all.push.apply(all, m)\n      else\n        m.forEach(function (m) {\n          all[m] = true\n        })\n    }\n  }\n\n  if (!nou)\n    all = Object.keys(all)\n\n  if (!self.nosort)\n    all = all.sort(self.nocase ? alphasorti : alphasort)\n\n  // at *some* point we statted all of these\n  if (self.mark) {\n    for (var i = 0; i < all.length; i++) {\n      all[i] = self._mark(all[i])\n    }\n    if (self.nodir) {\n      all = all.filter(function (e) {\n        var notDir = !(/\\/$/.test(e))\n        var c = self.cache[e] || self.cache[makeAbs(self, e)]\n        if (notDir && c)\n          notDir = c !== 'DIR' && !Array.isArray(c)\n        return notDir\n      })\n    }\n  }\n\n  if (self.ignore.length)\n    all = all.filter(function(m) {\n      return !isIgnored(self, m)\n    })\n\n  self.found = all\n}\n\nfunction mark (self, p) {\n  var abs = makeAbs(self, p)\n  var c = self.cache[abs]\n  var m = p\n  if (c) {\n    var isDir = c === 'DIR' || Array.isArray(c)\n    var slash = p.slice(-1) === '/'\n\n    if (isDir && !slash)\n      m += '/'\n    else if (!isDir && slash)\n      m = m.slice(0, -1)\n\n    if (m !== p) {\n      var mabs = makeAbs(self, m)\n      self.statCache[mabs] = self.statCache[abs]\n      self.cache[mabs] = self.cache[abs]\n    }\n  }\n\n  return m\n}\n\n// lotta situps...\nfunction makeAbs (self, f) {\n  var abs = f\n  if (f.charAt(0) === '/') {\n    abs = path.join(self.root, f)\n  } else if (isAbsolute(f) || f === '') {\n    abs = f\n  } else if (self.changedCwd) {\n    abs = path.resolve(self.cwd, f)\n  } else {\n    abs = path.resolve(f)\n  }\n\n  if (process.platform === 'win32')\n    abs = abs.replace(/\\\\/g, '/')\n\n  return abs\n}\n\n\n// Return true, if pattern ends with globstar '**', for the accompanying parent directory.\n// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents\nfunction isIgnored (self, path) {\n  if (!self.ignore.length)\n    return false\n\n  return self.ignore.some(function(item) {\n    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))\n  })\n}\n\nfunction childrenIgnored (self, path) {\n  if (!self.ignore.length)\n    return false\n\n  return self.ignore.some(function(item) {\n    return !!(item.gmatcher && item.gmatcher.match(path))\n  })\n}\n\n\n/***/ }),\n/* 116 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar path = __webpack_require__(0);\nvar fs = __webpack_require__(3);\nvar _0777 = parseInt('0777', 8);\n\nmodule.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;\n\nfunction mkdirP (p, opts, f, made) {\n    if (typeof opts === 'function') {\n        f = opts;\n        opts = {};\n    }\n    else if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n    \n    var cb = f || function () {};\n    p = path.resolve(p);\n    \n    xfs.mkdir(p, mode, function (er) {\n        if (!er) {\n            made = made || p;\n            return cb(null, made);\n        }\n        switch (er.code) {\n            case 'ENOENT':\n                mkdirP(path.dirname(p), opts, function (er, made) {\n                    if (er) cb(er, made);\n                    else mkdirP(p, opts, cb, made);\n                });\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                xfs.stat(p, function (er2, stat) {\n                    // if the stat fails, then that's super weird.\n                    // let the original error be the failure reason.\n                    if (er2 || !stat.isDirectory()) cb(er, made)\n                    else cb(null, made);\n                });\n                break;\n        }\n    });\n}\n\nmkdirP.sync = function sync (p, opts, made) {\n    if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n\n    p = path.resolve(p);\n\n    try {\n        xfs.mkdirSync(p, mode);\n        made = made || p;\n    }\n    catch (err0) {\n        switch (err0.code) {\n            case 'ENOENT' :\n                made = sync(path.dirname(p), opts, made);\n                sync(p, opts, made);\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                var stat;\n                try {\n                    stat = xfs.statSync(p);\n                }\n                catch (err1) {\n                    throw err0;\n                }\n                if (!stat.isDirectory()) throw err0;\n                break;\n        }\n    }\n\n    return made;\n};\n\n\n/***/ }),\n/* 117 */,\n/* 118 */,\n/* 119 */,\n/* 120 */,\n/* 121 */,\n/* 122 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nmodule.exports = x => {\n\tif (typeof x !== 'string') {\n\t\tthrow new TypeError('Expected a string, got ' + typeof x);\n\t}\n\n\t// Catches EFBBBF (UTF-8 BOM) because the buffer-to-string\n\t// conversion translates it to FEFF (UTF-16 BOM)\n\tif (x.charCodeAt(0) === 0xFEFF) {\n\t\treturn x.slice(1);\n\t}\n\n\treturn x;\n};\n\n\n/***/ }),\n/* 123 */\n/***/ (function(module, exports) {\n\n// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k]\n  })\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n    var ret = fn.apply(this, args)\n    var cb = args[args.length-1]\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k]\n      })\n    }\n    return ret\n  }\n}\n\n\n/***/ }),\n/* 124 */,\n/* 125 */,\n/* 126 */,\n/* 127 */,\n/* 128 */,\n/* 129 */,\n/* 130 */,\n/* 131 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = __webpack_require__(47);\n// eslint-disable-next-line no-prototype-builtins\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n\n\n/***/ }),\n/* 132 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar $keys = __webpack_require__(195);\nvar enumBugKeys = __webpack_require__(101);\n\nmodule.exports = Object.keys || function keys(O) {\n  return $keys(O, enumBugKeys);\n};\n\n\n/***/ }),\n/* 133 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// 7.1.13 ToObject(argument)\nvar defined = __webpack_require__(67);\nmodule.exports = function (it) {\n  return Object(defined(it));\n};\n\n\n/***/ }),\n/* 134 */,\n/* 135 */,\n/* 136 */,\n/* 137 */,\n/* 138 */,\n/* 139 */,\n/* 140 */,\n/* 141 */,\n/* 142 */,\n/* 143 */,\n/* 144 */,\n/* 145 */\n/***/ (function(module, exports) {\n\nmodule.exports = {\"name\":\"yarn\",\"installationMethod\":\"unknown\",\"version\":\"1.10.0-0\",\"license\":\"BSD-2-Clause\",\"preferGlobal\":true,\"description\":\"📦🐈 Fast, reliable, and secure dependency management.\",\"dependencies\":{\"@zkochan/cmd-shim\":\"^2.2.4\",\"babel-runtime\":\"^6.26.0\",\"bytes\":\"^3.0.0\",\"camelcase\":\"^4.0.0\",\"chalk\":\"^2.1.0\",\"commander\":\"^2.9.0\",\"death\":\"^1.0.0\",\"debug\":\"^3.0.0\",\"deep-equal\":\"^1.0.1\",\"detect-indent\":\"^5.0.0\",\"dnscache\":\"^1.0.1\",\"glob\":\"^7.1.1\",\"gunzip-maybe\":\"^1.4.0\",\"hash-for-dep\":\"^1.2.3\",\"imports-loader\":\"^0.8.0\",\"ini\":\"^1.3.4\",\"inquirer\":\"^3.0.1\",\"invariant\":\"^2.2.0\",\"is-builtin-module\":\"^2.0.0\",\"is-ci\":\"^1.0.10\",\"is-webpack-bundle\":\"^1.0.0\",\"leven\":\"^2.0.0\",\"loud-rejection\":\"^1.2.0\",\"micromatch\":\"^2.3.11\",\"mkdirp\":\"^0.5.1\",\"node-emoji\":\"^1.6.1\",\"normalize-url\":\"^2.0.0\",\"npm-logical-tree\":\"^1.2.1\",\"object-path\":\"^0.11.2\",\"proper-lockfile\":\"^2.0.0\",\"puka\":\"^1.0.0\",\"read\":\"^1.0.7\",\"request\":\"^2.87.0\",\"request-capture-har\":\"^1.2.2\",\"rimraf\":\"^2.5.0\",\"semver\":\"^5.1.0\",\"ssri\":\"^5.3.0\",\"strip-ansi\":\"^4.0.0\",\"strip-bom\":\"^3.0.0\",\"tar-fs\":\"^1.16.0\",\"tar-stream\":\"^1.6.1\",\"uuid\":\"^3.0.1\",\"v8-compile-cache\":\"^2.0.0\",\"validate-npm-package-license\":\"^3.0.3\",\"yn\":\"^2.0.0\"},\"devDependencies\":{\"babel-core\":\"^6.26.0\",\"babel-eslint\":\"^7.2.3\",\"babel-loader\":\"^6.2.5\",\"babel-plugin-array-includes\":\"^2.0.3\",\"babel-plugin-transform-builtin-extend\":\"^1.1.2\",\"babel-plugin-transform-inline-imports-commonjs\":\"^1.0.0\",\"babel-plugin-transform-runtime\":\"^6.4.3\",\"babel-preset-env\":\"^1.6.0\",\"babel-preset-flow\":\"^6.23.0\",\"babel-preset-stage-0\":\"^6.0.0\",\"babylon\":\"^6.5.0\",\"commitizen\":\"^2.9.6\",\"cz-conventional-changelog\":\"^2.0.0\",\"eslint\":\"^4.3.0\",\"eslint-config-fb-strict\":\"^22.0.0\",\"eslint-plugin-babel\":\"^5.0.0\",\"eslint-plugin-flowtype\":\"^2.35.0\",\"eslint-plugin-jasmine\":\"^2.6.2\",\"eslint-plugin-jest\":\"^21.0.0\",\"eslint-plugin-jsx-a11y\":\"^6.0.2\",\"eslint-plugin-prefer-object-spread\":\"^1.2.1\",\"eslint-plugin-prettier\":\"^2.1.2\",\"eslint-plugin-react\":\"^7.1.0\",\"eslint-plugin-relay\":\"^0.0.24\",\"eslint-plugin-yarn-internal\":\"file:scripts/eslint-rules\",\"execa\":\"^0.10.0\",\"flow-bin\":\"^0.66.0\",\"git-release-notes\":\"^3.0.0\",\"gulp\":\"^3.9.0\",\"gulp-babel\":\"^7.0.0\",\"gulp-if\":\"^2.0.1\",\"gulp-newer\":\"^1.0.0\",\"gulp-plumber\":\"^1.0.1\",\"gulp-sourcemaps\":\"^2.2.0\",\"gulp-util\":\"^3.0.7\",\"gulp-watch\":\"^5.0.0\",\"jest\":\"^22.4.4\",\"jsinspect\":\"^0.12.6\",\"minimatch\":\"^3.0.4\",\"mock-stdin\":\"^0.3.0\",\"prettier\":\"^1.5.2\",\"temp\":\"^0.8.3\",\"webpack\":\"^2.1.0-beta.25\",\"yargs\":\"^6.3.0\"},\"resolutions\":{\"sshpk\":\"^1.14.2\"},\"engines\":{\"node\":\">=4.0.0\"},\"repository\":\"yarnpkg/yarn\",\"bin\":{\"yarn\":\"./bin/yarn.js\",\"yarnpkg\":\"./bin/yarn.js\"},\"scripts\":{\"build\":\"gulp build\",\"build-bundle\":\"node ./scripts/build-webpack.js\",\"build-chocolatey\":\"powershell ./scripts/build-chocolatey.ps1\",\"build-deb\":\"./scripts/build-deb.sh\",\"build-dist\":\"bash ./scripts/build-dist.sh\",\"build-win-installer\":\"scripts\\\\build-windows-installer.bat\",\"changelog\":\"git-release-notes $(git describe --tags --abbrev=0 $(git describe --tags --abbrev=0)^)..$(git describe --tags --abbrev=0) scripts/changelog.md\",\"dupe-check\":\"yarn jsinspect ./src\",\"lint\":\"eslint . && flow check\",\"pkg-tests\":\"yarn --cwd packages/pkg-tests jest yarn.test.js\",\"prettier\":\"eslint src __tests__ --fix\",\"release-branch\":\"./scripts/release-branch.sh\",\"test\":\"yarn lint && yarn test-only\",\"test-only\":\"node --max_old_space_size=4096 node_modules/jest/bin/jest.js --verbose\",\"test-only-debug\":\"node --inspect-brk --max_old_space_size=4096 node_modules/jest/bin/jest.js --runInBand --verbose\",\"test-coverage\":\"node --max_old_space_size=4096 node_modules/jest/bin/jest.js --coverage --verbose\",\"watch\":\"gulp watch\",\"commit\":\"git-cz\"},\"jest\":{\"collectCoverageFrom\":[\"src/**/*.js\"],\"testEnvironment\":\"node\",\"modulePathIgnorePatterns\":[\"__tests__/fixtures/\",\"packages/pkg-tests/pkg-tests-fixtures\",\"dist/\"],\"testPathIgnorePatterns\":[\"__tests__/(fixtures|__mocks__)/\",\"updates/\",\"_(temp|mock|install|init|helpers).js$\",\"packages/pkg-tests\"]},\"config\":{\"commitizen\":{\"path\":\"./node_modules/cz-conventional-changelog\"}}}\n\n/***/ }),\n/* 146 */,\n/* 147 */,\n/* 148 */,\n/* 149 */,\n/* 150 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = stringify;\n\nvar _misc;\n\nfunction _load_misc() {\n  return _misc = __webpack_require__(12);\n}\n\nvar _constants;\n\nfunction _load_constants() {\n  return _constants = __webpack_require__(6);\n}\n\nvar _package;\n\nfunction _load_package() {\n  return _package = __webpack_require__(145);\n}\n\nconst NODE_VERSION = process.version;\n\nfunction shouldWrapKey(str) {\n  return str.indexOf('true') === 0 || str.indexOf('false') === 0 || /[:\\s\\n\\\\\",\\[\\]]/g.test(str) || /^[0-9]/g.test(str) || !/^[a-zA-Z]/g.test(str);\n}\n\nfunction maybeWrap(str) {\n  if (typeof str === 'boolean' || typeof str === 'number' || shouldWrapKey(str)) {\n    return JSON.stringify(str);\n  } else {\n    return str;\n  }\n}\n\nconst priorities = {\n  name: 1,\n  version: 2,\n  uid: 3,\n  resolved: 4,\n  integrity: 5,\n  registry: 6,\n  dependencies: 7\n};\n\nfunction priorityThenAlphaSort(a, b) {\n  if (priorities[a] || priorities[b]) {\n    return (priorities[a] || 100) > (priorities[b] || 100) ? 1 : -1;\n  } else {\n    return (0, (_misc || _load_misc()).sortAlpha)(a, b);\n  }\n}\n\nfunction _stringify(obj, options) {\n  if (typeof obj !== 'object') {\n    throw new TypeError();\n  }\n\n  const indent = options.indent;\n  const lines = [];\n\n  // Sorting order needs to be consistent between runs, we run native sort by name because there are no\n  // problems with it being unstable because there are no to keys the same\n  // However priorities can be duplicated and native sort can shuffle things from run to run\n  const keys = Object.keys(obj).sort(priorityThenAlphaSort);\n\n  let addedKeys = [];\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const val = obj[key];\n    if (val == null || addedKeys.indexOf(key) >= 0) {\n      continue;\n    }\n\n    const valKeys = [key];\n\n    // get all keys that have the same value equality, we only want this for objects\n    if (typeof val === 'object') {\n      for (let j = i + 1; j < keys.length; j++) {\n        const key = keys[j];\n        if (val === obj[key]) {\n          valKeys.push(key);\n        }\n      }\n    }\n\n    const keyLine = valKeys.sort((_misc || _load_misc()).sortAlpha).map(maybeWrap).join(', ');\n\n    if (typeof val === 'string' || typeof val === 'boolean' || typeof val === 'number') {\n      lines.push(`${keyLine} ${maybeWrap(val)}`);\n    } else if (typeof val === 'object') {\n      lines.push(`${keyLine}:\\n${_stringify(val, { indent: indent + '  ' })}` + (options.topLevel ? '\\n' : ''));\n    } else {\n      throw new TypeError();\n    }\n\n    addedKeys = addedKeys.concat(valKeys);\n  }\n\n  return indent + lines.join(`\\n${indent}`);\n}\n\nfunction stringify(obj, noHeader, enableVersions) {\n  const val = _stringify(obj, {\n    indent: '',\n    topLevel: true\n  });\n  if (noHeader) {\n    return val;\n  }\n\n  const lines = [];\n  lines.push('# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.');\n  lines.push(`# yarn lockfile v${(_constants || _load_constants()).LOCKFILE_VERSION}`);\n  if (enableVersions) {\n    lines.push(`# yarn v${(_package || _load_package()).version}`);\n    lines.push(`# node ${NODE_VERSION}`);\n  }\n  lines.push('\\n');\n  lines.push(val);\n\n  return lines.join('\\n');\n}\n\n/***/ }),\n/* 151 */,\n/* 152 */,\n/* 153 */,\n/* 154 */,\n/* 155 */,\n/* 156 */,\n/* 157 */,\n/* 158 */,\n/* 159 */,\n/* 160 */,\n/* 161 */,\n/* 162 */,\n/* 163 */,\n/* 164 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fileDatesEqual = exports.copyFile = exports.unlink = undefined;\n\nvar _asyncToGenerator2;\n\nfunction _load_asyncToGenerator() {\n  return _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(1));\n}\n\n// We want to preserve file timestamps when copying a file, since yarn uses them to decide if a file has\n// changed compared to the cache.\n// There are some OS specific cases here:\n// * On linux, fs.copyFile does not preserve timestamps, but does on OSX and Win.\n// * On windows, you must open a file with write permissions to call `fs.futimes`.\n// * On OSX you can open with read permissions and still call `fs.futimes`.\nlet fixTimes = (() => {\n  var _ref3 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (fd, dest, data) {\n    const doOpen = fd === undefined;\n    let openfd = fd ? fd : -1;\n\n    if (disableTimestampCorrection === undefined) {\n      // if timestamps match already, no correction is needed.\n      // the need to correct timestamps varies based on OS and node versions.\n      const destStat = yield lstat(dest);\n      disableTimestampCorrection = fileDatesEqual(destStat.mtime, data.mtime);\n    }\n\n    if (disableTimestampCorrection) {\n      return;\n    }\n\n    if (doOpen) {\n      try {\n        openfd = yield open(dest, 'a', data.mode);\n      } catch (er) {\n        // file is likely read-only\n        try {\n          openfd = yield open(dest, 'r', data.mode);\n        } catch (err) {\n          // We can't even open this file for reading.\n          return;\n        }\n      }\n    }\n\n    try {\n      if (openfd) {\n        yield futimes(openfd, data.atime, data.mtime);\n      }\n    } catch (er) {\n      // If `futimes` throws an exception, we probably have a case of a read-only file on Windows.\n      // In this case we can just return. The incorrect timestamp will just cause that file to be recopied\n      // on subsequent installs, which will effect yarn performance but not break anything.\n    } finally {\n      if (doOpen && openfd) {\n        yield close(openfd);\n      }\n    }\n  });\n\n  return function fixTimes(_x7, _x8, _x9) {\n    return _ref3.apply(this, arguments);\n  };\n})();\n\n// Compare file timestamps.\n// Some versions of Node on windows zero the milliseconds when utime is used.\n\n\nvar _fs;\n\nfunction _load_fs() {\n  return _fs = _interopRequireDefault(__webpack_require__(3));\n}\n\nvar _promise;\n\nfunction _load_promise() {\n  return _promise = __webpack_require__(40);\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// This module serves as a wrapper for file operations that are inconsistant across node and OS versions.\n\nlet disableTimestampCorrection = undefined; // OS dependent. will be detected on first file copy.\n\nconst readFileBuffer = (0, (_promise || _load_promise()).promisify)((_fs || _load_fs()).default.readFile);\nconst close = (0, (_promise || _load_promise()).promisify)((_fs || _load_fs()).default.close);\nconst lstat = (0, (_promise || _load_promise()).promisify)((_fs || _load_fs()).default.lstat);\nconst open = (0, (_promise || _load_promise()).promisify)((_fs || _load_fs()).default.open);\nconst futimes = (0, (_promise || _load_promise()).promisify)((_fs || _load_fs()).default.futimes);\n\nconst write = (0, (_promise || _load_promise()).promisify)((_fs || _load_fs()).default.write);\n\nconst unlink = exports.unlink = (0, (_promise || _load_promise()).promisify)(__webpack_require__(233));\n\n/**\n * Unlinks the destination to force a recreation. This is needed on case-insensitive file systems\n * to force the correct naming when the filename has changed only in character-casing. (Jest -> jest).\n */\nconst copyFile = exports.copyFile = (() => {\n  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (data, cleanup) {\n    try {\n      yield unlink(data.dest);\n      yield copyFilePoly(data.src, data.dest, 0, data);\n    } finally {\n      if (cleanup) {\n        cleanup();\n      }\n    }\n  });\n\n  return function copyFile(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n})();\n\n// Node 8.5.0 introduced `fs.copyFile` which is much faster, so use that when available.\n// Otherwise we fall back to reading and writing files as buffers.\nconst copyFilePoly = (src, dest, flags, data) => {\n  if ((_fs || _load_fs()).default.copyFile) {\n    return new Promise((resolve, reject) => (_fs || _load_fs()).default.copyFile(src, dest, flags, err => {\n      if (err) {\n        reject(err);\n      } else {\n        fixTimes(undefined, dest, data).then(() => resolve()).catch(ex => reject(ex));\n      }\n    }));\n  } else {\n    return copyWithBuffer(src, dest, flags, data);\n  }\n};\n\nconst copyWithBuffer = (() => {\n  var _ref2 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (src, dest, flags, data) {\n    // Use open -> write -> futimes -> close sequence to avoid opening the file twice:\n    // one with writeFile and one with utimes\n    const fd = yield open(dest, 'w', data.mode);\n    try {\n      const buffer = yield readFileBuffer(src);\n      yield write(fd, buffer, 0, buffer.length);\n      yield fixTimes(fd, dest, data);\n    } finally {\n      yield close(fd);\n    }\n  });\n\n  return function copyWithBuffer(_x3, _x4, _x5, _x6) {\n    return _ref2.apply(this, arguments);\n  };\n})();const fileDatesEqual = exports.fileDatesEqual = (a, b) => {\n  const aTime = a.getTime();\n  const bTime = b.getTime();\n\n  if (process.platform !== 'win32') {\n    return aTime === bTime;\n  }\n\n  // See https://github.com/nodejs/node/pull/12607\n  // Submillisecond times from stat and utimes are truncated on Windows,\n  // causing a file with mtime 8.0079998 and 8.0081144 to become 8.007 and 8.008\n  // and making it impossible to update these files to their correct timestamps.\n  if (Math.abs(aTime - bTime) <= 1) {\n    return true;\n  }\n\n  const aTimeSec = Math.floor(aTime / 1000);\n  const bTimeSec = Math.floor(bTime / 1000);\n\n  // See https://github.com/nodejs/node/issues/2069\n  // Some versions of Node on windows zero the milliseconds when utime is used\n  // So if any of the time has a milliseconds part of zero we suspect that the\n  // bug is present and compare only seconds.\n  if (aTime - aTimeSec * 1000 === 0 || bTime - bTimeSec * 1000 === 0) {\n    return aTimeSec === bTimeSec;\n  }\n\n  return aTime === bTime;\n};\n\n/***/ }),\n/* 165 */,\n/* 166 */,\n/* 167 */,\n/* 168 */,\n/* 169 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isFakeRoot = isFakeRoot;\nexports.isRootUser = isRootUser;\nfunction getUid() {\n  if (process.platform !== 'win32' && process.getuid) {\n    return process.getuid();\n  }\n  return null;\n}\n\nexports.default = isRootUser(getUid()) && !isFakeRoot();\nfunction isFakeRoot() {\n  return Boolean(process.env.FAKEROOTKEY);\n}\n\nfunction isRootUser(uid) {\n  return uid === 0;\n}\n\n/***/ }),\n/* 170 */,\n/* 171 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getDataDir = getDataDir;\nexports.getCacheDir = getCacheDir;\nexports.getConfigDir = getConfigDir;\nconst path = __webpack_require__(0);\nconst userHome = __webpack_require__(45).default;\n\nconst FALLBACK_CONFIG_DIR = path.join(userHome, '.config', 'yarn');\nconst FALLBACK_CACHE_DIR = path.join(userHome, '.cache', 'yarn');\n\nfunction getDataDir() {\n  if (process.platform === 'win32') {\n    const WIN32_APPDATA_DIR = getLocalAppDataDir();\n    return WIN32_APPDATA_DIR == null ? FALLBACK_CONFIG_DIR : path.join(WIN32_APPDATA_DIR, 'Data');\n  } else if (process.env.XDG_DATA_HOME) {\n    return path.join(process.env.XDG_DATA_HOME, 'yarn');\n  } else {\n    // This could arguably be ~/Library/Application Support/Yarn on Macs,\n    // but that feels unintuitive for a cli tool\n\n    // Instead, use our prior fallback. Some day this could be\n    // path.join(userHome, '.local', 'share', 'yarn')\n    // or return path.join(WIN32_APPDATA_DIR, 'Data') on win32\n    return FALLBACK_CONFIG_DIR;\n  }\n}\n\nfunction getCacheDir() {\n  if (process.platform === 'win32') {\n    // process.env.TEMP also exists, but most apps put caches here\n    return path.join(getLocalAppDataDir() || path.join(userHome, 'AppData', 'Local', 'Yarn'), 'Cache');\n  } else if (process.env.XDG_CACHE_HOME) {\n    return path.join(process.env.XDG_CACHE_HOME, 'yarn');\n  } else if (process.platform === 'darwin') {\n    return path.join(userHome, 'Library', 'Caches', 'Yarn');\n  } else {\n    return FALLBACK_CACHE_DIR;\n  }\n}\n\nfunction getConfigDir() {\n  if (process.platform === 'win32') {\n    // Use our prior fallback. Some day this could be\n    // return path.join(WIN32_APPDATA_DIR, 'Config')\n    const WIN32_APPDATA_DIR = getLocalAppDataDir();\n    return WIN32_APPDATA_DIR == null ? FALLBACK_CONFIG_DIR : path.join(WIN32_APPDATA_DIR, 'Config');\n  } else if (process.env.XDG_CONFIG_HOME) {\n    return path.join(process.env.XDG_CONFIG_HOME, 'yarn');\n  } else {\n    return FALLBACK_CONFIG_DIR;\n  }\n}\n\nfunction getLocalAppDataDir() {\n  return process.env.LOCALAPPDATA ? path.join(process.env.LOCALAPPDATA, 'Yarn') : null;\n}\n\n/***/ }),\n/* 172 */,\n/* 173 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = { \"default\": __webpack_require__(179), __esModule: true };\n\n/***/ }),\n/* 174 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nmodule.exports = balanced;\nfunction balanced(a, b, str) {\n  if (a instanceof RegExp) a = maybeMatch(a, str);\n  if (b instanceof RegExp) b = maybeMatch(b, str);\n\n  var r = range(a, b, str);\n\n  return r && {\n    start: r[0],\n    end: r[1],\n    pre: str.slice(0, r[0]),\n    body: str.slice(r[0] + a.length, r[1]),\n    post: str.slice(r[1] + b.length)\n  };\n}\n\nfunction maybeMatch(reg, str) {\n  var m = str.match(reg);\n  return m ? m[0] : null;\n}\n\nbalanced.range = range;\nfunction range(a, b, str) {\n  var begs, beg, left, right, result;\n  var ai = str.indexOf(a);\n  var bi = str.indexOf(b, ai + 1);\n  var i = ai;\n\n  if (ai >= 0 && bi > 0) {\n    begs = [];\n    left = str.length;\n\n    while (i >= 0 && !result) {\n      if (i == ai) {\n        begs.push(i);\n        ai = str.indexOf(a, i + 1);\n      } else if (begs.length == 1) {\n        result = [ begs.pop(), bi ];\n      } else {\n        beg = begs.pop();\n        if (beg < left) {\n          left = beg;\n          right = bi;\n        }\n\n        bi = str.indexOf(b, i + 1);\n      }\n\n      i = ai < bi && ai >= 0 ? ai : bi;\n    }\n\n    if (begs.length) {\n      result = [ left, right ];\n    }\n  }\n\n  return result;\n}\n\n\n/***/ }),\n/* 175 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar concatMap = __webpack_require__(178);\nvar balanced = __webpack_require__(174);\n\nmodule.exports = expandTop;\n\nvar escSlash = '\\0SLASH'+Math.random()+'\\0';\nvar escOpen = '\\0OPEN'+Math.random()+'\\0';\nvar escClose = '\\0CLOSE'+Math.random()+'\\0';\nvar escComma = '\\0COMMA'+Math.random()+'\\0';\nvar escPeriod = '\\0PERIOD'+Math.random()+'\\0';\n\nfunction numeric(str) {\n  return parseInt(str, 10) == str\n    ? parseInt(str, 10)\n    : str.charCodeAt(0);\n}\n\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash)\n            .split('\\\\{').join(escOpen)\n            .split('\\\\}').join(escClose)\n            .split('\\\\,').join(escComma)\n            .split('\\\\.').join(escPeriod);\n}\n\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\')\n            .split(escOpen).join('{')\n            .split(escClose).join('}')\n            .split(escComma).join(',')\n            .split(escPeriod).join('.');\n}\n\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str)\n    return [''];\n\n  var parts = [];\n  var m = balanced('{', '}', str);\n\n  if (!m)\n    return str.split(',');\n\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n\n  p[p.length-1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length-1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n\n  parts.push.apply(parts, p);\n\n  return parts;\n}\n\nfunction expandTop(str) {\n  if (!str)\n    return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\n\nfunction identity(e) {\n  return e;\n}\n\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\n\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\n\nfunction expand(str, isTop) {\n  var expansions = [];\n\n  var m = balanced('{', '}', str);\n  if (!m || /\\$$/.test(m.pre)) return [str];\n\n  var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isSequence = isNumericSequence || isAlphaSequence;\n  var isOptions = m.body.indexOf(',') >= 0;\n  if (!isSequence && !isOptions) {\n    // {a},b}\n    if (m.post.match(/,.*\\}/)) {\n      str = m.pre + '{' + m.body + escClose + m.post;\n      return expand(str);\n    }\n    return [str];\n  }\n\n  var n;\n  if (isSequence) {\n    n = m.body.split(/\\.\\./);\n  } else {\n    n = parseCommaParts(m.body);\n    if (n.length === 1) {\n      // x{{a,b}}y ==> x{a}y x{b}y\n      n = expand(n[0], false).map(embrace);\n      if (n.length === 1) {\n        var post = m.post.length\n          ? expand(m.post, false)\n          : [''];\n        return post.map(function(p) {\n          return m.pre + n[0] + p;\n        });\n      }\n    }\n  }\n\n  // at this point, n is the parts, and we know it's not a comma set\n  // with a single entry.\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length\n    ? expand(m.post, false)\n    : [''];\n\n  var N;\n\n  if (isSequence) {\n    var x = numeric(n[0]);\n    var y = numeric(n[1]);\n    var width = Math.max(n[0].length, n[1].length)\n    var incr = n.length == 3\n      ? Math.abs(numeric(n[2]))\n      : 1;\n    var test = lte;\n    var reverse = y < x;\n    if (reverse) {\n      incr *= -1;\n      test = gte;\n    }\n    var pad = n.some(isPadded);\n\n    N = [];\n\n    for (var i = x; test(i, y); i += incr) {\n      var c;\n      if (isAlphaSequence) {\n        c = String.fromCharCode(i);\n        if (c === '\\\\')\n          c = '';\n      } else {\n        c = String(i);\n        if (pad) {\n          var need = width - c.length;\n          if (need > 0) {\n            var z = new Array(need + 1).join('0');\n            if (i < 0)\n              c = '-' + z + c.slice(1);\n            else\n              c = z + c;\n          }\n        }\n      }\n      N.push(c);\n    }\n  } else {\n    N = concatMap(n, function(el) { return expand(el, false) });\n  }\n\n  for (var j = 0; j < N.length; j++) {\n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre + N[j] + post[k];\n      if (!isTop || isSequence || expansion)\n        expansions.push(expansion);\n    }\n  }\n\n  return expansions;\n}\n\n\n\n/***/ }),\n/* 176 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction preserveCamelCase(str) {\n\tlet isLastCharLower = false;\n\tlet isLastCharUpper = false;\n\tlet isLastLastCharUpper = false;\n\n\tfor (let i = 0; i < str.length; i++) {\n\t\tconst c = str[i];\n\n\t\tif (isLastCharLower && /[a-zA-Z]/.test(c) && c.toUpperCase() === c) {\n\t\t\tstr = str.substr(0, i) + '-' + str.substr(i);\n\t\t\tisLastCharLower = false;\n\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\tisLastCharUpper = true;\n\t\t\ti++;\n\t\t} else if (isLastCharUpper && isLastLastCharUpper && /[a-zA-Z]/.test(c) && c.toLowerCase() === c) {\n\t\t\tstr = str.substr(0, i - 1) + '-' + str.substr(i - 1);\n\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\tisLastCharUpper = false;\n\t\t\tisLastCharLower = true;\n\t\t} else {\n\t\t\tisLastCharLower = c.toLowerCase() === c;\n\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\tisLastCharUpper = c.toUpperCase() === c;\n\t\t}\n\t}\n\n\treturn str;\n}\n\nmodule.exports = function (str) {\n\tif (arguments.length > 1) {\n\t\tstr = Array.from(arguments)\n\t\t\t.map(x => x.trim())\n\t\t\t.filter(x => x.length)\n\t\t\t.join('-');\n\t} else {\n\t\tstr = str.trim();\n\t}\n\n\tif (str.length === 0) {\n\t\treturn '';\n\t}\n\n\tif (str.length === 1) {\n\t\treturn str.toLowerCase();\n\t}\n\n\tif (/^[a-z0-9]+$/.test(str)) {\n\t\treturn str;\n\t}\n\n\tconst hasUpperCase = str !== str.toLowerCase();\n\n\tif (hasUpperCase) {\n\t\tstr = preserveCamelCase(str);\n\t}\n\n\treturn str\n\t\t.replace(/^[_.\\- ]+/, '')\n\t\t.toLowerCase()\n\t\t.replace(/[_.\\- ]+(\\w|$)/g, (m, p1) => p1.toUpperCase());\n};\n\n\n/***/ }),\n/* 177 */,\n/* 178 */\n/***/ (function(module, exports) {\n\nmodule.exports = function (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        var x = fn(xs[i], i);\n        if (isArray(x)) res.push.apply(res, x);\n        else res.push(x);\n    }\n    return res;\n};\n\nvar isArray = Array.isArray || function (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\n\n/***/ }),\n/* 179 */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(205);\n__webpack_require__(207);\n__webpack_require__(210);\n__webpack_require__(206);\n__webpack_require__(208);\n__webpack_require__(209);\nmodule.exports = __webpack_require__(23).Promise;\n\n\n/***/ }),\n/* 180 */\n/***/ (function(module, exports) {\n\nmodule.exports = function () { /* empty */ };\n\n\n/***/ }),\n/* 181 */\n/***/ (function(module, exports) {\n\nmodule.exports = function (it, Constructor, name, forbiddenField) {\n  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {\n    throw TypeError(name + ': incorrect invocation!');\n  } return it;\n};\n\n\n/***/ }),\n/* 182 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = __webpack_require__(74);\nvar toLength = __webpack_require__(110);\nvar toAbsoluteIndex = __webpack_require__(200);\nmodule.exports = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {\n      if (O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\n\n/***/ }),\n/* 183 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar ctx = __webpack_require__(48);\nvar call = __webpack_require__(187);\nvar isArrayIter = __webpack_require__(186);\nvar anObject = __webpack_require__(27);\nvar toLength = __webpack_require__(110);\nvar getIterFn = __webpack_require__(203);\nvar BREAK = {};\nvar RETURN = {};\nvar exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {\n  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);\n  var f = ctx(fn, that, entries ? 2 : 1);\n  var index = 0;\n  var length, step, iterator, result;\n  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');\n  // fast case for arrays with default iterator\n  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {\n    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);\n    if (result === BREAK || result === RETURN) return result;\n  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {\n    result = call(iterator, f, step.value, entries);\n    if (result === BREAK || result === RETURN) return result;\n  }\n};\nexports.BREAK = BREAK;\nexports.RETURN = RETURN;\n\n\n/***/ }),\n/* 184 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = !__webpack_require__(33) && !__webpack_require__(85)(function () {\n  return Object.defineProperty(__webpack_require__(68)('div'), 'a', { get: function () { return 7; } }).a != 7;\n});\n\n\n/***/ }),\n/* 185 */\n/***/ (function(module, exports) {\n\n// fast apply, http://jsperf.lnkit.com/fast-apply/5\nmodule.exports = function (fn, args, that) {\n  var un = that === undefined;\n  switch (args.length) {\n    case 0: return un ? fn()\n                      : fn.call(that);\n    case 1: return un ? fn(args[0])\n                      : fn.call(that, args[0]);\n    case 2: return un ? fn(args[0], args[1])\n                      : fn.call(that, args[0], args[1]);\n    case 3: return un ? fn(args[0], args[1], args[2])\n                      : fn.call(that, args[0], args[1], args[2]);\n    case 4: return un ? fn(args[0], args[1], args[2], args[3])\n                      : fn.call(that, args[0], args[1], args[2], args[3]);\n  } return fn.apply(that, args);\n};\n\n\n/***/ }),\n/* 186 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// check on default Array iterator\nvar Iterators = __webpack_require__(35);\nvar ITERATOR = __webpack_require__(13)('iterator');\nvar ArrayProto = Array.prototype;\n\nmodule.exports = function (it) {\n  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);\n};\n\n\n/***/ }),\n/* 187 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// call something on iterator step with safe closing on error\nvar anObject = __webpack_require__(27);\nmodule.exports = function (iterator, fn, value, entries) {\n  try {\n    return entries ? fn(anObject(value)[0], value[1]) : fn(value);\n  // 7.4.6 IteratorClose(iterator, completion)\n  } catch (e) {\n    var ret = iterator['return'];\n    if (ret !== undefined) anObject(ret.call(iterator));\n    throw e;\n  }\n};\n\n\n/***/ }),\n/* 188 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar create = __webpack_require__(192);\nvar descriptor = __webpack_require__(106);\nvar setToStringTag = __webpack_require__(71);\nvar IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n__webpack_require__(31)(IteratorPrototype, __webpack_require__(13)('iterator'), function () { return this; });\n\nmodule.exports = function (Constructor, NAME, next) {\n  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });\n  setToStringTag(Constructor, NAME + ' Iterator');\n};\n\n\n/***/ }),\n/* 189 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar ITERATOR = __webpack_require__(13)('iterator');\nvar SAFE_CLOSING = false;\n\ntry {\n  var riter = [7][ITERATOR]();\n  riter['return'] = function () { SAFE_CLOSING = true; };\n  // eslint-disable-next-line no-throw-literal\n  Array.from(riter, function () { throw 2; });\n} catch (e) { /* empty */ }\n\nmodule.exports = function (exec, skipClosing) {\n  if (!skipClosing && !SAFE_CLOSING) return false;\n  var safe = false;\n  try {\n    var arr = [7];\n    var iter = arr[ITERATOR]();\n    iter.next = function () { return { done: safe = true }; };\n    arr[ITERATOR] = function () { return iter; };\n    exec(arr);\n  } catch (e) { /* empty */ }\n  return safe;\n};\n\n\n/***/ }),\n/* 190 */\n/***/ (function(module, exports) {\n\nmodule.exports = function (done, value) {\n  return { value: value, done: !!done };\n};\n\n\n/***/ }),\n/* 191 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(11);\nvar macrotask = __webpack_require__(109).set;\nvar Observer = global.MutationObserver || global.WebKitMutationObserver;\nvar process = global.process;\nvar Promise = global.Promise;\nvar isNode = __webpack_require__(47)(process) == 'process';\n\nmodule.exports = function () {\n  var head, last, notify;\n\n  var flush = function () {\n    var parent, fn;\n    if (isNode && (parent = process.domain)) parent.exit();\n    while (head) {\n      fn = head.fn;\n      head = head.next;\n      try {\n        fn();\n      } catch (e) {\n        if (head) notify();\n        else last = undefined;\n        throw e;\n      }\n    } last = undefined;\n    if (parent) parent.enter();\n  };\n\n  // Node.js\n  if (isNode) {\n    notify = function () {\n      process.nextTick(flush);\n    };\n  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339\n  } else if (Observer && !(global.navigator && global.navigator.standalone)) {\n    var toggle = true;\n    var node = document.createTextNode('');\n    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new\n    notify = function () {\n      node.data = toggle = !toggle;\n    };\n  // environments with maybe non-completely correct, but existent Promise\n  } else if (Promise && Promise.resolve) {\n    // Promise.resolve without an argument throws an error in LG WebOS 2\n    var promise = Promise.resolve(undefined);\n    notify = function () {\n      promise.then(flush);\n    };\n  // for other environments - macrotask based on:\n  // - setImmediate\n  // - MessageChannel\n  // - window.postMessag\n  // - onreadystatechange\n  // - setTimeout\n  } else {\n    notify = function () {\n      // strange IE + webpack dev server bug - use .call(global)\n      macrotask.call(global, flush);\n    };\n  }\n\n  return function (fn) {\n    var task = { fn: fn, next: undefined };\n    if (last) last.next = task;\n    if (!head) {\n      head = task;\n      notify();\n    } last = task;\n  };\n};\n\n\n/***/ }),\n/* 192 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nvar anObject = __webpack_require__(27);\nvar dPs = __webpack_require__(193);\nvar enumBugKeys = __webpack_require__(101);\nvar IE_PROTO = __webpack_require__(72)('IE_PROTO');\nvar Empty = function () { /* empty */ };\nvar PROTOTYPE = 'prototype';\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = __webpack_require__(68)('iframe');\n  var i = enumBugKeys.length;\n  var lt = '<';\n  var gt = '>';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  __webpack_require__(102).appendChild(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];\n  return createDict();\n};\n\nmodule.exports = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty();\n    Empty[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : dPs(result, Properties);\n};\n\n\n/***/ }),\n/* 193 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar dP = __webpack_require__(50);\nvar anObject = __webpack_require__(27);\nvar getKeys = __webpack_require__(132);\n\nmodule.exports = __webpack_require__(33) ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject(O);\n  var keys = getKeys(Properties);\n  var length = keys.length;\n  var i = 0;\n  var P;\n  while (length > i) dP.f(O, P = keys[i++], Properties[P]);\n  return O;\n};\n\n\n/***/ }),\n/* 194 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\nvar has = __webpack_require__(49);\nvar toObject = __webpack_require__(133);\nvar IE_PROTO = __webpack_require__(72)('IE_PROTO');\nvar ObjectProto = Object.prototype;\n\nmodule.exports = Object.getPrototypeOf || function (O) {\n  O = toObject(O);\n  if (has(O, IE_PROTO)) return O[IE_PROTO];\n  if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectProto : null;\n};\n\n\n/***/ }),\n/* 195 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar has = __webpack_require__(49);\nvar toIObject = __webpack_require__(74);\nvar arrayIndexOf = __webpack_require__(182)(false);\nvar IE_PROTO = __webpack_require__(72)('IE_PROTO');\n\nmodule.exports = function (object, names) {\n  var O = toIObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (has(O, key = names[i++])) {\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n\n\n/***/ }),\n/* 196 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar hide = __webpack_require__(31);\nmodule.exports = function (target, src, safe) {\n  for (var key in src) {\n    if (safe && target[key]) target[key] = src[key];\n    else hide(target, key, src[key]);\n  } return target;\n};\n\n\n/***/ }),\n/* 197 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(31);\n\n\n/***/ }),\n/* 198 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar global = __webpack_require__(11);\nvar core = __webpack_require__(23);\nvar dP = __webpack_require__(50);\nvar DESCRIPTORS = __webpack_require__(33);\nvar SPECIES = __webpack_require__(13)('species');\n\nmodule.exports = function (KEY) {\n  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];\n  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {\n    configurable: true,\n    get: function () { return this; }\n  });\n};\n\n\n/***/ }),\n/* 199 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toInteger = __webpack_require__(73);\nvar defined = __webpack_require__(67);\n// true  -> String#at\n// false -> String#codePointAt\nmodule.exports = function (TO_STRING) {\n  return function (that, pos) {\n    var s = String(defined(that));\n    var i = toInteger(pos);\n    var l = s.length;\n    var a, b;\n    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n\n\n/***/ }),\n/* 200 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toInteger = __webpack_require__(73);\nvar max = Math.max;\nvar min = Math.min;\nmodule.exports = function (index, length) {\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n\n\n/***/ }),\n/* 201 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = __webpack_require__(34);\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function (it, S) {\n  if (!isObject(it)) return it;\n  var fn, val;\n  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n\n\n/***/ }),\n/* 202 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(11);\nvar navigator = global.navigator;\n\nmodule.exports = navigator && navigator.userAgent || '';\n\n\n/***/ }),\n/* 203 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar classof = __webpack_require__(100);\nvar ITERATOR = __webpack_require__(13)('iterator');\nvar Iterators = __webpack_require__(35);\nmodule.exports = __webpack_require__(23).getIteratorMethod = function (it) {\n  if (it != undefined) return it[ITERATOR]\n    || it['@@iterator']\n    || Iterators[classof(it)];\n};\n\n\n/***/ }),\n/* 204 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar addToUnscopables = __webpack_require__(180);\nvar step = __webpack_require__(190);\nvar Iterators = __webpack_require__(35);\nvar toIObject = __webpack_require__(74);\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nmodule.exports = __webpack_require__(103)(Array, 'Array', function (iterated, kind) {\n  this._t = toIObject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var kind = this._k;\n  var index = this._i++;\n  if (!O || index >= O.length) {\n    this._t = undefined;\n    return step(1);\n  }\n  if (kind == 'keys') return step(0, index);\n  if (kind == 'values') return step(0, O[index]);\n  return step(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\nIterators.Arguments = Iterators.Array;\n\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n\n\n/***/ }),\n/* 205 */\n/***/ (function(module, exports) {\n\n\n\n/***/ }),\n/* 206 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar LIBRARY = __webpack_require__(69);\nvar global = __webpack_require__(11);\nvar ctx = __webpack_require__(48);\nvar classof = __webpack_require__(100);\nvar $export = __webpack_require__(41);\nvar isObject = __webpack_require__(34);\nvar aFunction = __webpack_require__(46);\nvar anInstance = __webpack_require__(181);\nvar forOf = __webpack_require__(183);\nvar speciesConstructor = __webpack_require__(108);\nvar task = __webpack_require__(109).set;\nvar microtask = __webpack_require__(191)();\nvar newPromiseCapabilityModule = __webpack_require__(70);\nvar perform = __webpack_require__(104);\nvar userAgent = __webpack_require__(202);\nvar promiseResolve = __webpack_require__(105);\nvar PROMISE = 'Promise';\nvar TypeError = global.TypeError;\nvar process = global.process;\nvar versions = process && process.versions;\nvar v8 = versions && versions.v8 || '';\nvar $Promise = global[PROMISE];\nvar isNode = classof(process) == 'process';\nvar empty = function () { /* empty */ };\nvar Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;\nvar newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;\n\nvar USE_NATIVE = !!function () {\n  try {\n    // correct subclassing with @@species support\n    var promise = $Promise.resolve(1);\n    var FakePromise = (promise.constructor = {})[__webpack_require__(13)('species')] = function (exec) {\n      exec(empty, empty);\n    };\n    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test\n    return (isNode || typeof PromiseRejectionEvent == 'function')\n      && promise.then(empty) instanceof FakePromise\n      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565\n      // we can't detect it synchronously, so just check versions\n      && v8.indexOf('6.6') !== 0\n      && userAgent.indexOf('Chrome/66') === -1;\n  } catch (e) { /* empty */ }\n}();\n\n// helpers\nvar isThenable = function (it) {\n  var then;\n  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;\n};\nvar notify = function (promise, isReject) {\n  if (promise._n) return;\n  promise._n = true;\n  var chain = promise._c;\n  microtask(function () {\n    var value = promise._v;\n    var ok = promise._s == 1;\n    var i = 0;\n    var run = function (reaction) {\n      var handler = ok ? reaction.ok : reaction.fail;\n      var resolve = reaction.resolve;\n      var reject = reaction.reject;\n      var domain = reaction.domain;\n      var result, then, exited;\n      try {\n        if (handler) {\n          if (!ok) {\n            if (promise._h == 2) onHandleUnhandled(promise);\n            promise._h = 1;\n          }\n          if (handler === true) result = value;\n          else {\n            if (domain) domain.enter();\n            result = handler(value); // may throw\n            if (domain) {\n              domain.exit();\n              exited = true;\n            }\n          }\n          if (result === reaction.promise) {\n            reject(TypeError('Promise-chain cycle'));\n          } else if (then = isThenable(result)) {\n            then.call(result, resolve, reject);\n          } else resolve(result);\n        } else reject(value);\n      } catch (e) {\n        if (domain && !exited) domain.exit();\n        reject(e);\n      }\n    };\n    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach\n    promise._c = [];\n    promise._n = false;\n    if (isReject && !promise._h) onUnhandled(promise);\n  });\n};\nvar onUnhandled = function (promise) {\n  task.call(global, function () {\n    var value = promise._v;\n    var unhandled = isUnhandled(promise);\n    var result, handler, console;\n    if (unhandled) {\n      result = perform(function () {\n        if (isNode) {\n          process.emit('unhandledRejection', value, promise);\n        } else if (handler = global.onunhandledrejection) {\n          handler({ promise: promise, reason: value });\n        } else if ((console = global.console) && console.error) {\n          console.error('Unhandled promise rejection', value);\n        }\n      });\n      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\n      promise._h = isNode || isUnhandled(promise) ? 2 : 1;\n    } promise._a = undefined;\n    if (unhandled && result.e) throw result.v;\n  });\n};\nvar isUnhandled = function (promise) {\n  return promise._h !== 1 && (promise._a || promise._c).length === 0;\n};\nvar onHandleUnhandled = function (promise) {\n  task.call(global, function () {\n    var handler;\n    if (isNode) {\n      process.emit('rejectionHandled', promise);\n    } else if (handler = global.onrejectionhandled) {\n      handler({ promise: promise, reason: promise._v });\n    }\n  });\n};\nvar $reject = function (value) {\n  var promise = this;\n  if (promise._d) return;\n  promise._d = true;\n  promise = promise._w || promise; // unwrap\n  promise._v = value;\n  promise._s = 2;\n  if (!promise._a) promise._a = promise._c.slice();\n  notify(promise, true);\n};\nvar $resolve = function (value) {\n  var promise = this;\n  var then;\n  if (promise._d) return;\n  promise._d = true;\n  promise = promise._w || promise; // unwrap\n  try {\n    if (promise === value) throw TypeError(\"Promise can't be resolved itself\");\n    if (then = isThenable(value)) {\n      microtask(function () {\n        var wrapper = { _w: promise, _d: false }; // wrap\n        try {\n          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));\n        } catch (e) {\n          $reject.call(wrapper, e);\n        }\n      });\n    } else {\n      promise._v = value;\n      promise._s = 1;\n      notify(promise, false);\n    }\n  } catch (e) {\n    $reject.call({ _w: promise, _d: false }, e); // wrap\n  }\n};\n\n// constructor polyfill\nif (!USE_NATIVE) {\n  // 25.4.3.1 Promise(executor)\n  $Promise = function Promise(executor) {\n    anInstance(this, $Promise, PROMISE, '_h');\n    aFunction(executor);\n    Internal.call(this);\n    try {\n      executor(ctx($resolve, this, 1), ctx($reject, this, 1));\n    } catch (err) {\n      $reject.call(this, err);\n    }\n  };\n  // eslint-disable-next-line no-unused-vars\n  Internal = function Promise(executor) {\n    this._c = [];             // <- awaiting reactions\n    this._a = undefined;      // <- checked in isUnhandled reactions\n    this._s = 0;              // <- state\n    this._d = false;          // <- done\n    this._v = undefined;      // <- value\n    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled\n    this._n = false;          // <- notify\n  };\n  Internal.prototype = __webpack_require__(196)($Promise.prototype, {\n    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)\n    then: function then(onFulfilled, onRejected) {\n      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));\n      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;\n      reaction.fail = typeof onRejected == 'function' && onRejected;\n      reaction.domain = isNode ? process.domain : undefined;\n      this._c.push(reaction);\n      if (this._a) this._a.push(reaction);\n      if (this._s) notify(this, false);\n      return reaction.promise;\n    },\n    // 25.4.5.1 Promise.prototype.catch(onRejected)\n    'catch': function (onRejected) {\n      return this.then(undefined, onRejected);\n    }\n  });\n  OwnPromiseCapability = function () {\n    var promise = new Internal();\n    this.promise = promise;\n    this.resolve = ctx($resolve, promise, 1);\n    this.reject = ctx($reject, promise, 1);\n  };\n  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {\n    return C === $Promise || C === Wrapper\n      ? new OwnPromiseCapability(C)\n      : newGenericPromiseCapability(C);\n  };\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });\n__webpack_require__(71)($Promise, PROMISE);\n__webpack_require__(198)(PROMISE);\nWrapper = __webpack_require__(23)[PROMISE];\n\n// statics\n$export($export.S + $export.F * !USE_NATIVE, PROMISE, {\n  // 25.4.4.5 Promise.reject(r)\n  reject: function reject(r) {\n    var capability = newPromiseCapability(this);\n    var $$reject = capability.reject;\n    $$reject(r);\n    return capability.promise;\n  }\n});\n$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {\n  // 25.4.4.6 Promise.resolve(x)\n  resolve: function resolve(x) {\n    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);\n  }\n});\n$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(189)(function (iter) {\n  $Promise.all(iter)['catch'](empty);\n})), PROMISE, {\n  // 25.4.4.1 Promise.all(iterable)\n  all: function all(iterable) {\n    var C = this;\n    var capability = newPromiseCapability(C);\n    var resolve = capability.resolve;\n    var reject = capability.reject;\n    var result = perform(function () {\n      var values = [];\n      var index = 0;\n      var remaining = 1;\n      forOf(iterable, false, function (promise) {\n        var $index = index++;\n        var alreadyCalled = false;\n        values.push(undefined);\n        remaining++;\n        C.resolve(promise).then(function (value) {\n          if (alreadyCalled) return;\n          alreadyCalled = true;\n          values[$index] = value;\n          --remaining || resolve(values);\n        }, reject);\n      });\n      --remaining || resolve(values);\n    });\n    if (result.e) reject(result.v);\n    return capability.promise;\n  },\n  // 25.4.4.4 Promise.race(iterable)\n  race: function race(iterable) {\n    var C = this;\n    var capability = newPromiseCapability(C);\n    var reject = capability.reject;\n    var result = perform(function () {\n      forOf(iterable, false, function (promise) {\n        C.resolve(promise).then(capability.resolve, reject);\n      });\n    });\n    if (result.e) reject(result.v);\n    return capability.promise;\n  }\n});\n\n\n/***/ }),\n/* 207 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar $at = __webpack_require__(199)(true);\n\n// 21.1.3.27 String.prototype[@@iterator]()\n__webpack_require__(103)(String, 'String', function (iterated) {\n  this._t = String(iterated); // target\n  this._i = 0;                // next index\n// 21.1.5.2.1 %StringIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var index = this._i;\n  var point;\n  if (index >= O.length) return { value: undefined, done: true };\n  point = $at(O, index);\n  this._i += point.length;\n  return { value: point, done: false };\n});\n\n\n/***/ }),\n/* 208 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n// https://github.com/tc39/proposal-promise-finally\n\nvar $export = __webpack_require__(41);\nvar core = __webpack_require__(23);\nvar global = __webpack_require__(11);\nvar speciesConstructor = __webpack_require__(108);\nvar promiseResolve = __webpack_require__(105);\n\n$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {\n  var C = speciesConstructor(this, core.Promise || global.Promise);\n  var isFunction = typeof onFinally == 'function';\n  return this.then(\n    isFunction ? function (x) {\n      return promiseResolve(C, onFinally()).then(function () { return x; });\n    } : onFinally,\n    isFunction ? function (e) {\n      return promiseResolve(C, onFinally()).then(function () { throw e; });\n    } : onFinally\n  );\n} });\n\n\n/***/ }),\n/* 209 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// https://github.com/tc39/proposal-promise-try\nvar $export = __webpack_require__(41);\nvar newPromiseCapability = __webpack_require__(70);\nvar perform = __webpack_require__(104);\n\n$export($export.S, 'Promise', { 'try': function (callbackfn) {\n  var promiseCapability = newPromiseCapability.f(this);\n  var result = perform(callbackfn);\n  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);\n  return promiseCapability.promise;\n} });\n\n\n/***/ }),\n/* 210 */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(204);\nvar global = __webpack_require__(11);\nvar hide = __webpack_require__(31);\nvar Iterators = __webpack_require__(35);\nvar TO_STRING_TAG = __webpack_require__(13)('toStringTag');\n\nvar DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +\n  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +\n  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +\n  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +\n  'TextTrackList,TouchList').split(',');\n\nfor (var i = 0; i < DOMIterables.length; i++) {\n  var NAME = DOMIterables[i];\n  var Collection = global[NAME];\n  var proto = Collection && Collection.prototype;\n  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);\n  Iterators[NAME] = Iterators.Array;\n}\n\n\n/***/ }),\n/* 211 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = __webpack_require__(112);\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',\n  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',\n  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',\n  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',\n  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',\n  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',\n  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',\n  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',\n  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',\n  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',\n  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // Internet Explorer and Edge do not support colors.\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n    return false;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n\n/***/ }),\n/* 212 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Detect Electron renderer process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process === 'undefined' || process.type === 'renderer') {\n  module.exports = __webpack_require__(211);\n} else {\n  module.exports = __webpack_require__(213);\n}\n\n\n/***/ }),\n/* 213 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Module dependencies.\n */\n\nvar tty = __webpack_require__(79);\nvar util = __webpack_require__(2);\n\n/**\n * This is the Node.js implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = __webpack_require__(112);\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Colors.\n */\n\nexports.colors = [ 6, 2, 3, 4, 5, 1 ];\n\ntry {\n  var supportsColor = __webpack_require__(239);\n  if (supportsColor && supportsColor.level >= 2) {\n    exports.colors = [\n      20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68,\n      69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134,\n      135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171,\n      172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204,\n      205, 206, 207, 208, 209, 214, 215, 220, 221\n    ];\n  }\n} catch (err) {\n  // swallow - we only care if `supports-color` is available; it doesn't have to be.\n}\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(function (key) {\n  return /^debug_/i.test(key);\n}).reduce(function (obj, key) {\n  // camel-case\n  var prop = key\n    .substring(6)\n    .toLowerCase()\n    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });\n\n  // coerce string value into JS value\n  var val = process.env[key];\n  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;\n  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;\n  else if (val === 'null') val = null;\n  else val = Number(val);\n\n  obj[prop] = val;\n  return obj;\n}, {});\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n  return 'colors' in exports.inspectOpts\n    ? Boolean(exports.inspectOpts.colors)\n    : tty.isatty(process.stderr.fd);\n}\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nexports.formatters.o = function(v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts)\n    .split('\\n').map(function(str) {\n      return str.trim()\n    }).join(' ');\n};\n\n/**\n * Map %o to `util.inspect()`, allowing multiple lines if needed.\n */\n\nexports.formatters.O = function(v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts);\n};\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var name = this.namespace;\n  var useColors = this.useColors;\n\n  if (useColors) {\n    var c = this.color;\n    var colorCode = '\\u001b[3' + (c < 8 ? c : '8;5;' + c);\n    var prefix = '  ' + colorCode + ';1m' + name + ' ' + '\\u001b[0m';\n\n    args[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n    args.push(colorCode + 'm+' + exports.humanize(this.diff) + '\\u001b[0m');\n  } else {\n    args[0] = getDate() + name + ' ' + args[0];\n  }\n}\n\nfunction getDate() {\n  if (exports.inspectOpts.hideDate) {\n    return '';\n  } else {\n    return new Date().toISOString() + ' ';\n  }\n}\n\n/**\n * Invokes `util.format()` with the specified arguments and writes to stderr.\n */\n\nfunction log() {\n  return process.stderr.write(util.format.apply(util, arguments) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  if (null == namespaces) {\n    // If you set a process.env field to null or undefined, it gets cast to the\n    // string 'null' or 'undefined'. Just delete instead.\n    delete process.env.DEBUG;\n  } else {\n    process.env.DEBUG = namespaces;\n  }\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  return process.env.DEBUG;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init (debug) {\n  debug.inspectOpts = {};\n\n  var keys = Object.keys(exports.inspectOpts);\n  for (var i = 0; i < keys.length; i++) {\n    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n  }\n}\n\n/**\n * Enable namespaces listed in `process.env.DEBUG` initially.\n */\n\nexports.enable(load());\n\n\n/***/ }),\n/* 214 */,\n/* 215 */,\n/* 216 */,\n/* 217 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar pathModule = __webpack_require__(0);\nvar isWindows = process.platform === 'win32';\nvar fs = __webpack_require__(3);\n\n// JavaScript implementation of realpath, ported from node pre-v6\n\nvar DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);\n\nfunction rethrow() {\n  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and\n  // is fairly slow to generate.\n  var callback;\n  if (DEBUG) {\n    var backtrace = new Error;\n    callback = debugCallback;\n  } else\n    callback = missingCallback;\n\n  return callback;\n\n  function debugCallback(err) {\n    if (err) {\n      backtrace.message = err.message;\n      err = backtrace;\n      missingCallback(err);\n    }\n  }\n\n  function missingCallback(err) {\n    if (err) {\n      if (process.throwDeprecation)\n        throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs\n      else if (!process.noDeprecation) {\n        var msg = 'fs: missing callback ' + (err.stack || err.message);\n        if (process.traceDeprecation)\n          console.trace(msg);\n        else\n          console.error(msg);\n      }\n    }\n  }\n}\n\nfunction maybeCallback(cb) {\n  return typeof cb === 'function' ? cb : rethrow();\n}\n\nvar normalize = pathModule.normalize;\n\n// Regexp that finds the next partion of a (partial) path\n// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']\nif (isWindows) {\n  var nextPartRe = /(.*?)(?:[\\/\\\\]+|$)/g;\n} else {\n  var nextPartRe = /(.*?)(?:[\\/]+|$)/g;\n}\n\n// Regex to find the device root, including trailing slash. E.g. 'c:\\\\'.\nif (isWindows) {\n  var splitRootRe = /^(?:[a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/][^\\\\\\/]+)?[\\\\\\/]*/;\n} else {\n  var splitRootRe = /^[\\/]*/;\n}\n\nexports.realpathSync = function realpathSync(p, cache) {\n  // make p is absolute\n  p = pathModule.resolve(p);\n\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return cache[p];\n  }\n\n  var original = p,\n      seenLinks = {},\n      knownHard = {};\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  start();\n\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = '';\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstatSync(base);\n      knownHard[base] = true;\n    }\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  // NB: p.length changes.\n  while (pos < p.length) {\n    // find the next part\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex;\n\n    // continue if not a symlink\n    if (knownHard[base] || (cache && cache[base] === base)) {\n      continue;\n    }\n\n    var resolvedLink;\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // some known symbolic link.  no need to stat again.\n      resolvedLink = cache[base];\n    } else {\n      var stat = fs.lstatSync(base);\n      if (!stat.isSymbolicLink()) {\n        knownHard[base] = true;\n        if (cache) cache[base] = base;\n        continue;\n      }\n\n      // read the link if it wasn't read before\n      // dev/ino always return 0 on windows, so skip the check.\n      var linkTarget = null;\n      if (!isWindows) {\n        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n        if (seenLinks.hasOwnProperty(id)) {\n          linkTarget = seenLinks[id];\n        }\n      }\n      if (linkTarget === null) {\n        fs.statSync(base);\n        linkTarget = fs.readlinkSync(base);\n      }\n      resolvedLink = pathModule.resolve(previous, linkTarget);\n      // track this, if given a cache.\n      if (cache) cache[base] = resolvedLink;\n      if (!isWindows) seenLinks[id] = linkTarget;\n    }\n\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n\n  if (cache) cache[original] = p;\n\n  return p;\n};\n\n\nexports.realpath = function realpath(p, cache, cb) {\n  if (typeof cb !== 'function') {\n    cb = maybeCallback(cache);\n    cache = null;\n  }\n\n  // make p is absolute\n  p = pathModule.resolve(p);\n\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return process.nextTick(cb.bind(null, null, cache[p]));\n  }\n\n  var original = p,\n      seenLinks = {},\n      knownHard = {};\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  start();\n\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = '';\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstat(base, function(err) {\n        if (err) return cb(err);\n        knownHard[base] = true;\n        LOOP();\n      });\n    } else {\n      process.nextTick(LOOP);\n    }\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  function LOOP() {\n    // stop if scanned past end of path\n    if (pos >= p.length) {\n      if (cache) cache[original] = p;\n      return cb(null, p);\n    }\n\n    // find the next part\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex;\n\n    // continue if not a symlink\n    if (knownHard[base] || (cache && cache[base] === base)) {\n      return process.nextTick(LOOP);\n    }\n\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // known symbolic link.  no need to stat again.\n      return gotResolvedLink(cache[base]);\n    }\n\n    return fs.lstat(base, gotStat);\n  }\n\n  function gotStat(err, stat) {\n    if (err) return cb(err);\n\n    // if not a symlink, skip to the next path part\n    if (!stat.isSymbolicLink()) {\n      knownHard[base] = true;\n      if (cache) cache[base] = base;\n      return process.nextTick(LOOP);\n    }\n\n    // stat & read the link if not read before\n    // call gotTarget as soon as the link target is known\n    // dev/ino always return 0 on windows, so skip the check.\n    if (!isWindows) {\n      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n      if (seenLinks.hasOwnProperty(id)) {\n        return gotTarget(null, seenLinks[id], base);\n      }\n    }\n    fs.stat(base, function(err) {\n      if (err) return cb(err);\n\n      fs.readlink(base, function(err, target) {\n        if (!isWindows) seenLinks[id] = target;\n        gotTarget(err, target);\n      });\n    });\n  }\n\n  function gotTarget(err, target, base) {\n    if (err) return cb(err);\n\n    var resolvedLink = pathModule.resolve(previous, target);\n    if (cache) cache[base] = resolvedLink;\n    gotResolvedLink(resolvedLink);\n  }\n\n  function gotResolvedLink(resolvedLink) {\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n};\n\n\n/***/ }),\n/* 218 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = globSync\nglobSync.GlobSync = GlobSync\n\nvar fs = __webpack_require__(3)\nvar rp = __webpack_require__(114)\nvar minimatch = __webpack_require__(60)\nvar Minimatch = minimatch.Minimatch\nvar Glob = __webpack_require__(75).Glob\nvar util = __webpack_require__(2)\nvar path = __webpack_require__(0)\nvar assert = __webpack_require__(22)\nvar isAbsolute = __webpack_require__(76)\nvar common = __webpack_require__(115)\nvar alphasort = common.alphasort\nvar alphasorti = common.alphasorti\nvar setopts = common.setopts\nvar ownProp = common.ownProp\nvar childrenIgnored = common.childrenIgnored\nvar isIgnored = common.isIgnored\n\nfunction globSync (pattern, options) {\n  if (typeof options === 'function' || arguments.length === 3)\n    throw new TypeError('callback provided to sync glob\\n'+\n                        'See: https://github.com/isaacs/node-glob/issues/167')\n\n  return new GlobSync(pattern, options).found\n}\n\nfunction GlobSync (pattern, options) {\n  if (!pattern)\n    throw new Error('must provide pattern')\n\n  if (typeof options === 'function' || arguments.length === 3)\n    throw new TypeError('callback provided to sync glob\\n'+\n                        'See: https://github.com/isaacs/node-glob/issues/167')\n\n  if (!(this instanceof GlobSync))\n    return new GlobSync(pattern, options)\n\n  setopts(this, pattern, options)\n\n  if (this.noprocess)\n    return this\n\n  var n = this.minimatch.set.length\n  this.matches = new Array(n)\n  for (var i = 0; i < n; i ++) {\n    this._process(this.minimatch.set[i], i, false)\n  }\n  this._finish()\n}\n\nGlobSync.prototype._finish = function () {\n  assert(this instanceof GlobSync)\n  if (this.realpath) {\n    var self = this\n    this.matches.forEach(function (matchset, index) {\n      var set = self.matches[index] = Object.create(null)\n      for (var p in matchset) {\n        try {\n          p = self._makeAbs(p)\n          var real = rp.realpathSync(p, self.realpathCache)\n          set[real] = true\n        } catch (er) {\n          if (er.syscall === 'stat')\n            set[self._makeAbs(p)] = true\n          else\n            throw er\n        }\n      }\n    })\n  }\n  common.finish(this)\n}\n\n\nGlobSync.prototype._process = function (pattern, index, inGlobStar) {\n  assert(this instanceof GlobSync)\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0\n  while (typeof pattern[n] === 'string') {\n    n ++\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // See if there's anything else\n  var prefix\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index)\n      return\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null\n      break\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/')\n      break\n  }\n\n  var remain = pattern.slice(n)\n\n  // get the list of entries.\n  var read\n  if (prefix === null)\n    read = '.'\n  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {\n    if (!prefix || !isAbsolute(prefix))\n      prefix = '/' + prefix\n    read = prefix\n  } else\n    read = prefix\n\n  var abs = this._makeAbs(read)\n\n  //if ignored, skip processing\n  if (childrenIgnored(this, read))\n    return\n\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR\n  if (isGlobStar)\n    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)\n  else\n    this._processReaddir(prefix, read, abs, remain, index, inGlobStar)\n}\n\n\nGlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {\n  var entries = this._readdir(abs, inGlobStar)\n\n  // if the abs isn't a dir, then nothing can match!\n  if (!entries)\n    return\n\n  // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n  var pn = remain[0]\n  var negate = !!this.minimatch.negate\n  var rawGlob = pn._glob\n  var dotOk = this.dot || rawGlob.charAt(0) === '.'\n\n  var matchedEntries = []\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i]\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m\n      if (negate && !prefix) {\n        m = !e.match(pn)\n      } else {\n        m = e.match(pn)\n      }\n      if (m)\n        matchedEntries.push(e)\n    }\n  }\n\n  var len = matchedEntries.length\n  // If there are no matched entries, then nothing matches.\n  if (len === 0)\n    return\n\n  // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index])\n      this.matches[index] = Object.create(null)\n\n    for (var i = 0; i < len; i ++) {\n      var e = matchedEntries[i]\n      if (prefix) {\n        if (prefix.slice(-1) !== '/')\n          e = prefix + '/' + e\n        else\n          e = prefix + e\n      }\n\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path.join(this.root, e)\n      }\n      this._emitMatch(index, e)\n    }\n    // This was the last one, and no stats were needed\n    return\n  }\n\n  // now test all matched entries as stand-ins for that part\n  // of the pattern.\n  remain.shift()\n  for (var i = 0; i < len; i ++) {\n    var e = matchedEntries[i]\n    var newPattern\n    if (prefix)\n      newPattern = [prefix, e]\n    else\n      newPattern = [e]\n    this._process(newPattern.concat(remain), index, inGlobStar)\n  }\n}\n\n\nGlobSync.prototype._emitMatch = function (index, e) {\n  if (isIgnored(this, e))\n    return\n\n  var abs = this._makeAbs(e)\n\n  if (this.mark)\n    e = this._mark(e)\n\n  if (this.absolute) {\n    e = abs\n  }\n\n  if (this.matches[index][e])\n    return\n\n  if (this.nodir) {\n    var c = this.cache[abs]\n    if (c === 'DIR' || Array.isArray(c))\n      return\n  }\n\n  this.matches[index][e] = true\n\n  if (this.stat)\n    this._stat(e)\n}\n\n\nGlobSync.prototype._readdirInGlobStar = function (abs) {\n  // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n  if (this.follow)\n    return this._readdir(abs, false)\n\n  var entries\n  var lstat\n  var stat\n  try {\n    lstat = fs.lstatSync(abs)\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      // lstat failed, doesn't exist\n      return null\n    }\n  }\n\n  var isSym = lstat && lstat.isSymbolicLink()\n  this.symlinks[abs] = isSym\n\n  // If it's not a symlink or a dir, then it's definitely a regular file.\n  // don't bother doing a readdir in that case.\n  if (!isSym && lstat && !lstat.isDirectory())\n    this.cache[abs] = 'FILE'\n  else\n    entries = this._readdir(abs, false)\n\n  return entries\n}\n\nGlobSync.prototype._readdir = function (abs, inGlobStar) {\n  var entries\n\n  if (inGlobStar && !ownProp(this.symlinks, abs))\n    return this._readdirInGlobStar(abs)\n\n  if (ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n    if (!c || c === 'FILE')\n      return null\n\n    if (Array.isArray(c))\n      return c\n  }\n\n  try {\n    return this._readdirEntries(abs, fs.readdirSync(abs))\n  } catch (er) {\n    this._readdirError(abs, er)\n    return null\n  }\n}\n\nGlobSync.prototype._readdirEntries = function (abs, entries) {\n  // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i ++) {\n      var e = entries[i]\n      if (abs === '/')\n        e = abs + e\n      else\n        e = abs + '/' + e\n      this.cache[e] = true\n    }\n  }\n\n  this.cache[abs] = entries\n\n  // mark and cache dir-ness\n  return entries\n}\n\nGlobSync.prototype._readdirError = function (f, er) {\n  // handle errors, and cache the information\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n    case 'ENOTDIR': // totally normal. means it *does* exist.\n      var abs = this._makeAbs(f)\n      this.cache[abs] = 'FILE'\n      if (abs === this.cwdAbs) {\n        var error = new Error(er.code + ' invalid cwd ' + this.cwd)\n        error.path = this.cwd\n        error.code = er.code\n        throw error\n      }\n      break\n\n    case 'ENOENT': // not terribly unusual\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false\n      break\n\n    default: // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false\n      if (this.strict)\n        throw er\n      if (!this.silent)\n        console.error('glob error', er)\n      break\n  }\n}\n\nGlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {\n\n  var entries = this._readdir(abs, inGlobStar)\n\n  // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n  if (!entries)\n    return\n\n  // test without the globstar, and with every child both below\n  // and replacing the globstar.\n  var remainWithoutGlobStar = remain.slice(1)\n  var gspref = prefix ? [ prefix ] : []\n  var noGlobStar = gspref.concat(remainWithoutGlobStar)\n\n  // the noGlobStar pattern exits the inGlobStar state\n  this._process(noGlobStar, index, false)\n\n  var len = entries.length\n  var isSym = this.symlinks[abs]\n\n  // If it's a symlink, and we're in a globstar, then stop\n  if (isSym && inGlobStar)\n    return\n\n  for (var i = 0; i < len; i++) {\n    var e = entries[i]\n    if (e.charAt(0) === '.' && !this.dot)\n      continue\n\n    // these two cases enter the inGlobStar state\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar)\n    this._process(instead, index, true)\n\n    var below = gspref.concat(entries[i], remain)\n    this._process(below, index, true)\n  }\n}\n\nGlobSync.prototype._processSimple = function (prefix, index) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var exists = this._stat(prefix)\n\n  if (!this.matches[index])\n    this.matches[index] = Object.create(null)\n\n  // If it doesn't exist, then just mark the lack of results\n  if (!exists)\n    return\n\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix)\n    if (prefix.charAt(0) === '/') {\n      prefix = path.join(this.root, prefix)\n    } else {\n      prefix = path.resolve(this.root, prefix)\n      if (trail)\n        prefix += '/'\n    }\n  }\n\n  if (process.platform === 'win32')\n    prefix = prefix.replace(/\\\\/g, '/')\n\n  // Mark this as a match\n  this._emitMatch(index, prefix)\n}\n\n// Returns either 'DIR', 'FILE', or false\nGlobSync.prototype._stat = function (f) {\n  var abs = this._makeAbs(f)\n  var needDir = f.slice(-1) === '/'\n\n  if (f.length > this.maxLength)\n    return false\n\n  if (!this.stat && ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n\n    if (Array.isArray(c))\n      c = 'DIR'\n\n    // It exists, but maybe not how we need it\n    if (!needDir || c === 'DIR')\n      return c\n\n    if (needDir && c === 'FILE')\n      return false\n\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n\n  var exists\n  var stat = this.statCache[abs]\n  if (!stat) {\n    var lstat\n    try {\n      lstat = fs.lstatSync(abs)\n    } catch (er) {\n      if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {\n        this.statCache[abs] = false\n        return false\n      }\n    }\n\n    if (lstat && lstat.isSymbolicLink()) {\n      try {\n        stat = fs.statSync(abs)\n      } catch (er) {\n        stat = lstat\n      }\n    } else {\n      stat = lstat\n    }\n  }\n\n  this.statCache[abs] = stat\n\n  var c = true\n  if (stat)\n    c = stat.isDirectory() ? 'DIR' : 'FILE'\n\n  this.cache[abs] = this.cache[abs] || c\n\n  if (needDir && c === 'FILE')\n    return false\n\n  return c\n}\n\nGlobSync.prototype._mark = function (p) {\n  return common.mark(this, p)\n}\n\nGlobSync.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f)\n}\n\n\n/***/ }),\n/* 219 */,\n/* 220 */,\n/* 221 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nmodule.exports = function (flag, argv) {\n\targv = argv || process.argv;\n\n\tvar terminatorPos = argv.indexOf('--');\n\tvar prefix = /^--/.test(flag) ? '' : '--';\n\tvar pos = argv.indexOf(prefix + flag);\n\n\treturn pos !== -1 && (terminatorPos !== -1 ? pos < terminatorPos : true);\n};\n\n\n/***/ }),\n/* 222 */,\n/* 223 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar wrappy = __webpack_require__(123)\nvar reqs = Object.create(null)\nvar once = __webpack_require__(61)\n\nmodule.exports = wrappy(inflight)\n\nfunction inflight (key, cb) {\n  if (reqs[key]) {\n    reqs[key].push(cb)\n    return null\n  } else {\n    reqs[key] = [cb]\n    return makeres(key)\n  }\n}\n\nfunction makeres (key) {\n  return once(function RES () {\n    var cbs = reqs[key]\n    var len = cbs.length\n    var args = slice(arguments)\n\n    // XXX It's somewhat ambiguous whether a new callback added in this\n    // pass should be queued for later execution if something in the\n    // list of callbacks throws, or if it should just be discarded.\n    // However, it's such an edge case that it hardly matters, and either\n    // choice is likely as surprising as the other.\n    // As it happens, we do go ahead and schedule it for later execution.\n    try {\n      for (var i = 0; i < len; i++) {\n        cbs[i].apply(null, args)\n      }\n    } finally {\n      if (cbs.length > len) {\n        // added more in the interim.\n        // de-zalgo, just in case, but don't call again.\n        cbs.splice(0, len)\n        process.nextTick(function () {\n          RES.apply(null, args)\n        })\n      } else {\n        delete reqs[key]\n      }\n    }\n  })\n}\n\nfunction slice (args) {\n  var length = args.length\n  var array = []\n\n  for (var i = 0; i < length; i++) array[i] = args[i]\n  return array\n}\n\n\n/***/ }),\n/* 224 */\n/***/ (function(module, exports) {\n\nif (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n/***/ }),\n/* 225 */,\n/* 226 */,\n/* 227 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// @flow\n\n/*::\ndeclare var __webpack_require__: mixed;\n*/\n\nmodule.exports = typeof __webpack_require__ !== \"undefined\";\n\n\n/***/ }),\n/* 228 */,\n/* 229 */\n/***/ (function(module, exports) {\n\n/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n\n/***/ }),\n/* 230 */,\n/* 231 */,\n/* 232 */,\n/* 233 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = rimraf\nrimraf.sync = rimrafSync\n\nvar assert = __webpack_require__(22)\nvar path = __webpack_require__(0)\nvar fs = __webpack_require__(3)\nvar glob = __webpack_require__(75)\nvar _0666 = parseInt('666', 8)\n\nvar defaultGlobOpts = {\n  nosort: true,\n  silent: true\n}\n\n// for EMFILE handling\nvar timeout = 0\n\nvar isWindows = (process.platform === \"win32\")\n\nfunction defaults (options) {\n  var methods = [\n    'unlink',\n    'chmod',\n    'stat',\n    'lstat',\n    'rmdir',\n    'readdir'\n  ]\n  methods.forEach(function(m) {\n    options[m] = options[m] || fs[m]\n    m = m + 'Sync'\n    options[m] = options[m] || fs[m]\n  })\n\n  options.maxBusyTries = options.maxBusyTries || 3\n  options.emfileWait = options.emfileWait || 1000\n  if (options.glob === false) {\n    options.disableGlob = true\n  }\n  options.disableGlob = options.disableGlob || false\n  options.glob = options.glob || defaultGlobOpts\n}\n\nfunction rimraf (p, options, cb) {\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  assert(p, 'rimraf: missing path')\n  assert.equal(typeof p, 'string', 'rimraf: path should be a string')\n  assert.equal(typeof cb, 'function', 'rimraf: callback function required')\n  assert(options, 'rimraf: invalid options argument provided')\n  assert.equal(typeof options, 'object', 'rimraf: options should be object')\n\n  defaults(options)\n\n  var busyTries = 0\n  var errState = null\n  var n = 0\n\n  if (options.disableGlob || !glob.hasMagic(p))\n    return afterGlob(null, [p])\n\n  options.lstat(p, function (er, stat) {\n    if (!er)\n      return afterGlob(null, [p])\n\n    glob(p, options.glob, afterGlob)\n  })\n\n  function next (er) {\n    errState = errState || er\n    if (--n === 0)\n      cb(errState)\n  }\n\n  function afterGlob (er, results) {\n    if (er)\n      return cb(er)\n\n    n = results.length\n    if (n === 0)\n      return cb()\n\n    results.forEach(function (p) {\n      rimraf_(p, options, function CB (er) {\n        if (er) {\n          if ((er.code === \"EBUSY\" || er.code === \"ENOTEMPTY\" || er.code === \"EPERM\") &&\n              busyTries < options.maxBusyTries) {\n            busyTries ++\n            var time = busyTries * 100\n            // try again, with the same exact callback as this one.\n            return setTimeout(function () {\n              rimraf_(p, options, CB)\n            }, time)\n          }\n\n          // this one won't happen if graceful-fs is used.\n          if (er.code === \"EMFILE\" && timeout < options.emfileWait) {\n            return setTimeout(function () {\n              rimraf_(p, options, CB)\n            }, timeout ++)\n          }\n\n          // already gone\n          if (er.code === \"ENOENT\") er = null\n        }\n\n        timeout = 0\n        next(er)\n      })\n    })\n  }\n}\n\n// Two possible strategies.\n// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR\n// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR\n//\n// Both result in an extra syscall when you guess wrong.  However, there\n// are likely far more normal files in the world than directories.  This\n// is based on the assumption that a the average number of files per\n// directory is >= 1.\n//\n// If anyone ever complains about this, then I guess the strategy could\n// be made configurable somehow.  But until then, YAGNI.\nfunction rimraf_ (p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  // sunos lets the root user unlink directories, which is... weird.\n  // so we have to lstat here and make sure it's not a dir.\n  options.lstat(p, function (er, st) {\n    if (er && er.code === \"ENOENT\")\n      return cb(null)\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er && er.code === \"EPERM\" && isWindows)\n      fixWinEPERM(p, options, er, cb)\n\n    if (st && st.isDirectory())\n      return rmdir(p, options, er, cb)\n\n    options.unlink(p, function (er) {\n      if (er) {\n        if (er.code === \"ENOENT\")\n          return cb(null)\n        if (er.code === \"EPERM\")\n          return (isWindows)\n            ? fixWinEPERM(p, options, er, cb)\n            : rmdir(p, options, er, cb)\n        if (er.code === \"EISDIR\")\n          return rmdir(p, options, er, cb)\n      }\n      return cb(er)\n    })\n  })\n}\n\nfunction fixWinEPERM (p, options, er, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n  if (er)\n    assert(er instanceof Error)\n\n  options.chmod(p, _0666, function (er2) {\n    if (er2)\n      cb(er2.code === \"ENOENT\" ? null : er)\n    else\n      options.stat(p, function(er3, stats) {\n        if (er3)\n          cb(er3.code === \"ENOENT\" ? null : er)\n        else if (stats.isDirectory())\n          rmdir(p, options, er, cb)\n        else\n          options.unlink(p, cb)\n      })\n  })\n}\n\nfunction fixWinEPERMSync (p, options, er) {\n  assert(p)\n  assert(options)\n  if (er)\n    assert(er instanceof Error)\n\n  try {\n    options.chmodSync(p, _0666)\n  } catch (er2) {\n    if (er2.code === \"ENOENT\")\n      return\n    else\n      throw er\n  }\n\n  try {\n    var stats = options.statSync(p)\n  } catch (er3) {\n    if (er3.code === \"ENOENT\")\n      return\n    else\n      throw er\n  }\n\n  if (stats.isDirectory())\n    rmdirSync(p, options, er)\n  else\n    options.unlinkSync(p)\n}\n\nfunction rmdir (p, options, originalEr, cb) {\n  assert(p)\n  assert(options)\n  if (originalEr)\n    assert(originalEr instanceof Error)\n  assert(typeof cb === 'function')\n\n  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)\n  // if we guessed wrong, and it's not a directory, then\n  // raise the original error.\n  options.rmdir(p, function (er) {\n    if (er && (er.code === \"ENOTEMPTY\" || er.code === \"EEXIST\" || er.code === \"EPERM\"))\n      rmkids(p, options, cb)\n    else if (er && er.code === \"ENOTDIR\")\n      cb(originalEr)\n    else\n      cb(er)\n  })\n}\n\nfunction rmkids(p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  options.readdir(p, function (er, files) {\n    if (er)\n      return cb(er)\n    var n = files.length\n    if (n === 0)\n      return options.rmdir(p, cb)\n    var errState\n    files.forEach(function (f) {\n      rimraf(path.join(p, f), options, function (er) {\n        if (errState)\n          return\n        if (er)\n          return cb(errState = er)\n        if (--n === 0)\n          options.rmdir(p, cb)\n      })\n    })\n  })\n}\n\n// this looks simpler, and is strictly *faster*, but will\n// tie up the JavaScript thread and fail on excessively\n// deep directory trees.\nfunction rimrafSync (p, options) {\n  options = options || {}\n  defaults(options)\n\n  assert(p, 'rimraf: missing path')\n  assert.equal(typeof p, 'string', 'rimraf: path should be a string')\n  assert(options, 'rimraf: missing options')\n  assert.equal(typeof options, 'object', 'rimraf: options should be object')\n\n  var results\n\n  if (options.disableGlob || !glob.hasMagic(p)) {\n    results = [p]\n  } else {\n    try {\n      options.lstatSync(p)\n      results = [p]\n    } catch (er) {\n      results = glob.sync(p, options.glob)\n    }\n  }\n\n  if (!results.length)\n    return\n\n  for (var i = 0; i < results.length; i++) {\n    var p = results[i]\n\n    try {\n      var st = options.lstatSync(p)\n    } catch (er) {\n      if (er.code === \"ENOENT\")\n        return\n\n      // Windows can EPERM on stat.  Life is suffering.\n      if (er.code === \"EPERM\" && isWindows)\n        fixWinEPERMSync(p, options, er)\n    }\n\n    try {\n      // sunos lets the root user unlink directories, which is... weird.\n      if (st && st.isDirectory())\n        rmdirSync(p, options, null)\n      else\n        options.unlinkSync(p)\n    } catch (er) {\n      if (er.code === \"ENOENT\")\n        return\n      if (er.code === \"EPERM\")\n        return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)\n      if (er.code !== \"EISDIR\")\n        throw er\n\n      rmdirSync(p, options, er)\n    }\n  }\n}\n\nfunction rmdirSync (p, options, originalEr) {\n  assert(p)\n  assert(options)\n  if (originalEr)\n    assert(originalEr instanceof Error)\n\n  try {\n    options.rmdirSync(p)\n  } catch (er) {\n    if (er.code === \"ENOENT\")\n      return\n    if (er.code === \"ENOTDIR\")\n      throw originalEr\n    if (er.code === \"ENOTEMPTY\" || er.code === \"EEXIST\" || er.code === \"EPERM\")\n      rmkidsSync(p, options)\n  }\n}\n\nfunction rmkidsSync (p, options) {\n  assert(p)\n  assert(options)\n  options.readdirSync(p).forEach(function (f) {\n    rimrafSync(path.join(p, f), options)\n  })\n\n  // We only end up here once we got ENOTEMPTY at least once, and\n  // at this point, we are guaranteed to have removed all the kids.\n  // So, we know that it won't be ENOENT or ENOTDIR or anything else.\n  // try really hard to delete stuff on windows, because it has a\n  // PROFOUNDLY annoying habit of not closing handles promptly when\n  // files are deleted, resulting in spurious ENOTEMPTY errors.\n  var retries = isWindows ? 100 : 1\n  var i = 0\n  do {\n    var threw = true\n    try {\n      var ret = options.rmdirSync(p, options)\n      threw = false\n      return ret\n    } finally {\n      if (++i < retries && threw)\n        continue\n    }\n  } while (true)\n}\n\n\n/***/ }),\n/* 234 */,\n/* 235 */,\n/* 236 */,\n/* 237 */,\n/* 238 */,\n/* 239 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar hasFlag = __webpack_require__(221);\n\nvar support = function (level) {\n\tif (level === 0) {\n\t\treturn false;\n\t}\n\n\treturn {\n\t\tlevel: level,\n\t\thasBasic: true,\n\t\thas256: level >= 2,\n\t\thas16m: level >= 3\n\t};\n};\n\nvar supportLevel = (function () {\n\tif (hasFlag('no-color') ||\n\t\thasFlag('no-colors') ||\n\t\thasFlag('color=false')) {\n\t\treturn 0;\n\t}\n\n\tif (hasFlag('color=16m') ||\n\t\thasFlag('color=full') ||\n\t\thasFlag('color=truecolor')) {\n\t\treturn 3;\n\t}\n\n\tif (hasFlag('color=256')) {\n\t\treturn 2;\n\t}\n\n\tif (hasFlag('color') ||\n\t\thasFlag('colors') ||\n\t\thasFlag('color=true') ||\n\t\thasFlag('color=always')) {\n\t\treturn 1;\n\t}\n\n\tif (process.stdout && !process.stdout.isTTY) {\n\t\treturn 0;\n\t}\n\n\tif (process.platform === 'win32') {\n\t\treturn 1;\n\t}\n\n\tif ('CI' in process.env) {\n\t\tif ('TRAVIS' in process.env || process.env.CI === 'Travis') {\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif ('TEAMCITY_VERSION' in process.env) {\n\t\treturn process.env.TEAMCITY_VERSION.match(/^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/) === null ? 0 : 1;\n\t}\n\n\tif (/^(screen|xterm)-256(?:color)?/.test(process.env.TERM)) {\n\t\treturn 2;\n\t}\n\n\tif (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {\n\t\treturn 1;\n\t}\n\n\tif ('COLORTERM' in process.env) {\n\t\treturn 1;\n\t}\n\n\tif (process.env.TERM === 'dumb') {\n\t\treturn 0;\n\t}\n\n\treturn 0;\n})();\n\nif (supportLevel === 0 && 'FORCE_COLOR' in process.env) {\n\tsupportLevel = 1;\n}\n\nmodule.exports = process && support(supportLevel);\n\n\n/***/ })\n/******/ ]);",
    "package.json": "{\n  \"name\": \"@yarnpkg/lockfile\",\n  \"version\": \"1.1.0\",\n  \"description\": \"The parser/stringifier for Yarn lockfiles.\",\n  \"main\": \"index.js\",\n  \"repository\": \"https://github.com/yarnpkg/yarn/blob/master/packages/lockfile\",\n  \"keywords\": [\n    \"yarn\",\n    \"yarnpkg\",\n    \"lockfile\",\n    \"dependency\",\n    \"npm\"\n  ],\n  \"license\": \"BSD-2-Clause\"\n}\n"
  },
  "externals": [
    "path",
    "util",
    "fs",
    "crypto",
    "stream",
    "assert",
    "os",
    "events",
    "buffer",
    "tty"
  ]
}
