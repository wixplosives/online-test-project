{
  "packageName": "@jridgewell/sourcemap-codec",
  "packageVersion": "1.4.15",
  "request": "@jridgewell/sourcemap-codec",
  "resolved": "dist/sourcemap-codec.umd.js",
  "files": {
    "dist/sourcemap-codec.umd.js": "(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.sourcemapCodec = {}));\n})(this, (function (exports) { 'use strict';\n\n    const comma = ','.charCodeAt(0);\n    const semicolon = ';'.charCodeAt(0);\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    const intToChar = new Uint8Array(64); // 64 possible chars.\n    const charToInt = new Uint8Array(128); // z is 122 in ASCII\n    for (let i = 0; i < chars.length; i++) {\n        const c = chars.charCodeAt(i);\n        intToChar[i] = c;\n        charToInt[c] = i;\n    }\n    // Provide a fallback for older environments.\n    const td = typeof TextDecoder !== 'undefined'\n        ? /* #__PURE__ */ new TextDecoder()\n        : typeof Buffer !== 'undefined'\n            ? {\n                decode(buf) {\n                    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n                    return out.toString();\n                },\n            }\n            : {\n                decode(buf) {\n                    let out = '';\n                    for (let i = 0; i < buf.length; i++) {\n                        out += String.fromCharCode(buf[i]);\n                    }\n                    return out;\n                },\n            };\n    function decode(mappings) {\n        const state = new Int32Array(5);\n        const decoded = [];\n        let index = 0;\n        do {\n            const semi = indexOf(mappings, index);\n            const line = [];\n            let sorted = true;\n            let lastCol = 0;\n            state[0] = 0;\n            for (let i = index; i < semi; i++) {\n                let seg;\n                i = decodeInteger(mappings, i, state, 0); // genColumn\n                const col = state[0];\n                if (col < lastCol)\n                    sorted = false;\n                lastCol = col;\n                if (hasMoreVlq(mappings, i, semi)) {\n                    i = decodeInteger(mappings, i, state, 1); // sourcesIndex\n                    i = decodeInteger(mappings, i, state, 2); // sourceLine\n                    i = decodeInteger(mappings, i, state, 3); // sourceColumn\n                    if (hasMoreVlq(mappings, i, semi)) {\n                        i = decodeInteger(mappings, i, state, 4); // namesIndex\n                        seg = [col, state[1], state[2], state[3], state[4]];\n                    }\n                    else {\n                        seg = [col, state[1], state[2], state[3]];\n                    }\n                }\n                else {\n                    seg = [col];\n                }\n                line.push(seg);\n            }\n            if (!sorted)\n                sort(line);\n            decoded.push(line);\n            index = semi + 1;\n        } while (index <= mappings.length);\n        return decoded;\n    }\n    function indexOf(mappings, index) {\n        const idx = mappings.indexOf(';', index);\n        return idx === -1 ? mappings.length : idx;\n    }\n    function decodeInteger(mappings, pos, state, j) {\n        let value = 0;\n        let shift = 0;\n        let integer = 0;\n        do {\n            const c = mappings.charCodeAt(pos++);\n            integer = charToInt[c];\n            value |= (integer & 31) << shift;\n            shift += 5;\n        } while (integer & 32);\n        const shouldNegate = value & 1;\n        value >>>= 1;\n        if (shouldNegate) {\n            value = -0x80000000 | -value;\n        }\n        state[j] += value;\n        return pos;\n    }\n    function hasMoreVlq(mappings, i, length) {\n        if (i >= length)\n            return false;\n        return mappings.charCodeAt(i) !== comma;\n    }\n    function sort(line) {\n        line.sort(sortComparator);\n    }\n    function sortComparator(a, b) {\n        return a[0] - b[0];\n    }\n    function encode(decoded) {\n        const state = new Int32Array(5);\n        const bufLength = 1024 * 16;\n        const subLength = bufLength - 36;\n        const buf = new Uint8Array(bufLength);\n        const sub = buf.subarray(0, subLength);\n        let pos = 0;\n        let out = '';\n        for (let i = 0; i < decoded.length; i++) {\n            const line = decoded[i];\n            if (i > 0) {\n                if (pos === bufLength) {\n                    out += td.decode(buf);\n                    pos = 0;\n                }\n                buf[pos++] = semicolon;\n            }\n            if (line.length === 0)\n                continue;\n            state[0] = 0;\n            for (let j = 0; j < line.length; j++) {\n                const segment = line[j];\n                // We can push up to 5 ints, each int can take at most 7 chars, and we\n                // may push a comma.\n                if (pos > subLength) {\n                    out += td.decode(sub);\n                    buf.copyWithin(0, subLength, pos);\n                    pos -= subLength;\n                }\n                if (j > 0)\n                    buf[pos++] = comma;\n                pos = encodeInteger(buf, pos, state, segment, 0); // genColumn\n                if (segment.length === 1)\n                    continue;\n                pos = encodeInteger(buf, pos, state, segment, 1); // sourcesIndex\n                pos = encodeInteger(buf, pos, state, segment, 2); // sourceLine\n                pos = encodeInteger(buf, pos, state, segment, 3); // sourceColumn\n                if (segment.length === 4)\n                    continue;\n                pos = encodeInteger(buf, pos, state, segment, 4); // namesIndex\n            }\n        }\n        return out + td.decode(buf.subarray(0, pos));\n    }\n    function encodeInteger(buf, pos, state, segment, j) {\n        const next = segment[j];\n        let num = next - state[j];\n        state[j] = next;\n        num = num < 0 ? (-num << 1) | 1 : num << 1;\n        do {\n            let clamped = num & 0b011111;\n            num >>>= 5;\n            if (num > 0)\n                clamped |= 0b100000;\n            buf[pos++] = intToChar[clamped];\n        } while (num > 0);\n        return pos;\n    }\n\n    exports.decode = decode;\n    exports.encode = encode;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=sourcemap-codec.umd.js.map\n",
    "package.json": "{\n  \"name\": \"@jridgewell/sourcemap-codec\",\n  \"version\": \"1.4.15\",\n  \"description\": \"Encode/decode sourcemap mappings\",\n  \"keywords\": [\n    \"sourcemap\",\n    \"vlq\"\n  ],\n  \"main\": \"dist/sourcemap-codec.umd.js\",\n  \"module\": \"dist/sourcemap-codec.mjs\",\n  \"types\": \"dist/types/sourcemap-codec.d.ts\",\n  \"files\": [\n    \"dist\"\n  ],\n  \"exports\": {\n    \".\": [\n      {\n        \"types\": \"./dist/types/sourcemap-codec.d.ts\",\n        \"browser\": \"./dist/sourcemap-codec.umd.js\",\n        \"require\": \"./dist/sourcemap-codec.umd.js\",\n        \"import\": \"./dist/sourcemap-codec.mjs\"\n      },\n      \"./dist/sourcemap-codec.umd.js\"\n    ],\n    \"./package.json\": \"./package.json\"\n  },\n  \"scripts\": {\n    \"benchmark\": \"run-s build:rollup benchmark:*\",\n    \"benchmark:install\": \"cd benchmark && npm install\",\n    \"benchmark:only\": \"node --expose-gc benchmark/index.js\",\n    \"build\": \"run-s -n build:*\",\n    \"build:rollup\": \"rollup -c rollup.config.js\",\n    \"build:ts\": \"tsc --project tsconfig.build.json\",\n    \"lint\": \"run-s -n lint:*\",\n    \"lint:prettier\": \"npm run test:lint:prettier -- --write\",\n    \"lint:ts\": \"npm run test:lint:ts -- --fix\",\n    \"prebuild\": \"rm -rf dist\",\n    \"prepublishOnly\": \"npm run preversion\",\n    \"preversion\": \"run-s test build\",\n    \"pretest\": \"run-s build:rollup\",\n    \"test\": \"run-s -n test:lint test:only\",\n    \"test:debug\": \"mocha --inspect-brk\",\n    \"test:lint\": \"run-s -n test:lint:*\",\n    \"test:lint:prettier\": \"prettier --check '{src,test}/**/*.ts'\",\n    \"test:lint:ts\": \"eslint '{src,test}/**/*.ts'\",\n    \"test:only\": \"mocha\",\n    \"test:coverage\": \"c8 mocha\",\n    \"test:watch\": \"mocha --watch\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/jridgewell/sourcemap-codec.git\"\n  },\n  \"author\": \"Rich Harris\",\n  \"license\": \"MIT\",\n  \"devDependencies\": {\n    \"@rollup/plugin-typescript\": \"8.3.0\",\n    \"@types/node\": \"17.0.15\",\n    \"@typescript-eslint/eslint-plugin\": \"5.10.0\",\n    \"@typescript-eslint/parser\": \"5.10.0\",\n    \"benchmark\": \"2.1.4\",\n    \"c8\": \"7.11.2\",\n    \"eslint\": \"8.7.0\",\n    \"eslint-config-prettier\": \"8.3.0\",\n    \"mocha\": \"9.2.0\",\n    \"npm-run-all\": \"4.1.5\",\n    \"prettier\": \"2.5.1\",\n    \"rollup\": \"2.64.0\",\n    \"source-map\": \"0.6.1\",\n    \"source-map-js\": \"1.0.2\",\n    \"sourcemap-codec\": \"1.4.8\",\n    \"typescript\": \"4.5.4\"\n  }\n}\n"
  },
  "externals": []
}
