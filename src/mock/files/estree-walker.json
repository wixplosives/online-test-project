{
  "packageName": "estree-walker",
  "packageVersion": "2.0.2",
  "request": "estree-walker",
  "resolved": "dist/umd/estree-walker.js",
  "files": {
    "dist/umd/estree-walker.js": "(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(global = global || self, factory(global.estreeWalker = {}));\n}(this, (function (exports) { 'use strict';\n\n\t// @ts-check\n\t/** @typedef { import('estree').BaseNode} BaseNode */\n\n\t/** @typedef {{\n\t\tskip: () => void;\n\t\tremove: () => void;\n\t\treplace: (node: BaseNode) => void;\n\t}} WalkerContext */\n\n\tclass WalkerBase {\n\t\tconstructor() {\n\t\t\t/** @type {boolean} */\n\t\t\tthis.should_skip = false;\n\n\t\t\t/** @type {boolean} */\n\t\t\tthis.should_remove = false;\n\n\t\t\t/** @type {BaseNode | null} */\n\t\t\tthis.replacement = null;\n\n\t\t\t/** @type {WalkerContext} */\n\t\t\tthis.context = {\n\t\t\t\tskip: () => (this.should_skip = true),\n\t\t\t\tremove: () => (this.should_remove = true),\n\t\t\t\treplace: (node) => (this.replacement = node)\n\t\t\t};\n\t\t}\n\n\t\t/**\n\t\t *\n\t\t * @param {any} parent\n\t\t * @param {string} prop\n\t\t * @param {number} index\n\t\t * @param {BaseNode} node\n\t\t */\n\t\treplace(parent, prop, index, node) {\n\t\t\tif (parent) {\n\t\t\t\tif (index !== null) {\n\t\t\t\t\tparent[prop][index] = node;\n\t\t\t\t} else {\n\t\t\t\t\tparent[prop] = node;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t *\n\t\t * @param {any} parent\n\t\t * @param {string} prop\n\t\t * @param {number} index\n\t\t */\n\t\tremove(parent, prop, index) {\n\t\t\tif (parent) {\n\t\t\t\tif (index !== null) {\n\t\t\t\t\tparent[prop].splice(index, 1);\n\t\t\t\t} else {\n\t\t\t\t\tdelete parent[prop];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// @ts-check\n\n\t/** @typedef { import('estree').BaseNode} BaseNode */\n\t/** @typedef { import('./walker.js').WalkerContext} WalkerContext */\n\n\t/** @typedef {(\n\t *    this: WalkerContext,\n\t *    node: BaseNode,\n\t *    parent: BaseNode,\n\t *    key: string,\n\t *    index: number\n\t * ) => void} SyncHandler */\n\n\tclass SyncWalker extends WalkerBase {\n\t\t/**\n\t\t *\n\t\t * @param {SyncHandler} enter\n\t\t * @param {SyncHandler} leave\n\t\t */\n\t\tconstructor(enter, leave) {\n\t\t\tsuper();\n\n\t\t\t/** @type {SyncHandler} */\n\t\t\tthis.enter = enter;\n\n\t\t\t/** @type {SyncHandler} */\n\t\t\tthis.leave = leave;\n\t\t}\n\n\t\t/**\n\t\t *\n\t\t * @param {BaseNode} node\n\t\t * @param {BaseNode} parent\n\t\t * @param {string} [prop]\n\t\t * @param {number} [index]\n\t\t * @returns {BaseNode}\n\t\t */\n\t\tvisit(node, parent, prop, index) {\n\t\t\tif (node) {\n\t\t\t\tif (this.enter) {\n\t\t\t\t\tconst _should_skip = this.should_skip;\n\t\t\t\t\tconst _should_remove = this.should_remove;\n\t\t\t\t\tconst _replacement = this.replacement;\n\t\t\t\t\tthis.should_skip = false;\n\t\t\t\t\tthis.should_remove = false;\n\t\t\t\t\tthis.replacement = null;\n\n\t\t\t\t\tthis.enter.call(this.context, node, parent, prop, index);\n\n\t\t\t\t\tif (this.replacement) {\n\t\t\t\t\t\tnode = this.replacement;\n\t\t\t\t\t\tthis.replace(parent, prop, index, node);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.should_remove) {\n\t\t\t\t\t\tthis.remove(parent, prop, index);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst skipped = this.should_skip;\n\t\t\t\t\tconst removed = this.should_remove;\n\n\t\t\t\t\tthis.should_skip = _should_skip;\n\t\t\t\t\tthis.should_remove = _should_remove;\n\t\t\t\t\tthis.replacement = _replacement;\n\n\t\t\t\t\tif (skipped) return node;\n\t\t\t\t\tif (removed) return null;\n\t\t\t\t}\n\n\t\t\t\tfor (const key in node) {\n\t\t\t\t\tconst value = node[key];\n\n\t\t\t\t\tif (typeof value !== \"object\") {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (Array.isArray(value)) {\n\t\t\t\t\t\tfor (let i = 0; i < value.length; i += 1) {\n\t\t\t\t\t\t\tif (value[i] !== null && typeof value[i].type === 'string') {\n\t\t\t\t\t\t\t\tif (!this.visit(value[i], node, key, i)) {\n\t\t\t\t\t\t\t\t\t// removed\n\t\t\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (value !== null && typeof value.type === \"string\") {\n\t\t\t\t\t\tthis.visit(value, node, key, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (this.leave) {\n\t\t\t\t\tconst _replacement = this.replacement;\n\t\t\t\t\tconst _should_remove = this.should_remove;\n\t\t\t\t\tthis.replacement = null;\n\t\t\t\t\tthis.should_remove = false;\n\n\t\t\t\t\tthis.leave.call(this.context, node, parent, prop, index);\n\n\t\t\t\t\tif (this.replacement) {\n\t\t\t\t\t\tnode = this.replacement;\n\t\t\t\t\t\tthis.replace(parent, prop, index, node);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.should_remove) {\n\t\t\t\t\t\tthis.remove(parent, prop, index);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst removed = this.should_remove;\n\n\t\t\t\t\tthis.replacement = _replacement;\n\t\t\t\t\tthis.should_remove = _should_remove;\n\n\t\t\t\t\tif (removed) return null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn node;\n\t\t}\n\t}\n\n\t// @ts-check\n\n\t/** @typedef { import('estree').BaseNode} BaseNode */\n\t/** @typedef { import('./walker').WalkerContext} WalkerContext */\n\n\t/** @typedef {(\n\t *    this: WalkerContext,\n\t *    node: BaseNode,\n\t *    parent: BaseNode,\n\t *    key: string,\n\t *    index: number\n\t * ) => Promise<void>} AsyncHandler */\n\n\tclass AsyncWalker extends WalkerBase {\n\t\t/**\n\t\t *\n\t\t * @param {AsyncHandler} enter\n\t\t * @param {AsyncHandler} leave\n\t\t */\n\t\tconstructor(enter, leave) {\n\t\t\tsuper();\n\n\t\t\t/** @type {AsyncHandler} */\n\t\t\tthis.enter = enter;\n\n\t\t\t/** @type {AsyncHandler} */\n\t\t\tthis.leave = leave;\n\t\t}\n\n\t\t/**\n\t\t *\n\t\t * @param {BaseNode} node\n\t\t * @param {BaseNode} parent\n\t\t * @param {string} [prop]\n\t\t * @param {number} [index]\n\t\t * @returns {Promise<BaseNode>}\n\t\t */\n\t\tasync visit(node, parent, prop, index) {\n\t\t\tif (node) {\n\t\t\t\tif (this.enter) {\n\t\t\t\t\tconst _should_skip = this.should_skip;\n\t\t\t\t\tconst _should_remove = this.should_remove;\n\t\t\t\t\tconst _replacement = this.replacement;\n\t\t\t\t\tthis.should_skip = false;\n\t\t\t\t\tthis.should_remove = false;\n\t\t\t\t\tthis.replacement = null;\n\n\t\t\t\t\tawait this.enter.call(this.context, node, parent, prop, index);\n\n\t\t\t\t\tif (this.replacement) {\n\t\t\t\t\t\tnode = this.replacement;\n\t\t\t\t\t\tthis.replace(parent, prop, index, node);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.should_remove) {\n\t\t\t\t\t\tthis.remove(parent, prop, index);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst skipped = this.should_skip;\n\t\t\t\t\tconst removed = this.should_remove;\n\n\t\t\t\t\tthis.should_skip = _should_skip;\n\t\t\t\t\tthis.should_remove = _should_remove;\n\t\t\t\t\tthis.replacement = _replacement;\n\n\t\t\t\t\tif (skipped) return node;\n\t\t\t\t\tif (removed) return null;\n\t\t\t\t}\n\n\t\t\t\tfor (const key in node) {\n\t\t\t\t\tconst value = node[key];\n\n\t\t\t\t\tif (typeof value !== \"object\") {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (Array.isArray(value)) {\n\t\t\t\t\t\tfor (let i = 0; i < value.length; i += 1) {\n\t\t\t\t\t\t\tif (value[i] !== null && typeof value[i].type === 'string') {\n\t\t\t\t\t\t\t\tif (!(await this.visit(value[i], node, key, i))) {\n\t\t\t\t\t\t\t\t\t// removed\n\t\t\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (value !== null && typeof value.type === \"string\") {\n\t\t\t\t\t\tawait this.visit(value, node, key, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (this.leave) {\n\t\t\t\t\tconst _replacement = this.replacement;\n\t\t\t\t\tconst _should_remove = this.should_remove;\n\t\t\t\t\tthis.replacement = null;\n\t\t\t\t\tthis.should_remove = false;\n\n\t\t\t\t\tawait this.leave.call(this.context, node, parent, prop, index);\n\n\t\t\t\t\tif (this.replacement) {\n\t\t\t\t\t\tnode = this.replacement;\n\t\t\t\t\t\tthis.replace(parent, prop, index, node);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.should_remove) {\n\t\t\t\t\t\tthis.remove(parent, prop, index);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst removed = this.should_remove;\n\n\t\t\t\t\tthis.replacement = _replacement;\n\t\t\t\t\tthis.should_remove = _should_remove;\n\n\t\t\t\t\tif (removed) return null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn node;\n\t\t}\n\t}\n\n\t// @ts-check\n\n\t/** @typedef { import('estree').BaseNode} BaseNode */\n\t/** @typedef { import('./sync.js').SyncHandler} SyncHandler */\n\t/** @typedef { import('./async.js').AsyncHandler} AsyncHandler */\n\n\t/**\n\t *\n\t * @param {BaseNode} ast\n\t * @param {{\n\t *   enter?: SyncHandler\n\t *   leave?: SyncHandler\n\t * }} walker\n\t * @returns {BaseNode}\n\t */\n\tfunction walk(ast, { enter, leave }) {\n\t\tconst instance = new SyncWalker(enter, leave);\n\t\treturn instance.visit(ast, null);\n\t}\n\n\t/**\n\t *\n\t * @param {BaseNode} ast\n\t * @param {{\n\t *   enter?: AsyncHandler\n\t *   leave?: AsyncHandler\n\t * }} walker\n\t * @returns {Promise<BaseNode>}\n\t */\n\tasync function asyncWalk(ast, { enter, leave }) {\n\t\tconst instance = new AsyncWalker(enter, leave);\n\t\treturn await instance.visit(ast, null);\n\t}\n\n\texports.asyncWalk = asyncWalk;\n\texports.walk = walk;\n\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n",
    "package.json": "{\n  \"name\": \"estree-walker\",\n  \"description\": \"Traverse an ESTree-compliant AST\",\n  \"version\": \"2.0.2\",\n  \"private\": false,\n  \"author\": \"Rich Harris\",\n  \"license\": \"MIT\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/Rich-Harris/estree-walker\"\n  },\n  \"type\": \"commonjs\",\n  \"main\": \"./dist/umd/estree-walker.js\",\n  \"module\": \"./dist/esm/estree-walker.js\",\n  \"exports\": {\n    \"require\": \"./dist/umd/estree-walker.js\",\n    \"import\": \"./dist/esm/estree-walker.js\"\n  },\n  \"types\": \"types/index.d.ts\",\n  \"scripts\": {\n    \"prepublishOnly\": \"npm run build && npm test\",\n    \"build\": \"tsc && rollup -c\",\n    \"test\": \"uvu test\"\n  },\n  \"devDependencies\": {\n    \"@types/estree\": \"0.0.42\",\n    \"rollup\": \"^2.10.9\",\n    \"typescript\": \"^3.7.5\",\n    \"uvu\": \"^0.5.1\"\n  },\n  \"files\": [\n    \"src\",\n    \"dist\",\n    \"types\",\n    \"README.md\"\n  ]\n}\n"
  },
  "externals": []
}
