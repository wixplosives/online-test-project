{
  "packageName": "@vitejs/plugin-react",
  "packageVersion": "4.1.1",
  "request": "@vitejs/plugin-react",
  "resolved": "dist/index.mjs",
  "files": {
    "dist/index.mjs": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = void 0;\nconst vite_1 = require(\"vite\");\nconst node_fs_1 = __importDefault(require(\"node:fs\"));\nconst node_path_1 = __importDefault(require(\"node:path\"));\nconst node_module_1 = require(\"node:module\");\nconst runtimePublicPath = \"/@react-refresh\";\nconst _require = (0, node_module_1.createRequire)(import.meta.url);\nconst reactRefreshDir = node_path_1.default.dirname(_require.resolve(\"react-refresh/package.json\"));\nconst runtimeFilePath = node_path_1.default.join(reactRefreshDir, \"cjs/react-refresh-runtime.development.js\");\nconst runtimeCode = `\nconst exports = {}\n${node_fs_1.default.readFileSync(runtimeFilePath, \"utf-8\")}\n${node_fs_1.default.readFileSync(_require.resolve(\"./refreshUtils.js\"), \"utf-8\")}\nexport default exports\n`;\nconst preambleCode = `\nimport RefreshRuntime from \"__BASE__${runtimePublicPath.slice(1)}\"\nRefreshRuntime.injectIntoGlobalHook(window)\nwindow.$RefreshReg$ = () => {}\nwindow.$RefreshSig$ = () => (type) => type\nwindow.__vite_plugin_react_preamble_installed__ = true\n`;\nconst header = `\nimport RefreshRuntime from \"${runtimePublicPath}\";\n\nconst inWebWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;\nlet prevRefreshReg;\nlet prevRefreshSig;\n\nif (import.meta.hot && !inWebWorker) {\n  if (!window.__vite_plugin_react_preamble_installed__) {\n    throw new Error(\n      \"@vitejs/plugin-react can't detect preamble. Something is wrong. \" +\n      \"See https://github.com/vitejs/vite-plugin-react/pull/11#discussion_r430879201\"\n    );\n  }\n\n  prevRefreshReg = window.$RefreshReg$;\n  prevRefreshSig = window.$RefreshSig$;\n  window.$RefreshReg$ = (type, id) => {\n    RefreshRuntime.register(type, __SOURCE__ + \" \" + id)\n  };\n  window.$RefreshSig$ = RefreshRuntime.createSignatureFunctionForTransform;\n}`.replace(/\\n+/g, \"\");\nconst footer = `\nif (import.meta.hot && !inWebWorker) {\n  window.$RefreshReg$ = prevRefreshReg;\n  window.$RefreshSig$ = prevRefreshSig;\n\n  RefreshRuntime.__hmr_import(import.meta.url).then((currentExports) => {\n    RefreshRuntime.registerExportsForReactRefresh(__SOURCE__, currentExports);\n    import.meta.hot.accept((nextExports) => {\n      if (!nextExports) return;\n      const invalidateMessage = RefreshRuntime.validateRefreshBoundaryAndEnqueueUpdate(currentExports, nextExports);\n      if (invalidateMessage) import.meta.hot.invalidate(invalidateMessage);\n    });\n  });\n}`;\nfunction addRefreshWrapper(code, id) {\n    return header.replace(\"__SOURCE__\", JSON.stringify(id)) + code + footer.replace(\"__SOURCE__\", JSON.stringify(id));\n}\nlet babel;\nasync function loadBabel() {\n    if (!babel) {\n        babel = await Promise.resolve().then(() => __importStar(require('@babel/core')));\n    }\n    return babel;\n}\nconst refreshContentRE = /\\$Refresh(?:Reg|Sig)\\$\\(/;\nconst defaultIncludeRE = /\\.[tj]sx?$/;\nconst tsRE = /\\.tsx?$/;\nfunction viteReact(opts = {}) {\n    let devBase = \"/\";\n    const filter = (0, vite_1.createFilter)(opts.include ?? defaultIncludeRE, opts.exclude);\n    const jsxImportSource = opts.jsxImportSource ?? \"react\";\n    const jsxImportRuntime = `${jsxImportSource}/jsx-runtime`;\n    const jsxImportDevRuntime = `${jsxImportSource}/jsx-dev-runtime`;\n    let isProduction = true;\n    let projectRoot = process.cwd();\n    let skipFastRefresh = false;\n    let runPluginOverrides;\n    let staticBabelOptions;\n    const importReactRE = /(?:^|\\s)import\\s+(?:\\*\\s+as\\s+)?React(?:,|\\s+)/;\n    const viteBabel = {\n        name: \"vite:react-babel\",\n        enforce: \"pre\",\n        config() {\n            if (opts.jsxRuntime === \"classic\") {\n                return {\n                    esbuild: {\n                        jsx: \"transform\"\n                    }\n                };\n            }\n            else {\n                return {\n                    esbuild: {\n                        jsx: \"automatic\",\n                        jsxImportSource: opts.jsxImportSource\n                    }\n                };\n            }\n        },\n        configResolved(config) {\n            devBase = config.base;\n            projectRoot = config.root;\n            isProduction = config.isProduction;\n            skipFastRefresh = isProduction || config.command === \"build\" || config.server.hmr === false;\n            if (\"jsxPure\" in opts) {\n                config.logger.warnOnce(\"[@vitejs/plugin-react] jsxPure was removed. You can configure esbuild.jsxSideEffects directly.\");\n            }\n            const hooks = config.plugins.map((plugin) => plugin.api?.reactBabel).filter(defined);\n            if (hooks.length > 0) {\n                runPluginOverrides = (babelOptions, context) => {\n                    hooks.forEach((hook) => hook(babelOptions, context, config));\n                };\n            }\n            else if (typeof opts.babel !== \"function\") {\n                staticBabelOptions = createBabelOptions(opts.babel);\n            }\n        },\n        async transform(code, id, options) {\n            if (id.includes(\"/node_modules/\"))\n                return;\n            const [filepath] = id.split(\"?\");\n            if (!filter(filepath))\n                return;\n            const ssr = options?.ssr === true;\n            const babelOptions = (() => {\n                if (staticBabelOptions)\n                    return staticBabelOptions;\n                const newBabelOptions = createBabelOptions(typeof opts.babel === \"function\" ? opts.babel(id, { ssr }) : opts.babel);\n                runPluginOverrides?.(newBabelOptions, { id, ssr });\n                return newBabelOptions;\n            })();\n            const plugins = [...babelOptions.plugins];\n            const isJSX = filepath.endsWith(\"x\");\n            const useFastRefresh = !skipFastRefresh && !ssr && (isJSX || (opts.jsxRuntime === \"classic\" ? importReactRE.test(code) : code.includes(jsxImportDevRuntime) || code.includes(jsxImportRuntime)));\n            if (useFastRefresh) {\n                plugins.push([\n                    await loadPlugin(\"react-refresh/babel\"),\n                    { skipEnvCheck: true }\n                ]);\n            }\n            if (opts.jsxRuntime === \"classic\" && isJSX) {\n                if (!isProduction) {\n                    plugins.push(await loadPlugin(\"@babel/plugin-transform-react-jsx-self\"), await loadPlugin(\"@babel/plugin-transform-react-jsx-source\"));\n                }\n            }\n            if (!plugins.length && !babelOptions.presets.length && !babelOptions.configFile && !babelOptions.babelrc) {\n                return;\n            }\n            const parserPlugins = [...babelOptions.parserOpts.plugins];\n            if (!filepath.endsWith(\".ts\")) {\n                parserPlugins.push(\"jsx\");\n            }\n            if (tsRE.test(filepath)) {\n                parserPlugins.push(\"typescript\");\n            }\n            const babel2 = await loadBabel();\n            const result = await babel2.transformAsync(code, {\n                ...babelOptions,\n                root: projectRoot,\n                filename: id,\n                sourceFileName: filepath,\n                // Required for esbuild.jsxDev to provide correct line numbers\n                retainLines: !isProduction && isJSX && opts.jsxRuntime !== \"classic\",\n                parserOpts: {\n                    ...babelOptions.parserOpts,\n                    sourceType: \"module\",\n                    allowAwaitOutsideFunction: true,\n                    plugins: parserPlugins\n                },\n                generatorOpts: {\n                    ...babelOptions.generatorOpts,\n                    decoratorsBeforeExport: true\n                },\n                plugins,\n                sourceMaps: true\n            });\n            if (result) {\n                let code2 = result.code;\n                if (useFastRefresh && refreshContentRE.test(code2)) {\n                    code2 = addRefreshWrapper(code2, id);\n                }\n                return { code: code2, map: result.map };\n            }\n        }\n    };\n    const viteReactRefresh = {\n        name: \"vite:react-refresh\",\n        enforce: \"pre\",\n        config: (userConfig) => ({\n            build: silenceUseClientWarning(userConfig),\n            optimizeDeps: {\n                // We can't add `react-dom` because the dependency is `react-dom/client`\n                // for React 18 while it's `react-dom` for React 17. We'd need to detect\n                // what React version the user has installed.\n                include: [\"react\", jsxImportDevRuntime, jsxImportRuntime]\n            },\n            resolve: {\n                dedupe: [\"react\", \"react-dom\"]\n            }\n        }),\n        resolveId(id) {\n            if (id === runtimePublicPath) {\n                return id;\n            }\n        },\n        load(id) {\n            if (id === runtimePublicPath) {\n                return runtimeCode;\n            }\n        },\n        transformIndexHtml() {\n            if (!skipFastRefresh)\n                return [\n                    {\n                        tag: \"script\",\n                        attrs: { type: \"module\" },\n                        children: preambleCode.replace(`__BASE__`, devBase)\n                    }\n                ];\n        }\n    };\n    return [viteBabel, viteReactRefresh];\n}\nexports.default = viteReact;\nviteReact.preambleCode = preambleCode;\nconst silenceUseClientWarning = (userConfig) => ({\n    rollupOptions: {\n        onwarn(warning, defaultHandler) {\n            if (warning.code === \"MODULE_LEVEL_DIRECTIVE\" && warning.message.includes(\"use client\")) {\n                return;\n            }\n            if (userConfig.build?.rollupOptions?.onwarn) {\n                userConfig.build.rollupOptions.onwarn(warning, defaultHandler);\n            }\n            else {\n                defaultHandler(warning);\n            }\n        }\n    }\n});\nconst loadedPlugin = /* @__PURE__ */ new Map();\nfunction loadPlugin(path) {\n    const cached = loadedPlugin.get(path);\n    if (cached)\n        return cached;\n    const promise = Promise.resolve(`${path}`).then(s => __importStar(require(s))).then((module) => {\n        const value = module.default || module;\n        loadedPlugin.set(path, value);\n        return value;\n    });\n    loadedPlugin.set(path, promise);\n    return promise;\n}\nfunction createBabelOptions(rawOptions) {\n    var _a;\n    const babelOptions = {\n        babelrc: false,\n        configFile: false,\n        ...rawOptions\n    };\n    babelOptions.plugins || (babelOptions.plugins = []);\n    babelOptions.presets || (babelOptions.presets = []);\n    babelOptions.overrides || (babelOptions.overrides = []);\n    babelOptions.parserOpts || (babelOptions.parserOpts = {});\n    (_a = babelOptions.parserOpts).plugins || (_a.plugins = []);\n    return babelOptions;\n}\nfunction defined(value) {\n    return value !== void 0;\n}\n",
    "package.json": "{\n  \"name\": \"@vitejs/plugin-react\",\n  \"version\": \"4.1.1\",\n  \"license\": \"MIT\",\n  \"author\": \"Evan You\",\n  \"contributors\": [\n    \"Alec Larson\",\n    \"Arnaud Barré\"\n  ],\n  \"files\": [\n    \"dist\"\n  ],\n  \"main\": \"./dist/index.cjs\",\n  \"module\": \"./dist/index.mjs\",\n  \"types\": \"./dist/index.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"import\": \"./dist/index.mjs\",\n      \"require\": \"./dist/index.cjs\"\n    }\n  },\n  \"scripts\": {\n    \"dev\": \"unbuild --stub\",\n    \"build\": \"unbuild && pnpm run patch-cjs && tsx scripts/copyRefreshUtils.ts\",\n    \"patch-cjs\": \"tsx ../../scripts/patchCJS.ts\",\n    \"prepublishOnly\": \"npm run build\"\n  },\n  \"engines\": {\n    \"node\": \"^14.18.0 || >=16.0.0\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/vitejs/vite-plugin-react.git\",\n    \"directory\": \"packages/plugin-react\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/vitejs/vite-plugin-react/issues\"\n  },\n  \"homepage\": \"https://github.com/vitejs/vite-plugin-react/tree/main/packages/plugin-react#readme\",\n  \"dependencies\": {\n    \"@babel/core\": \"^7.23.2\",\n    \"@babel/plugin-transform-react-jsx-self\": \"^7.22.5\",\n    \"@babel/plugin-transform-react-jsx-source\": \"^7.22.5\",\n    \"@types/babel__core\": \"^7.20.3\",\n    \"react-refresh\": \"^0.14.0\"\n  },\n  \"peerDependencies\": {\n    \"vite\": \"^4.2.0\"\n  }\n}\n"
  },
  "externals": [
    "vite",
    "node:fs",
    "node:path",
    "node:module",
    "@babel/core"
  ]
}
