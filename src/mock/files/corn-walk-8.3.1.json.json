{
  "packageName": "acorn-walk",
  "packageVersion": "8.3.1",
  "request": "acorn-walk",
  "resolved": "dist/walk.mjs",
  "files": {
    "dist/walk.mjs": "\"use strict\";\n// AST walker module for ESTree compatible trees\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.simple = exports.recursive = exports.make = exports.fullAncestor = exports.full = exports.findNodeBefore = exports.findNodeAt = exports.findNodeAround = exports.findNodeAfter = exports.base = exports.ancestor = void 0;\n// A simple walk is one where you simply specify callbacks to be\n// called on specific nodes. The last two arguments are optional. A\n// simple use would be\n//\n//     walk.simple(myTree, {\n//         Expression: function(node) { ... }\n//     });\n//\n// to do something with all expressions. All ESTree node types\n// can be used to identify node types, as well as Expression and\n// Statement, which denote categories of nodes.\n//\n// The base argument can be used to pass a custom (recursive)\n// walker, and state can be used to give this walked an initial\n// state.\nfunction simple(node, visitors, baseVisitor, state, override) {\n    if (!baseVisitor) {\n        baseVisitor = base;\n    }\n    (function c(node, st, override) {\n        var type = override || node.type;\n        baseVisitor[type](node, st, c);\n        if (visitors[type]) {\n            visitors[type](node, st);\n        }\n    })(node, state, override);\n}\nexports.simple = simple;\n// An ancestor walk keeps an array of ancestor nodes (including the\n// current node) and passes them to the callback as third parameter\n// (and also as state parameter when no other state is present).\nfunction ancestor(node, visitors, baseVisitor, state, override) {\n    var ancestors = [];\n    if (!baseVisitor) {\n        baseVisitor = base;\n    }\n    (function c(node, st, override) {\n        var type = override || node.type;\n        var isNew = node !== ancestors[ancestors.length - 1];\n        if (isNew) {\n            ancestors.push(node);\n        }\n        baseVisitor[type](node, st, c);\n        if (visitors[type]) {\n            visitors[type](node, st || ancestors, ancestors);\n        }\n        if (isNew) {\n            ancestors.pop();\n        }\n    })(node, state, override);\n}\nexports.ancestor = ancestor;\n// A recursive walk is one where your functions override the default\n// walkers. They can modify and replace the state parameter that's\n// threaded through the walk, and can opt how and whether to walk\n// their child nodes (by calling their third argument on these\n// nodes).\nfunction recursive(node, state, funcs, baseVisitor, override) {\n    var visitor = funcs ? make(funcs, baseVisitor || undefined) : baseVisitor;\n    (function c(node, st, override) {\n        visitor[override || node.type](node, st, c);\n    })(node, state, override);\n}\nexports.recursive = recursive;\nfunction makeTest(test) {\n    if (typeof test === \"string\") {\n        return function (type) { return type === test; };\n    }\n    else if (!test) {\n        return function () { return true; };\n    }\n    else {\n        return test;\n    }\n}\nvar Found = function Found(node, state) { this.node = node; this.state = state; };\n// A full walk triggers the callback on each node\nfunction full(node, callback, baseVisitor, state, override) {\n    if (!baseVisitor) {\n        baseVisitor = base;\n    }\n    var last;\n    (function c(node, st, override) {\n        var type = override || node.type;\n        baseVisitor[type](node, st, c);\n        if (last !== node) {\n            callback(node, st, type);\n            last = node;\n        }\n    })(node, state, override);\n}\nexports.full = full;\n// An fullAncestor walk is like an ancestor walk, but triggers\n// the callback on each node\nfunction fullAncestor(node, callback, baseVisitor, state) {\n    if (!baseVisitor) {\n        baseVisitor = base;\n    }\n    var ancestors = [], last;\n    (function c(node, st, override) {\n        var type = override || node.type;\n        var isNew = node !== ancestors[ancestors.length - 1];\n        if (isNew) {\n            ancestors.push(node);\n        }\n        baseVisitor[type](node, st, c);\n        if (last !== node) {\n            callback(node, st || ancestors, ancestors, type);\n            last = node;\n        }\n        if (isNew) {\n            ancestors.pop();\n        }\n    })(node, state);\n}\nexports.fullAncestor = fullAncestor;\n// Find a node with a given start, end, and type (all are optional,\n// null can be used as wildcard). Returns a {node, state} object, or\n// undefined when it doesn't find a matching node.\nfunction findNodeAt(node, start, end, test, baseVisitor, state) {\n    if (!baseVisitor) {\n        baseVisitor = base;\n    }\n    test = makeTest(test);\n    try {\n        (function c(node, st, override) {\n            var type = override || node.type;\n            if ((start == null || node.start <= start) &&\n                (end == null || node.end >= end)) {\n                baseVisitor[type](node, st, c);\n            }\n            if ((start == null || node.start === start) &&\n                (end == null || node.end === end) &&\n                test(type, node)) {\n                throw new Found(node, st);\n            }\n        })(node, state);\n    }\n    catch (e) {\n        if (e instanceof Found) {\n            return e;\n        }\n        throw e;\n    }\n}\nexports.findNodeAt = findNodeAt;\n// Find the innermost node of a given type that contains the given\n// position. Interface similar to findNodeAt.\nfunction findNodeAround(node, pos, test, baseVisitor, state) {\n    test = makeTest(test);\n    if (!baseVisitor) {\n        baseVisitor = base;\n    }\n    try {\n        (function c(node, st, override) {\n            var type = override || node.type;\n            if (node.start > pos || node.end < pos) {\n                return;\n            }\n            baseVisitor[type](node, st, c);\n            if (test(type, node)) {\n                throw new Found(node, st);\n            }\n        })(node, state);\n    }\n    catch (e) {\n        if (e instanceof Found) {\n            return e;\n        }\n        throw e;\n    }\n}\nexports.findNodeAround = findNodeAround;\n// Find the outermost matching node after a given position.\nfunction findNodeAfter(node, pos, test, baseVisitor, state) {\n    test = makeTest(test);\n    if (!baseVisitor) {\n        baseVisitor = base;\n    }\n    try {\n        (function c(node, st, override) {\n            if (node.end < pos) {\n                return;\n            }\n            var type = override || node.type;\n            if (node.start >= pos && test(type, node)) {\n                throw new Found(node, st);\n            }\n            baseVisitor[type](node, st, c);\n        })(node, state);\n    }\n    catch (e) {\n        if (e instanceof Found) {\n            return e;\n        }\n        throw e;\n    }\n}\nexports.findNodeAfter = findNodeAfter;\n// Find the outermost matching node before a given position.\nfunction findNodeBefore(node, pos, test, baseVisitor, state) {\n    test = makeTest(test);\n    if (!baseVisitor) {\n        baseVisitor = base;\n    }\n    var max;\n    (function c(node, st, override) {\n        if (node.start > pos) {\n            return;\n        }\n        var type = override || node.type;\n        if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node)) {\n            max = new Found(node, st);\n        }\n        baseVisitor[type](node, st, c);\n    })(node, state);\n    return max;\n}\nexports.findNodeBefore = findNodeBefore;\n// Used to create a custom walker. Will fill in all missing node\n// type properties with the defaults.\nfunction make(funcs, baseVisitor) {\n    var visitor = Object.create(baseVisitor || base);\n    for (var type in funcs) {\n        visitor[type] = funcs[type];\n    }\n    return visitor;\n}\nexports.make = make;\nfunction skipThrough(node, st, c) { c(node, st); }\nfunction ignore(_node, _st, _c) { }\n// Node walkers.\nvar base = {};\nexports.base = base;\nbase.Program = base.BlockStatement = base.StaticBlock = function (node, st, c) {\n    for (var i = 0, list = node.body; i < list.length; i += 1) {\n        var stmt = list[i];\n        c(stmt, st, \"Statement\");\n    }\n};\nbase.Statement = skipThrough;\nbase.EmptyStatement = ignore;\nbase.ExpressionStatement = base.ParenthesizedExpression = base.ChainExpression =\n    function (node, st, c) { return c(node.expression, st, \"Expression\"); };\nbase.IfStatement = function (node, st, c) {\n    c(node.test, st, \"Expression\");\n    c(node.consequent, st, \"Statement\");\n    if (node.alternate) {\n        c(node.alternate, st, \"Statement\");\n    }\n};\nbase.LabeledStatement = function (node, st, c) { return c(node.body, st, \"Statement\"); };\nbase.BreakStatement = base.ContinueStatement = ignore;\nbase.WithStatement = function (node, st, c) {\n    c(node.object, st, \"Expression\");\n    c(node.body, st, \"Statement\");\n};\nbase.SwitchStatement = function (node, st, c) {\n    c(node.discriminant, st, \"Expression\");\n    for (var i$1 = 0, list$1 = node.cases; i$1 < list$1.length; i$1 += 1) {\n        var cs = list$1[i$1];\n        if (cs.test) {\n            c(cs.test, st, \"Expression\");\n        }\n        for (var i = 0, list = cs.consequent; i < list.length; i += 1) {\n            var cons = list[i];\n            c(cons, st, \"Statement\");\n        }\n    }\n};\nbase.SwitchCase = function (node, st, c) {\n    if (node.test) {\n        c(node.test, st, \"Expression\");\n    }\n    for (var i = 0, list = node.consequent; i < list.length; i += 1) {\n        var cons = list[i];\n        c(cons, st, \"Statement\");\n    }\n};\nbase.ReturnStatement = base.YieldExpression = base.AwaitExpression = function (node, st, c) {\n    if (node.argument) {\n        c(node.argument, st, \"Expression\");\n    }\n};\nbase.ThrowStatement = base.SpreadElement =\n    function (node, st, c) { return c(node.argument, st, \"Expression\"); };\nbase.TryStatement = function (node, st, c) {\n    c(node.block, st, \"Statement\");\n    if (node.handler) {\n        c(node.handler, st);\n    }\n    if (node.finalizer) {\n        c(node.finalizer, st, \"Statement\");\n    }\n};\nbase.CatchClause = function (node, st, c) {\n    if (node.param) {\n        c(node.param, st, \"Pattern\");\n    }\n    c(node.body, st, \"Statement\");\n};\nbase.WhileStatement = base.DoWhileStatement = function (node, st, c) {\n    c(node.test, st, \"Expression\");\n    c(node.body, st, \"Statement\");\n};\nbase.ForStatement = function (node, st, c) {\n    if (node.init) {\n        c(node.init, st, \"ForInit\");\n    }\n    if (node.test) {\n        c(node.test, st, \"Expression\");\n    }\n    if (node.update) {\n        c(node.update, st, \"Expression\");\n    }\n    c(node.body, st, \"Statement\");\n};\nbase.ForInStatement = base.ForOfStatement = function (node, st, c) {\n    c(node.left, st, \"ForInit\");\n    c(node.right, st, \"Expression\");\n    c(node.body, st, \"Statement\");\n};\nbase.ForInit = function (node, st, c) {\n    if (node.type === \"VariableDeclaration\") {\n        c(node, st);\n    }\n    else {\n        c(node, st, \"Expression\");\n    }\n};\nbase.DebuggerStatement = ignore;\nbase.FunctionDeclaration = function (node, st, c) { return c(node, st, \"Function\"); };\nbase.VariableDeclaration = function (node, st, c) {\n    for (var i = 0, list = node.declarations; i < list.length; i += 1) {\n        var decl = list[i];\n        c(decl, st);\n    }\n};\nbase.VariableDeclarator = function (node, st, c) {\n    c(node.id, st, \"Pattern\");\n    if (node.init) {\n        c(node.init, st, \"Expression\");\n    }\n};\nbase.Function = function (node, st, c) {\n    if (node.id) {\n        c(node.id, st, \"Pattern\");\n    }\n    for (var i = 0, list = node.params; i < list.length; i += 1) {\n        var param = list[i];\n        c(param, st, \"Pattern\");\n    }\n    c(node.body, st, node.expression ? \"Expression\" : \"Statement\");\n};\nbase.Pattern = function (node, st, c) {\n    if (node.type === \"Identifier\") {\n        c(node, st, \"VariablePattern\");\n    }\n    else if (node.type === \"MemberExpression\") {\n        c(node, st, \"MemberPattern\");\n    }\n    else {\n        c(node, st);\n    }\n};\nbase.VariablePattern = ignore;\nbase.MemberPattern = skipThrough;\nbase.RestElement = function (node, st, c) { return c(node.argument, st, \"Pattern\"); };\nbase.ArrayPattern = function (node, st, c) {\n    for (var i = 0, list = node.elements; i < list.length; i += 1) {\n        var elt = list[i];\n        if (elt) {\n            c(elt, st, \"Pattern\");\n        }\n    }\n};\nbase.ObjectPattern = function (node, st, c) {\n    for (var i = 0, list = node.properties; i < list.length; i += 1) {\n        var prop = list[i];\n        if (prop.type === \"Property\") {\n            if (prop.computed) {\n                c(prop.key, st, \"Expression\");\n            }\n            c(prop.value, st, \"Pattern\");\n        }\n        else if (prop.type === \"RestElement\") {\n            c(prop.argument, st, \"Pattern\");\n        }\n    }\n};\nbase.Expression = skipThrough;\nbase.ThisExpression = base.Super = base.MetaProperty = ignore;\nbase.ArrayExpression = function (node, st, c) {\n    for (var i = 0, list = node.elements; i < list.length; i += 1) {\n        var elt = list[i];\n        if (elt) {\n            c(elt, st, \"Expression\");\n        }\n    }\n};\nbase.ObjectExpression = function (node, st, c) {\n    for (var i = 0, list = node.properties; i < list.length; i += 1) {\n        var prop = list[i];\n        c(prop, st);\n    }\n};\nbase.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;\nbase.SequenceExpression = function (node, st, c) {\n    for (var i = 0, list = node.expressions; i < list.length; i += 1) {\n        var expr = list[i];\n        c(expr, st, \"Expression\");\n    }\n};\nbase.TemplateLiteral = function (node, st, c) {\n    for (var i = 0, list = node.quasis; i < list.length; i += 1) {\n        var quasi = list[i];\n        c(quasi, st);\n    }\n    for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1) {\n        var expr = list$1[i$1];\n        c(expr, st, \"Expression\");\n    }\n};\nbase.TemplateElement = ignore;\nbase.UnaryExpression = base.UpdateExpression = function (node, st, c) {\n    c(node.argument, st, \"Expression\");\n};\nbase.BinaryExpression = base.LogicalExpression = function (node, st, c) {\n    c(node.left, st, \"Expression\");\n    c(node.right, st, \"Expression\");\n};\nbase.AssignmentExpression = base.AssignmentPattern = function (node, st, c) {\n    c(node.left, st, \"Pattern\");\n    c(node.right, st, \"Expression\");\n};\nbase.ConditionalExpression = function (node, st, c) {\n    c(node.test, st, \"Expression\");\n    c(node.consequent, st, \"Expression\");\n    c(node.alternate, st, \"Expression\");\n};\nbase.NewExpression = base.CallExpression = function (node, st, c) {\n    c(node.callee, st, \"Expression\");\n    if (node.arguments) {\n        for (var i = 0, list = node.arguments; i < list.length; i += 1) {\n            var arg = list[i];\n            c(arg, st, \"Expression\");\n        }\n    }\n};\nbase.MemberExpression = function (node, st, c) {\n    c(node.object, st, \"Expression\");\n    if (node.computed) {\n        c(node.property, st, \"Expression\");\n    }\n};\nbase.ExportNamedDeclaration = base.ExportDefaultDeclaration = function (node, st, c) {\n    if (node.declaration) {\n        c(node.declaration, st, node.type === \"ExportNamedDeclaration\" || node.declaration.id ? \"Statement\" : \"Expression\");\n    }\n    if (node.source) {\n        c(node.source, st, \"Expression\");\n    }\n};\nbase.ExportAllDeclaration = function (node, st, c) {\n    if (node.exported) {\n        c(node.exported, st);\n    }\n    c(node.source, st, \"Expression\");\n};\nbase.ImportDeclaration = function (node, st, c) {\n    for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n        var spec = list[i];\n        c(spec, st);\n    }\n    c(node.source, st, \"Expression\");\n};\nbase.ImportExpression = function (node, st, c) {\n    c(node.source, st, \"Expression\");\n};\nbase.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.PrivateIdentifier = base.Literal = ignore;\nbase.TaggedTemplateExpression = function (node, st, c) {\n    c(node.tag, st, \"Expression\");\n    c(node.quasi, st, \"Expression\");\n};\nbase.ClassDeclaration = base.ClassExpression = function (node, st, c) { return c(node, st, \"Class\"); };\nbase.Class = function (node, st, c) {\n    if (node.id) {\n        c(node.id, st, \"Pattern\");\n    }\n    if (node.superClass) {\n        c(node.superClass, st, \"Expression\");\n    }\n    c(node.body, st);\n};\nbase.ClassBody = function (node, st, c) {\n    for (var i = 0, list = node.body; i < list.length; i += 1) {\n        var elt = list[i];\n        c(elt, st);\n    }\n};\nbase.MethodDefinition = base.PropertyDefinition = base.Property = function (node, st, c) {\n    if (node.computed) {\n        c(node.key, st, \"Expression\");\n    }\n    if (node.value) {\n        c(node.value, st, \"Expression\");\n    }\n};\n",
    "package.json": "{\n  \"name\": \"acorn-walk\",\n  \"description\": \"ECMAScript (ESTree) AST walker\",\n  \"homepage\": \"https://github.com/acornjs/acorn\",\n  \"main\": \"dist/walk.js\",\n  \"types\": \"dist/walk.d.ts\",\n  \"module\": \"dist/walk.mjs\",\n  \"exports\": {\n    \".\": [\n      {\n        \"import\": \"./dist/walk.mjs\",\n        \"require\": \"./dist/walk.js\",\n        \"default\": \"./dist/walk.js\"\n      },\n      \"./dist/walk.js\"\n    ],\n    \"./package.json\": \"./package.json\"\n  },\n  \"version\": \"8.3.1\",\n  \"engines\": {\n    \"node\": \">=0.4.0\"\n  },\n  \"maintainers\": [\n    {\n      \"name\": \"Marijn Haverbeke\",\n      \"email\": \"marijnh@gmail.com\",\n      \"web\": \"https://marijnhaverbeke.nl\"\n    },\n    {\n      \"name\": \"Ingvar Stepanyan\",\n      \"email\": \"me@rreverser.com\",\n      \"web\": \"https://rreverser.com/\"\n    },\n    {\n      \"name\": \"Adrian Heine\",\n      \"web\": \"http://adrianheine.de\"\n    }\n  ],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/acornjs/acorn.git\"\n  },\n  \"scripts\": {\n    \"prepare\": \"cd ..; npm run build:walk\"\n  },\n  \"license\": \"MIT\"\n}\n"
  },
  "externals": []
}
