{
  "packageName": "@babel/core",
  "packageVersion": "7.23.2",
  "request": "@babel/core",
  "resolved": "lib/index.js",
  "files": {
    "lib/index.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DEFAULT_EXTENSIONS = void 0;\nObject.defineProperty(exports, \"File\", {\n  enumerable: true,\n  get: function () {\n    return _file.default;\n  }\n});\nObject.defineProperty(exports, \"buildExternalHelpers\", {\n  enumerable: true,\n  get: function () {\n    return _buildExternalHelpers.default;\n  }\n});\nObject.defineProperty(exports, \"createConfigItem\", {\n  enumerable: true,\n  get: function () {\n    return _index2.createConfigItem;\n  }\n});\nObject.defineProperty(exports, \"createConfigItemAsync\", {\n  enumerable: true,\n  get: function () {\n    return _index2.createConfigItemAsync;\n  }\n});\nObject.defineProperty(exports, \"createConfigItemSync\", {\n  enumerable: true,\n  get: function () {\n    return _index2.createConfigItemSync;\n  }\n});\nObject.defineProperty(exports, \"getEnv\", {\n  enumerable: true,\n  get: function () {\n    return _environment.getEnv;\n  }\n});\nObject.defineProperty(exports, \"loadOptions\", {\n  enumerable: true,\n  get: function () {\n    return _index2.loadOptions;\n  }\n});\nObject.defineProperty(exports, \"loadOptionsAsync\", {\n  enumerable: true,\n  get: function () {\n    return _index2.loadOptionsAsync;\n  }\n});\nObject.defineProperty(exports, \"loadOptionsSync\", {\n  enumerable: true,\n  get: function () {\n    return _index2.loadOptionsSync;\n  }\n});\nObject.defineProperty(exports, \"loadPartialConfig\", {\n  enumerable: true,\n  get: function () {\n    return _index2.loadPartialConfig;\n  }\n});\nObject.defineProperty(exports, \"loadPartialConfigAsync\", {\n  enumerable: true,\n  get: function () {\n    return _index2.loadPartialConfigAsync;\n  }\n});\nObject.defineProperty(exports, \"loadPartialConfigSync\", {\n  enumerable: true,\n  get: function () {\n    return _index2.loadPartialConfigSync;\n  }\n});\nObject.defineProperty(exports, \"parse\", {\n  enumerable: true,\n  get: function () {\n    return _parse.parse;\n  }\n});\nObject.defineProperty(exports, \"parseAsync\", {\n  enumerable: true,\n  get: function () {\n    return _parse.parseAsync;\n  }\n});\nObject.defineProperty(exports, \"parseSync\", {\n  enumerable: true,\n  get: function () {\n    return _parse.parseSync;\n  }\n});\nObject.defineProperty(exports, \"resolvePlugin\", {\n  enumerable: true,\n  get: function () {\n    return _index.resolvePlugin;\n  }\n});\nObject.defineProperty(exports, \"resolvePreset\", {\n  enumerable: true,\n  get: function () {\n    return _index.resolvePreset;\n  }\n});\nObject.defineProperty((0, exports), \"template\", {\n  enumerable: true,\n  get: function () {\n    return _template().default;\n  }\n});\nObject.defineProperty((0, exports), \"tokTypes\", {\n  enumerable: true,\n  get: function () {\n    return _parser().tokTypes;\n  }\n});\nObject.defineProperty(exports, \"transform\", {\n  enumerable: true,\n  get: function () {\n    return _transform.transform;\n  }\n});\nObject.defineProperty(exports, \"transformAsync\", {\n  enumerable: true,\n  get: function () {\n    return _transform.transformAsync;\n  }\n});\nObject.defineProperty(exports, \"transformFile\", {\n  enumerable: true,\n  get: function () {\n    return _transformFile.transformFile;\n  }\n});\nObject.defineProperty(exports, \"transformFileAsync\", {\n  enumerable: true,\n  get: function () {\n    return _transformFile.transformFileAsync;\n  }\n});\nObject.defineProperty(exports, \"transformFileSync\", {\n  enumerable: true,\n  get: function () {\n    return _transformFile.transformFileSync;\n  }\n});\nObject.defineProperty(exports, \"transformFromAst\", {\n  enumerable: true,\n  get: function () {\n    return _transformAst.transformFromAst;\n  }\n});\nObject.defineProperty(exports, \"transformFromAstAsync\", {\n  enumerable: true,\n  get: function () {\n    return _transformAst.transformFromAstAsync;\n  }\n});\nObject.defineProperty(exports, \"transformFromAstSync\", {\n  enumerable: true,\n  get: function () {\n    return _transformAst.transformFromAstSync;\n  }\n});\nObject.defineProperty(exports, \"transformSync\", {\n  enumerable: true,\n  get: function () {\n    return _transform.transformSync;\n  }\n});\nObject.defineProperty((0, exports), \"traverse\", {\n  enumerable: true,\n  get: function () {\n    return _traverse().default;\n  }\n});\nexports.version = exports.types = void 0;\nvar _file = require(\"./transformation/file/file.js\");\nvar _buildExternalHelpers = require(\"./tools/build-external-helpers.js\");\nvar _index = require(\"./config/files/index.js\");\nvar _environment = require(\"./config/helpers/environment.js\");\nfunction _types() {\n  const data = require(\"@babel/types\");\n  _types = function () {\n    return data;\n  };\n  return data;\n}\nObject.defineProperty((0, exports), \"types\", {\n  enumerable: true,\n  get: function () {\n    return _types();\n  }\n});\nfunction _parser() {\n  const data = require(\"@babel/parser\");\n  _parser = function () {\n    return data;\n  };\n  return data;\n}\nfunction _traverse() {\n  const data = require(\"@babel/traverse\");\n  _traverse = function () {\n    return data;\n  };\n  return data;\n}\nfunction _template() {\n  const data = require(\"@babel/template\");\n  _template = function () {\n    return data;\n  };\n  return data;\n}\nvar _index2 = require(\"./config/index.js\");\nvar _transform = require(\"./transform.js\");\nvar _transformFile = require(\"./transform-file.js\");\nvar _transformAst = require(\"./transform-ast.js\");\nvar _parse = require(\"./parse.js\");\nvar thisFile = require(\"./index.js\");\n;\nconst version = \"7.23.2\";\nexports.version = version;\nconst DEFAULT_EXTENSIONS = Object.freeze([\".js\", \".jsx\", \".es6\", \".es\", \".mjs\", \".cjs\"]);\nexports.DEFAULT_EXTENSIONS = DEFAULT_EXTENSIONS;\n;\n{\n  exports.OptionManager = class OptionManager {\n    init(opts) {\n      return (0, _index2.loadOptionsSync)(opts);\n    }\n  };\n  exports.Plugin = function Plugin(alias) {\n    throw new Error(`The (${alias}) Babel 5 plugin is being run with an unsupported Babel version.`);\n  };\n}\n0 && (exports.types = exports.traverse = exports.tokTypes = exports.template = 0);\n\n//# sourceMappingURL=index.js.map\n",
    "package.json": "{\n  \"name\": \"@babel/core\",\n  \"version\": \"7.23.2\",\n  \"description\": \"Babel compiler core.\",\n  \"main\": \"./lib/index.js\",\n  \"author\": \"The Babel Team (https://babel.dev/team)\",\n  \"license\": \"MIT\",\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/babel/babel.git\",\n    \"directory\": \"packages/babel-core\"\n  },\n  \"homepage\": \"https://babel.dev/docs/en/next/babel-core\",\n  \"bugs\": \"https://github.com/babel/babel/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3A%22pkg%3A%20core%22+is%3Aopen\",\n  \"keywords\": [\n    \"6to5\",\n    \"babel\",\n    \"classes\",\n    \"const\",\n    \"es6\",\n    \"harmony\",\n    \"let\",\n    \"modules\",\n    \"transpile\",\n    \"transpiler\",\n    \"var\",\n    \"babel-core\",\n    \"compiler\"\n  ],\n  \"engines\": {\n    \"node\": \">=6.9.0\"\n  },\n  \"funding\": {\n    \"type\": \"opencollective\",\n    \"url\": \"https://opencollective.com/babel\"\n  },\n  \"browser\": {\n    \"./lib/config/files/index.js\": \"./lib/config/files/index-browser.js\",\n    \"./lib/config/resolve-targets.js\": \"./lib/config/resolve-targets-browser.js\",\n    \"./lib/transform-file.js\": \"./lib/transform-file-browser.js\",\n    \"./src/config/files/index.ts\": \"./src/config/files/index-browser.ts\",\n    \"./src/config/resolve-targets.ts\": \"./src/config/resolve-targets-browser.ts\",\n    \"./src/transform-file.ts\": \"./src/transform-file-browser.ts\"\n  },\n  \"dependencies\": {\n    \"@ampproject/remapping\": \"^2.2.0\",\n    \"@babel/code-frame\": \"^7.22.13\",\n    \"@babel/generator\": \"^7.23.0\",\n    \"@babel/helper-compilation-targets\": \"^7.22.15\",\n    \"@babel/helper-module-transforms\": \"^7.23.0\",\n    \"@babel/helpers\": \"^7.23.2\",\n    \"@babel/parser\": \"^7.23.0\",\n    \"@babel/template\": \"^7.22.15\",\n    \"@babel/traverse\": \"^7.23.2\",\n    \"@babel/types\": \"^7.23.0\",\n    \"convert-source-map\": \"^2.0.0\",\n    \"debug\": \"^4.1.0\",\n    \"gensync\": \"^1.0.0-beta.2\",\n    \"json5\": \"^2.2.3\",\n    \"semver\": \"^6.3.1\"\n  },\n  \"devDependencies\": {\n    \"@babel/helper-transform-fixture-test-runner\": \"^7.22.19\",\n    \"@babel/plugin-syntax-flow\": \"^7.22.5\",\n    \"@babel/plugin-transform-flow-strip-types\": \"^7.22.5\",\n    \"@babel/plugin-transform-modules-commonjs\": \"^7.23.0\",\n    \"@babel/preset-env\": \"^7.23.2\",\n    \"@babel/preset-typescript\": \"^7.23.2\",\n    \"@jridgewell/trace-mapping\": \"^0.3.17\",\n    \"@types/convert-source-map\": \"^2.0.0\",\n    \"@types/debug\": \"^4.1.0\",\n    \"@types/gensync\": \"^1.0.0\",\n    \"@types/resolve\": \"^1.3.2\",\n    \"@types/semver\": \"^5.4.0\",\n    \"rimraf\": \"^3.0.0\",\n    \"ts-node\": \"^10.9.1\"\n  },\n  \"type\": \"commonjs\"\n}",
    "lib/config/files/index.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"ROOT_CONFIG_FILENAMES\", {\n  enumerable: true,\n  get: function () {\n    return _configuration.ROOT_CONFIG_FILENAMES;\n  }\n});\nObject.defineProperty(exports, \"findConfigUpwards\", {\n  enumerable: true,\n  get: function () {\n    return _configuration.findConfigUpwards;\n  }\n});\nObject.defineProperty(exports, \"findPackageData\", {\n  enumerable: true,\n  get: function () {\n    return _package.findPackageData;\n  }\n});\nObject.defineProperty(exports, \"findRelativeConfig\", {\n  enumerable: true,\n  get: function () {\n    return _configuration.findRelativeConfig;\n  }\n});\nObject.defineProperty(exports, \"findRootConfig\", {\n  enumerable: true,\n  get: function () {\n    return _configuration.findRootConfig;\n  }\n});\nObject.defineProperty(exports, \"loadConfig\", {\n  enumerable: true,\n  get: function () {\n    return _configuration.loadConfig;\n  }\n});\nObject.defineProperty(exports, \"loadPlugin\", {\n  enumerable: true,\n  get: function () {\n    return _plugins.loadPlugin;\n  }\n});\nObject.defineProperty(exports, \"loadPreset\", {\n  enumerable: true,\n  get: function () {\n    return _plugins.loadPreset;\n  }\n});\nObject.defineProperty(exports, \"resolvePlugin\", {\n  enumerable: true,\n  get: function () {\n    return _plugins.resolvePlugin;\n  }\n});\nObject.defineProperty(exports, \"resolvePreset\", {\n  enumerable: true,\n  get: function () {\n    return _plugins.resolvePreset;\n  }\n});\nObject.defineProperty(exports, \"resolveShowConfigPath\", {\n  enumerable: true,\n  get: function () {\n    return _configuration.resolveShowConfigPath;\n  }\n});\nvar _package = require(\"./package.js\");\nvar _configuration = require(\"./configuration.js\");\nvar _plugins = require(\"./plugins.js\");\n({});\n0 && 0;\n\n//# sourceMappingURL=index.js.map\n",
    "lib/transform-file.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.transformFile = transformFile;\nexports.transformFileAsync = transformFileAsync;\nexports.transformFileSync = transformFileSync;\nfunction _gensync() {\n  const data = require(\"gensync\");\n  _gensync = function () {\n    return data;\n  };\n  return data;\n}\nvar _index = require(\"./config/index.js\");\nvar _index2 = require(\"./transformation/index.js\");\nvar fs = require(\"./gensync-utils/fs.js\");\n({});\nconst transformFileRunner = _gensync()(function* (filename, opts) {\n  const options = Object.assign({}, opts, {\n    filename\n  });\n  const config = yield* (0, _index.default)(options);\n  if (config === null) return null;\n  const code = yield* fs.readFile(filename, \"utf8\");\n  return yield* (0, _index2.run)(config, code);\n});\nfunction transformFile(...args) {\n  transformFileRunner.errback(...args);\n}\nfunction transformFileSync(...args) {\n  return transformFileRunner.sync(...args);\n}\nfunction transformFileAsync(...args) {\n  return transformFileRunner.async(...args);\n}\n0 && 0;\n\n//# sourceMappingURL=transform-file.js.map\n",
    "lib/transformation/file/file.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nfunction helpers() {\n  const data = require(\"@babel/helpers\");\n  helpers = function () {\n    return data;\n  };\n  return data;\n}\nfunction _traverse() {\n  const data = require(\"@babel/traverse\");\n  _traverse = function () {\n    return data;\n  };\n  return data;\n}\nfunction _codeFrame() {\n  const data = require(\"@babel/code-frame\");\n  _codeFrame = function () {\n    return data;\n  };\n  return data;\n}\nfunction _t() {\n  const data = require(\"@babel/types\");\n  _t = function () {\n    return data;\n  };\n  return data;\n}\nfunction _helperModuleTransforms() {\n  const data = require(\"@babel/helper-module-transforms\");\n  _helperModuleTransforms = function () {\n    return data;\n  };\n  return data;\n}\nfunction _semver() {\n  const data = require(\"semver\");\n  _semver = function () {\n    return data;\n  };\n  return data;\n}\nconst {\n  cloneNode,\n  interpreterDirective\n} = _t();\nconst errorVisitor = {\n  enter(path, state) {\n    const loc = path.node.loc;\n    if (loc) {\n      state.loc = loc;\n      path.stop();\n    }\n  }\n};\nclass File {\n  constructor(options, {\n    code,\n    ast,\n    inputMap\n  }) {\n    this._map = new Map();\n    this.opts = void 0;\n    this.declarations = {};\n    this.path = void 0;\n    this.ast = void 0;\n    this.scope = void 0;\n    this.metadata = {};\n    this.code = \"\";\n    this.inputMap = void 0;\n    this.hub = {\n      file: this,\n      getCode: () => this.code,\n      getScope: () => this.scope,\n      addHelper: this.addHelper.bind(this),\n      buildError: this.buildCodeFrameError.bind(this)\n    };\n    this.opts = options;\n    this.code = code;\n    this.ast = ast;\n    this.inputMap = inputMap;\n    this.path = _traverse().NodePath.get({\n      hub: this.hub,\n      parentPath: null,\n      parent: this.ast,\n      container: this.ast,\n      key: \"program\"\n    }).setContext();\n    this.scope = this.path.scope;\n  }\n  get shebang() {\n    const {\n      interpreter\n    } = this.path.node;\n    return interpreter ? interpreter.value : \"\";\n  }\n  set shebang(value) {\n    if (value) {\n      this.path.get(\"interpreter\").replaceWith(interpreterDirective(value));\n    } else {\n      this.path.get(\"interpreter\").remove();\n    }\n  }\n  set(key, val) {\n    if (key === \"helpersNamespace\") {\n      throw new Error(\"Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility.\" + \"If you are using @babel/plugin-external-helpers you will need to use a newer \" + \"version than the one you currently have installed. \" + \"If you have your own implementation, you'll want to explore using 'helperGenerator' \" + \"alongside 'file.availableHelper()'.\");\n    }\n    this._map.set(key, val);\n  }\n  get(key) {\n    return this._map.get(key);\n  }\n  has(key) {\n    return this._map.has(key);\n  }\n  getModuleName() {\n    return (0, _helperModuleTransforms().getModuleName)(this.opts, this.opts);\n  }\n  addImport() {\n    throw new Error(\"This API has been removed. If you're looking for this \" + \"functionality in Babel 7, you should import the \" + \"'@babel/helper-module-imports' module and use the functions exposed \" + \" from that module, such as 'addNamed' or 'addDefault'.\");\n  }\n  availableHelper(name, versionRange) {\n    let minVersion;\n    try {\n      minVersion = helpers().minVersion(name);\n    } catch (err) {\n      if (err.code !== \"BABEL_HELPER_UNKNOWN\") throw err;\n      return false;\n    }\n    if (typeof versionRange !== \"string\") return true;\n    if (_semver().valid(versionRange)) versionRange = `^${versionRange}`;\n    return !_semver().intersects(`<${minVersion}`, versionRange) && !_semver().intersects(`>=8.0.0`, versionRange);\n  }\n  addHelper(name) {\n    const declar = this.declarations[name];\n    if (declar) return cloneNode(declar);\n    const generator = this.get(\"helperGenerator\");\n    if (generator) {\n      const res = generator(name);\n      if (res) return res;\n    }\n    helpers().ensure(name, File);\n    const uid = this.declarations[name] = this.scope.generateUidIdentifier(name);\n    const dependencies = {};\n    for (const dep of helpers().getDependencies(name)) {\n      dependencies[dep] = this.addHelper(dep);\n    }\n    const {\n      nodes,\n      globals\n    } = helpers().get(name, dep => dependencies[dep], uid, Object.keys(this.scope.getAllBindings()));\n    globals.forEach(name => {\n      if (this.path.scope.hasBinding(name, true)) {\n        this.path.scope.rename(name);\n      }\n    });\n    nodes.forEach(node => {\n      node._compact = true;\n    });\n    this.path.unshiftContainer(\"body\", nodes);\n    this.path.get(\"body\").forEach(path => {\n      if (nodes.indexOf(path.node) === -1) return;\n      if (path.isVariableDeclaration()) this.scope.registerDeclaration(path);\n    });\n    return uid;\n  }\n  addTemplateObject() {\n    throw new Error(\"This function has been moved into the template literal transform itself.\");\n  }\n  buildCodeFrameError(node, msg, _Error = SyntaxError) {\n    let loc = node && (node.loc || node._loc);\n    if (!loc && node) {\n      const state = {\n        loc: null\n      };\n      (0, _traverse().default)(node, errorVisitor, this.scope, state);\n      loc = state.loc;\n      let txt = \"This is an error on an internal node. Probably an internal error.\";\n      if (loc) txt += \" Location has been estimated.\";\n      msg += ` (${txt})`;\n    }\n    if (loc) {\n      const {\n        highlightCode = true\n      } = this.opts;\n      msg += \"\\n\" + (0, _codeFrame().codeFrameColumns)(this.code, {\n        start: {\n          line: loc.start.line,\n          column: loc.start.column + 1\n        },\n        end: loc.end && loc.start.line === loc.end.line ? {\n          line: loc.end.line,\n          column: loc.end.column + 1\n        } : undefined\n      }, {\n        highlightCode\n      });\n    }\n    return new _Error(msg);\n  }\n}\nexports.default = File;\n0 && 0;\n\n//# sourceMappingURL=file.js.map\n",
    "lib/tools/build-external-helpers.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\nfunction helpers() {\n  const data = require(\"@babel/helpers\");\n  helpers = function () {\n    return data;\n  };\n  return data;\n}\nfunction _generator() {\n  const data = require(\"@babel/generator\");\n  _generator = function () {\n    return data;\n  };\n  return data;\n}\nfunction _template() {\n  const data = require(\"@babel/template\");\n  _template = function () {\n    return data;\n  };\n  return data;\n}\nfunction _t() {\n  const data = require(\"@babel/types\");\n  _t = function () {\n    return data;\n  };\n  return data;\n}\nvar _file = require(\"../transformation/file/file.js\");\nconst {\n  arrayExpression,\n  assignmentExpression,\n  binaryExpression,\n  blockStatement,\n  callExpression,\n  cloneNode,\n  conditionalExpression,\n  exportNamedDeclaration,\n  exportSpecifier,\n  expressionStatement,\n  functionExpression,\n  identifier,\n  memberExpression,\n  objectExpression,\n  program,\n  stringLiteral,\n  unaryExpression,\n  variableDeclaration,\n  variableDeclarator\n} = _t();\nconst buildUmdWrapper = replacements => _template().default.statement`\n    (function (root, factory) {\n      if (typeof define === \"function\" && define.amd) {\n        define(AMD_ARGUMENTS, factory);\n      } else if (typeof exports === \"object\") {\n        factory(COMMON_ARGUMENTS);\n      } else {\n        factory(BROWSER_ARGUMENTS);\n      }\n    })(UMD_ROOT, function (FACTORY_PARAMETERS) {\n      FACTORY_BODY\n    });\n  `(replacements);\nfunction buildGlobal(allowlist) {\n  const namespace = identifier(\"babelHelpers\");\n  const body = [];\n  const container = functionExpression(null, [identifier(\"global\")], blockStatement(body));\n  const tree = program([expressionStatement(callExpression(container, [conditionalExpression(binaryExpression(\"===\", unaryExpression(\"typeof\", identifier(\"global\")), stringLiteral(\"undefined\")), identifier(\"self\"), identifier(\"global\"))]))]);\n  body.push(variableDeclaration(\"var\", [variableDeclarator(namespace, assignmentExpression(\"=\", memberExpression(identifier(\"global\"), namespace), objectExpression([])))]));\n  buildHelpers(body, namespace, allowlist);\n  return tree;\n}\nfunction buildModule(allowlist) {\n  const body = [];\n  const refs = buildHelpers(body, null, allowlist);\n  body.unshift(exportNamedDeclaration(null, Object.keys(refs).map(name => {\n    return exportSpecifier(cloneNode(refs[name]), identifier(name));\n  })));\n  return program(body, [], \"module\");\n}\nfunction buildUmd(allowlist) {\n  const namespace = identifier(\"babelHelpers\");\n  const body = [];\n  body.push(variableDeclaration(\"var\", [variableDeclarator(namespace, identifier(\"global\"))]));\n  buildHelpers(body, namespace, allowlist);\n  return program([buildUmdWrapper({\n    FACTORY_PARAMETERS: identifier(\"global\"),\n    BROWSER_ARGUMENTS: assignmentExpression(\"=\", memberExpression(identifier(\"root\"), namespace), objectExpression([])),\n    COMMON_ARGUMENTS: identifier(\"exports\"),\n    AMD_ARGUMENTS: arrayExpression([stringLiteral(\"exports\")]),\n    FACTORY_BODY: body,\n    UMD_ROOT: identifier(\"this\")\n  })]);\n}\nfunction buildVar(allowlist) {\n  const namespace = identifier(\"babelHelpers\");\n  const body = [];\n  body.push(variableDeclaration(\"var\", [variableDeclarator(namespace, objectExpression([]))]));\n  const tree = program(body);\n  buildHelpers(body, namespace, allowlist);\n  body.push(expressionStatement(namespace));\n  return tree;\n}\nfunction buildHelpers(body, namespace, allowlist) {\n  const getHelperReference = name => {\n    return namespace ? memberExpression(namespace, identifier(name)) : identifier(`_${name}`);\n  };\n  const refs = {};\n  helpers().list.forEach(function (name) {\n    if (allowlist && allowlist.indexOf(name) < 0) return;\n    const ref = refs[name] = getHelperReference(name);\n    helpers().ensure(name, _file.default);\n    const {\n      nodes\n    } = helpers().get(name, getHelperReference, ref);\n    body.push(...nodes);\n  });\n  return refs;\n}\nfunction _default(allowlist, outputType = \"global\") {\n  let tree;\n  const build = {\n    global: buildGlobal,\n    module: buildModule,\n    umd: buildUmd,\n    var: buildVar\n  }[outputType];\n  if (build) {\n    tree = build(allowlist);\n  } else {\n    throw new Error(`Unsupported output type ${outputType}`);\n  }\n  return (0, _generator().default)(tree).code;\n}\n0 && 0;\n\n//# sourceMappingURL=build-external-helpers.js.map\n",
    "lib/config/files/index-browser.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ROOT_CONFIG_FILENAMES = void 0;\nexports.findConfigUpwards = findConfigUpwards;\nexports.findPackageData = findPackageData;\nexports.findRelativeConfig = findRelativeConfig;\nexports.findRootConfig = findRootConfig;\nexports.loadConfig = loadConfig;\nexports.loadPlugin = loadPlugin;\nexports.loadPreset = loadPreset;\nexports.resolvePlugin = resolvePlugin;\nexports.resolvePreset = resolvePreset;\nexports.resolveShowConfigPath = resolveShowConfigPath;\nfunction findConfigUpwards(rootDir) {\n  return null;\n}\nfunction* findPackageData(filepath) {\n  return {\n    filepath,\n    directories: [],\n    pkg: null,\n    isPackage: false\n  };\n}\nfunction* findRelativeConfig(pkgData, envName, caller) {\n  return {\n    config: null,\n    ignore: null\n  };\n}\nfunction* findRootConfig(dirname, envName, caller) {\n  return null;\n}\nfunction* loadConfig(name, dirname, envName, caller) {\n  throw new Error(`Cannot load ${name} relative to ${dirname} in a browser`);\n}\nfunction* resolveShowConfigPath(dirname) {\n  return null;\n}\nconst ROOT_CONFIG_FILENAMES = [];\nexports.ROOT_CONFIG_FILENAMES = ROOT_CONFIG_FILENAMES;\nfunction resolvePlugin(name, dirname) {\n  return null;\n}\nfunction resolvePreset(name, dirname) {\n  return null;\n}\nfunction loadPlugin(name, dirname) {\n  throw new Error(`Cannot load plugin ${name} relative to ${dirname} in a browser`);\n}\nfunction loadPreset(name, dirname) {\n  throw new Error(`Cannot load preset ${name} relative to ${dirname} in a browser`);\n}\n0 && 0;\n\n//# sourceMappingURL=index-browser.js.map\n",
    "lib/config/helpers/environment.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getEnv = getEnv;\nfunction getEnv(defaultValue = \"development\") {\n  return process.env.BABEL_ENV || process.env.NODE_ENV || defaultValue;\n}\n0 && 0;\n\n//# sourceMappingURL=environment.js.map\n",
    "lib/config/index.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createConfigItem = createConfigItem;\nexports.createConfigItemAsync = createConfigItemAsync;\nexports.createConfigItemSync = createConfigItemSync;\nObject.defineProperty(exports, \"default\", {\n  enumerable: true,\n  get: function () {\n    return _full.default;\n  }\n});\nexports.loadOptions = loadOptions;\nexports.loadOptionsAsync = loadOptionsAsync;\nexports.loadOptionsSync = loadOptionsSync;\nexports.loadPartialConfig = loadPartialConfig;\nexports.loadPartialConfigAsync = loadPartialConfigAsync;\nexports.loadPartialConfigSync = loadPartialConfigSync;\nfunction _gensync() {\n  const data = require(\"gensync\");\n  _gensync = function () {\n    return data;\n  };\n  return data;\n}\nvar _full = require(\"./full.js\");\nvar _partial = require(\"./partial.js\");\nvar _item = require(\"./item.js\");\nvar _rewriteStackTrace = require(\"../errors/rewrite-stack-trace.js\");\nconst loadPartialConfigRunner = _gensync()(_partial.loadPartialConfig);\nfunction loadPartialConfigAsync(...args) {\n  return (0, _rewriteStackTrace.beginHiddenCallStack)(loadPartialConfigRunner.async)(...args);\n}\nfunction loadPartialConfigSync(...args) {\n  return (0, _rewriteStackTrace.beginHiddenCallStack)(loadPartialConfigRunner.sync)(...args);\n}\nfunction loadPartialConfig(opts, callback) {\n  if (callback !== undefined) {\n    (0, _rewriteStackTrace.beginHiddenCallStack)(loadPartialConfigRunner.errback)(opts, callback);\n  } else if (typeof opts === \"function\") {\n    (0, _rewriteStackTrace.beginHiddenCallStack)(loadPartialConfigRunner.errback)(undefined, opts);\n  } else {\n    {\n      return loadPartialConfigSync(opts);\n    }\n  }\n}\nfunction* loadOptionsImpl(opts) {\n  var _config$options;\n  const config = yield* (0, _full.default)(opts);\n  return (_config$options = config == null ? void 0 : config.options) != null ? _config$options : null;\n}\nconst loadOptionsRunner = _gensync()(loadOptionsImpl);\nfunction loadOptionsAsync(...args) {\n  return (0, _rewriteStackTrace.beginHiddenCallStack)(loadOptionsRunner.async)(...args);\n}\nfunction loadOptionsSync(...args) {\n  return (0, _rewriteStackTrace.beginHiddenCallStack)(loadOptionsRunner.sync)(...args);\n}\nfunction loadOptions(opts, callback) {\n  if (callback !== undefined) {\n    (0, _rewriteStackTrace.beginHiddenCallStack)(loadOptionsRunner.errback)(opts, callback);\n  } else if (typeof opts === \"function\") {\n    (0, _rewriteStackTrace.beginHiddenCallStack)(loadOptionsRunner.errback)(undefined, opts);\n  } else {\n    {\n      return loadOptionsSync(opts);\n    }\n  }\n}\nconst createConfigItemRunner = _gensync()(_item.createConfigItem);\nfunction createConfigItemAsync(...args) {\n  return (0, _rewriteStackTrace.beginHiddenCallStack)(createConfigItemRunner.async)(...args);\n}\nfunction createConfigItemSync(...args) {\n  return (0, _rewriteStackTrace.beginHiddenCallStack)(createConfigItemRunner.sync)(...args);\n}\nfunction createConfigItem(target, options, callback) {\n  if (callback !== undefined) {\n    (0, _rewriteStackTrace.beginHiddenCallStack)(createConfigItemRunner.errback)(target, options, callback);\n  } else if (typeof options === \"function\") {\n    (0, _rewriteStackTrace.beginHiddenCallStack)(createConfigItemRunner.errback)(target, undefined, callback);\n  } else {\n    {\n      return createConfigItemSync(target, options);\n    }\n  }\n}\n0 && 0;\n\n//# sourceMappingURL=index.js.map\n",
    "lib/transform.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.transform = void 0;\nexports.transformAsync = transformAsync;\nexports.transformSync = transformSync;\nfunction _gensync() {\n  const data = require(\"gensync\");\n  _gensync = function () {\n    return data;\n  };\n  return data;\n}\nvar _index = require(\"./config/index.js\");\nvar _index2 = require(\"./transformation/index.js\");\nvar _rewriteStackTrace = require(\"./errors/rewrite-stack-trace.js\");\nconst transformRunner = _gensync()(function* transform(code, opts) {\n  const config = yield* (0, _index.default)(opts);\n  if (config === null) return null;\n  return yield* (0, _index2.run)(config, code);\n});\nconst transform = function transform(code, optsOrCallback, maybeCallback) {\n  let opts;\n  let callback;\n  if (typeof optsOrCallback === \"function\") {\n    callback = optsOrCallback;\n    opts = undefined;\n  } else {\n    opts = optsOrCallback;\n    callback = maybeCallback;\n  }\n  if (callback === undefined) {\n    {\n      return (0, _rewriteStackTrace.beginHiddenCallStack)(transformRunner.sync)(code, opts);\n    }\n  }\n  (0, _rewriteStackTrace.beginHiddenCallStack)(transformRunner.errback)(code, opts, callback);\n};\nexports.transform = transform;\nfunction transformSync(...args) {\n  return (0, _rewriteStackTrace.beginHiddenCallStack)(transformRunner.sync)(...args);\n}\nfunction transformAsync(...args) {\n  return (0, _rewriteStackTrace.beginHiddenCallStack)(transformRunner.async)(...args);\n}\n0 && 0;\n\n//# sourceMappingURL=transform.js.map\n",
    "lib/transform-file-browser.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.transformFile = void 0;\nexports.transformFileAsync = transformFileAsync;\nexports.transformFileSync = transformFileSync;\nconst transformFile = function transformFile(filename, opts, callback) {\n  if (typeof opts === \"function\") {\n    callback = opts;\n  }\n  callback(new Error(\"Transforming files is not supported in browsers\"), null);\n};\nexports.transformFile = transformFile;\nfunction transformFileSync() {\n  throw new Error(\"Transforming files is not supported in browsers\");\n}\nfunction transformFileAsync() {\n  return Promise.reject(new Error(\"Transforming files is not supported in browsers\"));\n}\n0 && 0;\n\n//# sourceMappingURL=transform-file-browser.js.map\n",
    "lib/transform-ast.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.transformFromAst = void 0;\nexports.transformFromAstAsync = transformFromAstAsync;\nexports.transformFromAstSync = transformFromAstSync;\nfunction _gensync() {\n  const data = require(\"gensync\");\n  _gensync = function () {\n    return data;\n  };\n  return data;\n}\nvar _index = require(\"./config/index.js\");\nvar _index2 = require(\"./transformation/index.js\");\nvar _rewriteStackTrace = require(\"./errors/rewrite-stack-trace.js\");\nconst transformFromAstRunner = _gensync()(function* (ast, code, opts) {\n  const config = yield* (0, _index.default)(opts);\n  if (config === null) return null;\n  if (!ast) throw new Error(\"No AST given\");\n  return yield* (0, _index2.run)(config, code, ast);\n});\nconst transformFromAst = function transformFromAst(ast, code, optsOrCallback, maybeCallback) {\n  let opts;\n  let callback;\n  if (typeof optsOrCallback === \"function\") {\n    callback = optsOrCallback;\n    opts = undefined;\n  } else {\n    opts = optsOrCallback;\n    callback = maybeCallback;\n  }\n  if (callback === undefined) {\n    {\n      return (0, _rewriteStackTrace.beginHiddenCallStack)(transformFromAstRunner.sync)(ast, code, opts);\n    }\n  }\n  (0, _rewriteStackTrace.beginHiddenCallStack)(transformFromAstRunner.errback)(ast, code, opts, callback);\n};\nexports.transformFromAst = transformFromAst;\nfunction transformFromAstSync(...args) {\n  return (0, _rewriteStackTrace.beginHiddenCallStack)(transformFromAstRunner.sync)(...args);\n}\nfunction transformFromAstAsync(...args) {\n  return (0, _rewriteStackTrace.beginHiddenCallStack)(transformFromAstRunner.async)(...args);\n}\n0 && 0;\n\n//# sourceMappingURL=transform-ast.js.map\n",
    "lib/parse.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parse = void 0;\nexports.parseAsync = parseAsync;\nexports.parseSync = parseSync;\nfunction _gensync() {\n  const data = require(\"gensync\");\n  _gensync = function () {\n    return data;\n  };\n  return data;\n}\nvar _index = require(\"./config/index.js\");\nvar _index2 = require(\"./parser/index.js\");\nvar _normalizeOpts = require(\"./transformation/normalize-opts.js\");\nvar _rewriteStackTrace = require(\"./errors/rewrite-stack-trace.js\");\nconst parseRunner = _gensync()(function* parse(code, opts) {\n  const config = yield* (0, _index.default)(opts);\n  if (config === null) {\n    return null;\n  }\n  return yield* (0, _index2.default)(config.passes, (0, _normalizeOpts.default)(config), code);\n});\nconst parse = function parse(code, opts, callback) {\n  if (typeof opts === \"function\") {\n    callback = opts;\n    opts = undefined;\n  }\n  if (callback === undefined) {\n    {\n      return (0, _rewriteStackTrace.beginHiddenCallStack)(parseRunner.sync)(code, opts);\n    }\n  }\n  (0, _rewriteStackTrace.beginHiddenCallStack)(parseRunner.errback)(code, opts, callback);\n};\nexports.parse = parse;\nfunction parseSync(...args) {\n  return (0, _rewriteStackTrace.beginHiddenCallStack)(parseRunner.sync)(...args);\n}\nfunction parseAsync(...args) {\n  return (0, _rewriteStackTrace.beginHiddenCallStack)(parseRunner.async)(...args);\n}\n0 && 0;\n\n//# sourceMappingURL=parse.js.map\n",
    "lib/config/full.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nfunction _gensync() {\n  const data = require(\"gensync\");\n  _gensync = function () {\n    return data;\n  };\n  return data;\n}\nvar _async = require(\"../gensync-utils/async.js\");\nvar _util = require(\"./util.js\");\nvar context = require(\"../index.js\");\nvar _plugin = require(\"./plugin.js\");\nvar _item = require(\"./item.js\");\nvar _configChain = require(\"./config-chain.js\");\nvar _deepArray = require(\"./helpers/deep-array.js\");\nfunction _traverse() {\n  const data = require(\"@babel/traverse\");\n  _traverse = function () {\n    return data;\n  };\n  return data;\n}\nvar _caching = require(\"./caching.js\");\nvar _options = require(\"./validation/options.js\");\nvar _plugins = require(\"./validation/plugins.js\");\nvar _configApi = require(\"./helpers/config-api.js\");\nvar _partial = require(\"./partial.js\");\nvar _configError = require(\"../errors/config-error.js\");\nvar _default = _gensync()(function* loadFullConfig(inputOpts) {\n  var _opts$assumptions;\n  const result = yield* (0, _partial.default)(inputOpts);\n  if (!result) {\n    return null;\n  }\n  const {\n    options,\n    context,\n    fileHandling\n  } = result;\n  if (fileHandling === \"ignored\") {\n    return null;\n  }\n  const optionDefaults = {};\n  const {\n    plugins,\n    presets\n  } = options;\n  if (!plugins || !presets) {\n    throw new Error(\"Assertion failure - plugins and presets exist\");\n  }\n  const presetContext = Object.assign({}, context, {\n    targets: options.targets\n  });\n  const toDescriptor = item => {\n    const desc = (0, _item.getItemDescriptor)(item);\n    if (!desc) {\n      throw new Error(\"Assertion failure - must be config item\");\n    }\n    return desc;\n  };\n  const presetsDescriptors = presets.map(toDescriptor);\n  const initialPluginsDescriptors = plugins.map(toDescriptor);\n  const pluginDescriptorsByPass = [[]];\n  const passes = [];\n  const externalDependencies = [];\n  const ignored = yield* enhanceError(context, function* recursePresetDescriptors(rawPresets, pluginDescriptorsPass) {\n    const presets = [];\n    for (let i = 0; i < rawPresets.length; i++) {\n      const descriptor = rawPresets[i];\n      if (descriptor.options !== false) {\n        try {\n          var preset = yield* loadPresetDescriptor(descriptor, presetContext);\n        } catch (e) {\n          if (e.code === \"BABEL_UNKNOWN_OPTION\") {\n            (0, _options.checkNoUnwrappedItemOptionPairs)(rawPresets, i, \"preset\", e);\n          }\n          throw e;\n        }\n        externalDependencies.push(preset.externalDependencies);\n        if (descriptor.ownPass) {\n          presets.push({\n            preset: preset.chain,\n            pass: []\n          });\n        } else {\n          presets.unshift({\n            preset: preset.chain,\n            pass: pluginDescriptorsPass\n          });\n        }\n      }\n    }\n    if (presets.length > 0) {\n      pluginDescriptorsByPass.splice(1, 0, ...presets.map(o => o.pass).filter(p => p !== pluginDescriptorsPass));\n      for (const {\n        preset,\n        pass\n      } of presets) {\n        if (!preset) return true;\n        pass.push(...preset.plugins);\n        const ignored = yield* recursePresetDescriptors(preset.presets, pass);\n        if (ignored) return true;\n        preset.options.forEach(opts => {\n          (0, _util.mergeOptions)(optionDefaults, opts);\n        });\n      }\n    }\n  })(presetsDescriptors, pluginDescriptorsByPass[0]);\n  if (ignored) return null;\n  const opts = optionDefaults;\n  (0, _util.mergeOptions)(opts, options);\n  const pluginContext = Object.assign({}, presetContext, {\n    assumptions: (_opts$assumptions = opts.assumptions) != null ? _opts$assumptions : {}\n  });\n  yield* enhanceError(context, function* loadPluginDescriptors() {\n    pluginDescriptorsByPass[0].unshift(...initialPluginsDescriptors);\n    for (const descs of pluginDescriptorsByPass) {\n      const pass = [];\n      passes.push(pass);\n      for (let i = 0; i < descs.length; i++) {\n        const descriptor = descs[i];\n        if (descriptor.options !== false) {\n          try {\n            var plugin = yield* loadPluginDescriptor(descriptor, pluginContext);\n          } catch (e) {\n            if (e.code === \"BABEL_UNKNOWN_PLUGIN_PROPERTY\") {\n              (0, _options.checkNoUnwrappedItemOptionPairs)(descs, i, \"plugin\", e);\n            }\n            throw e;\n          }\n          pass.push(plugin);\n          externalDependencies.push(plugin.externalDependencies);\n        }\n      }\n    }\n  })();\n  opts.plugins = passes[0];\n  opts.presets = passes.slice(1).filter(plugins => plugins.length > 0).map(plugins => ({\n    plugins\n  }));\n  opts.passPerPreset = opts.presets.length > 0;\n  return {\n    options: opts,\n    passes: passes,\n    externalDependencies: (0, _deepArray.finalize)(externalDependencies)\n  };\n});\nexports.default = _default;\nfunction enhanceError(context, fn) {\n  return function* (arg1, arg2) {\n    try {\n      return yield* fn(arg1, arg2);\n    } catch (e) {\n      if (!/^\\[BABEL\\]/.test(e.message)) {\n        var _context$filename;\n        e.message = `[BABEL] ${(_context$filename = context.filename) != null ? _context$filename : \"unknown file\"}: ${e.message}`;\n      }\n      throw e;\n    }\n  };\n}\nconst makeDescriptorLoader = apiFactory => (0, _caching.makeWeakCache)(function* ({\n  value,\n  options,\n  dirname,\n  alias\n}, cache) {\n  if (options === false) throw new Error(\"Assertion failure\");\n  options = options || {};\n  const externalDependencies = [];\n  let item = value;\n  if (typeof value === \"function\") {\n    const factory = (0, _async.maybeAsync)(value, `You appear to be using an async plugin/preset, but Babel has been called synchronously`);\n    const api = Object.assign({}, context, apiFactory(cache, externalDependencies));\n    try {\n      item = yield* factory(api, options, dirname);\n    } catch (e) {\n      if (alias) {\n        e.message += ` (While processing: ${JSON.stringify(alias)})`;\n      }\n      throw e;\n    }\n  }\n  if (!item || typeof item !== \"object\") {\n    throw new Error(\"Plugin/Preset did not return an object.\");\n  }\n  if ((0, _async.isThenable)(item)) {\n    yield* [];\n    throw new Error(`You appear to be using a promise as a plugin, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, ` + `you may need to upgrade your @babel/core version. ` + `As an alternative, you can prefix the promise with \"await\". ` + `(While processing: ${JSON.stringify(alias)})`);\n  }\n  if (externalDependencies.length > 0 && (!cache.configured() || cache.mode() === \"forever\")) {\n    let error = `A plugin/preset has external untracked dependencies ` + `(${externalDependencies[0]}), but the cache `;\n    if (!cache.configured()) {\n      error += `has not been configured to be invalidated when the external dependencies change. `;\n    } else {\n      error += ` has been configured to never be invalidated. `;\n    }\n    error += `Plugins/presets should configure their cache to be invalidated when the external ` + `dependencies change, for example using \\`api.cache.invalidate(() => ` + `statSync(filepath).mtimeMs)\\` or \\`api.cache.never()\\`\\n` + `(While processing: ${JSON.stringify(alias)})`;\n    throw new Error(error);\n  }\n  return {\n    value: item,\n    options,\n    dirname,\n    alias,\n    externalDependencies: (0, _deepArray.finalize)(externalDependencies)\n  };\n});\nconst pluginDescriptorLoader = makeDescriptorLoader(_configApi.makePluginAPI);\nconst presetDescriptorLoader = makeDescriptorLoader(_configApi.makePresetAPI);\nconst instantiatePlugin = (0, _caching.makeWeakCache)(function* ({\n  value,\n  options,\n  dirname,\n  alias,\n  externalDependencies\n}, cache) {\n  const pluginObj = (0, _plugins.validatePluginObject)(value);\n  const plugin = Object.assign({}, pluginObj);\n  if (plugin.visitor) {\n    plugin.visitor = _traverse().default.explode(Object.assign({}, plugin.visitor));\n  }\n  if (plugin.inherits) {\n    const inheritsDescriptor = {\n      name: undefined,\n      alias: `${alias}$inherits`,\n      value: plugin.inherits,\n      options,\n      dirname\n    };\n    const inherits = yield* (0, _async.forwardAsync)(loadPluginDescriptor, run => {\n      return cache.invalidate(data => run(inheritsDescriptor, data));\n    });\n    plugin.pre = chain(inherits.pre, plugin.pre);\n    plugin.post = chain(inherits.post, plugin.post);\n    plugin.manipulateOptions = chain(inherits.manipulateOptions, plugin.manipulateOptions);\n    plugin.visitor = _traverse().default.visitors.merge([inherits.visitor || {}, plugin.visitor || {}]);\n    if (inherits.externalDependencies.length > 0) {\n      if (externalDependencies.length === 0) {\n        externalDependencies = inherits.externalDependencies;\n      } else {\n        externalDependencies = (0, _deepArray.finalize)([externalDependencies, inherits.externalDependencies]);\n      }\n    }\n  }\n  return new _plugin.default(plugin, options, alias, externalDependencies);\n});\nfunction* loadPluginDescriptor(descriptor, context) {\n  if (descriptor.value instanceof _plugin.default) {\n    if (descriptor.options) {\n      throw new Error(\"Passed options to an existing Plugin instance will not work.\");\n    }\n    return descriptor.value;\n  }\n  return yield* instantiatePlugin(yield* pluginDescriptorLoader(descriptor, context), context);\n}\nconst needsFilename = val => val && typeof val !== \"function\";\nconst validateIfOptionNeedsFilename = (options, descriptor) => {\n  if (needsFilename(options.test) || needsFilename(options.include) || needsFilename(options.exclude)) {\n    const formattedPresetName = descriptor.name ? `\"${descriptor.name}\"` : \"/* your preset */\";\n    throw new _configError.default([`Preset ${formattedPresetName} requires a filename to be set when babel is called directly,`, `\\`\\`\\``, `babel.transformSync(code, { filename: 'file.ts', presets: [${formattedPresetName}] });`, `\\`\\`\\``, `See https://babeljs.io/docs/en/options#filename for more information.`].join(\"\\n\"));\n  }\n};\nconst validatePreset = (preset, context, descriptor) => {\n  if (!context.filename) {\n    var _options$overrides;\n    const {\n      options\n    } = preset;\n    validateIfOptionNeedsFilename(options, descriptor);\n    (_options$overrides = options.overrides) == null ? void 0 : _options$overrides.forEach(overrideOptions => validateIfOptionNeedsFilename(overrideOptions, descriptor));\n  }\n};\nconst instantiatePreset = (0, _caching.makeWeakCacheSync)(({\n  value,\n  dirname,\n  alias,\n  externalDependencies\n}) => {\n  return {\n    options: (0, _options.validate)(\"preset\", value),\n    alias,\n    dirname,\n    externalDependencies\n  };\n});\nfunction* loadPresetDescriptor(descriptor, context) {\n  const preset = instantiatePreset(yield* presetDescriptorLoader(descriptor, context));\n  validatePreset(preset, context, descriptor);\n  return {\n    chain: yield* (0, _configChain.buildPresetChain)(preset, context),\n    externalDependencies: preset.externalDependencies\n  };\n}\nfunction chain(a, b) {\n  const fns = [a, b].filter(Boolean);\n  if (fns.length <= 1) return fns[0];\n  return function (...args) {\n    for (const fn of fns) {\n      fn.apply(this, args);\n    }\n  };\n}\n0 && 0;\n\n//# sourceMappingURL=full.js.map\n",
    "lib/config/partial.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = loadPrivatePartialConfig;\nexports.loadPartialConfig = loadPartialConfig;\nfunction _path() {\n  const data = require(\"path\");\n  _path = function () {\n    return data;\n  };\n  return data;\n}\nvar _plugin = require(\"./plugin.js\");\nvar _util = require(\"./util.js\");\nvar _item = require(\"./item.js\");\nvar _configChain = require(\"./config-chain.js\");\nvar _environment = require(\"./helpers/environment.js\");\nvar _options = require(\"./validation/options.js\");\nvar _index = require(\"./files/index.js\");\nvar _resolveTargets = require(\"./resolve-targets.js\");\nconst _excluded = [\"showIgnoredFiles\"];\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nfunction resolveRootMode(rootDir, rootMode) {\n  switch (rootMode) {\n    case \"root\":\n      return rootDir;\n    case \"upward-optional\":\n      {\n        const upwardRootDir = (0, _index.findConfigUpwards)(rootDir);\n        return upwardRootDir === null ? rootDir : upwardRootDir;\n      }\n    case \"upward\":\n      {\n        const upwardRootDir = (0, _index.findConfigUpwards)(rootDir);\n        if (upwardRootDir !== null) return upwardRootDir;\n        throw Object.assign(new Error(`Babel was run with rootMode:\"upward\" but a root could not ` + `be found when searching upward from \"${rootDir}\".\\n` + `One of the following config files must be in the directory tree: ` + `\"${_index.ROOT_CONFIG_FILENAMES.join(\", \")}\".`), {\n          code: \"BABEL_ROOT_NOT_FOUND\",\n          dirname: rootDir\n        });\n      }\n    default:\n      throw new Error(`Assertion failure - unknown rootMode value.`);\n  }\n}\nfunction* loadPrivatePartialConfig(inputOpts) {\n  if (inputOpts != null && (typeof inputOpts !== \"object\" || Array.isArray(inputOpts))) {\n    throw new Error(\"Babel options must be an object, null, or undefined\");\n  }\n  const args = inputOpts ? (0, _options.validate)(\"arguments\", inputOpts) : {};\n  const {\n    envName = (0, _environment.getEnv)(),\n    cwd = \".\",\n    root: rootDir = \".\",\n    rootMode = \"root\",\n    caller,\n    cloneInputAst = true\n  } = args;\n  const absoluteCwd = _path().resolve(cwd);\n  const absoluteRootDir = resolveRootMode(_path().resolve(absoluteCwd, rootDir), rootMode);\n  const filename = typeof args.filename === \"string\" ? _path().resolve(cwd, args.filename) : undefined;\n  const showConfigPath = yield* (0, _index.resolveShowConfigPath)(absoluteCwd);\n  const context = {\n    filename,\n    cwd: absoluteCwd,\n    root: absoluteRootDir,\n    envName,\n    caller,\n    showConfig: showConfigPath === filename\n  };\n  const configChain = yield* (0, _configChain.buildRootChain)(args, context);\n  if (!configChain) return null;\n  const merged = {\n    assumptions: {}\n  };\n  configChain.options.forEach(opts => {\n    (0, _util.mergeOptions)(merged, opts);\n  });\n  const options = Object.assign({}, merged, {\n    targets: (0, _resolveTargets.resolveTargets)(merged, absoluteRootDir),\n    cloneInputAst,\n    babelrc: false,\n    configFile: false,\n    browserslistConfigFile: false,\n    passPerPreset: false,\n    envName: context.envName,\n    cwd: context.cwd,\n    root: context.root,\n    rootMode: \"root\",\n    filename: typeof context.filename === \"string\" ? context.filename : undefined,\n    plugins: configChain.plugins.map(descriptor => (0, _item.createItemFromDescriptor)(descriptor)),\n    presets: configChain.presets.map(descriptor => (0, _item.createItemFromDescriptor)(descriptor))\n  });\n  return {\n    options,\n    context,\n    fileHandling: configChain.fileHandling,\n    ignore: configChain.ignore,\n    babelrc: configChain.babelrc,\n    config: configChain.config,\n    files: configChain.files\n  };\n}\nfunction* loadPartialConfig(opts) {\n  let showIgnoredFiles = false;\n  if (typeof opts === \"object\" && opts !== null && !Array.isArray(opts)) {\n    var _opts = opts;\n    ({\n      showIgnoredFiles\n    } = _opts);\n    opts = _objectWithoutPropertiesLoose(_opts, _excluded);\n    _opts;\n  }\n  const result = yield* loadPrivatePartialConfig(opts);\n  if (!result) return null;\n  const {\n    options,\n    babelrc,\n    ignore,\n    config,\n    fileHandling,\n    files\n  } = result;\n  if (fileHandling === \"ignored\" && !showIgnoredFiles) {\n    return null;\n  }\n  (options.plugins || []).forEach(item => {\n    if (item.value instanceof _plugin.default) {\n      throw new Error(\"Passing cached plugin instances is not supported in \" + \"babel.loadPartialConfig()\");\n    }\n  });\n  return new PartialConfig(options, babelrc ? babelrc.filepath : undefined, ignore ? ignore.filepath : undefined, config ? config.filepath : undefined, fileHandling, files);\n}\nclass PartialConfig {\n  constructor(options, babelrc, ignore, config, fileHandling, files) {\n    this.options = void 0;\n    this.babelrc = void 0;\n    this.babelignore = void 0;\n    this.config = void 0;\n    this.fileHandling = void 0;\n    this.files = void 0;\n    this.options = options;\n    this.babelignore = ignore;\n    this.babelrc = babelrc;\n    this.config = config;\n    this.fileHandling = fileHandling;\n    this.files = files;\n    Object.freeze(this);\n  }\n  hasFilesystemConfig() {\n    return this.babelrc !== undefined || this.config !== undefined;\n  }\n}\nObject.freeze(PartialConfig.prototype);\n0 && 0;\n\n//# sourceMappingURL=partial.js.map\n",
    "lib/config/resolve-targets.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveBrowserslistConfigFile = resolveBrowserslistConfigFile;\nexports.resolveTargets = resolveTargets;\nfunction _path() {\n  const data = require(\"path\");\n  _path = function () {\n    return data;\n  };\n  return data;\n}\nfunction _helperCompilationTargets() {\n  const data = require(\"@babel/helper-compilation-targets\");\n  _helperCompilationTargets = function () {\n    return data;\n  };\n  return data;\n}\n({});\nfunction resolveBrowserslistConfigFile(browserslistConfigFile, configFileDir) {\n  return _path().resolve(configFileDir, browserslistConfigFile);\n}\nfunction resolveTargets(options, root) {\n  const optTargets = options.targets;\n  let targets;\n  if (typeof optTargets === \"string\" || Array.isArray(optTargets)) {\n    targets = {\n      browsers: optTargets\n    };\n  } else if (optTargets) {\n    if (\"esmodules\" in optTargets) {\n      targets = Object.assign({}, optTargets, {\n        esmodules: \"intersect\"\n      });\n    } else {\n      targets = optTargets;\n    }\n  }\n  const {\n    browserslistConfigFile\n  } = options;\n  let configFile;\n  let ignoreBrowserslistConfig = false;\n  if (typeof browserslistConfigFile === \"string\") {\n    configFile = browserslistConfigFile;\n  } else {\n    ignoreBrowserslistConfig = browserslistConfigFile === false;\n  }\n  return (0, _helperCompilationTargets().default)(targets, {\n    ignoreBrowserslistConfig,\n    configFile,\n    configPath: root,\n    browserslistEnv: options.browserslistEnv\n  });\n}\n0 && 0;\n\n//# sourceMappingURL=resolve-targets.js.map\n",
    "lib/config/item.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createConfigItem = createConfigItem;\nexports.createItemFromDescriptor = createItemFromDescriptor;\nexports.getItemDescriptor = getItemDescriptor;\nfunction _path() {\n  const data = require(\"path\");\n  _path = function () {\n    return data;\n  };\n  return data;\n}\nvar _configDescriptors = require(\"./config-descriptors.js\");\nfunction createItemFromDescriptor(desc) {\n  return new ConfigItem(desc);\n}\nfunction* createConfigItem(value, {\n  dirname = \".\",\n  type\n} = {}) {\n  const descriptor = yield* (0, _configDescriptors.createDescriptor)(value, _path().resolve(dirname), {\n    type,\n    alias: \"programmatic item\"\n  });\n  return createItemFromDescriptor(descriptor);\n}\nconst CONFIG_ITEM_BRAND = Symbol.for(\"@babel/core@7 - ConfigItem\");\nfunction getItemDescriptor(item) {\n  if (item != null && item[CONFIG_ITEM_BRAND]) {\n    return item._descriptor;\n  }\n  return undefined;\n}\nclass ConfigItem {\n  constructor(descriptor) {\n    this._descriptor = void 0;\n    this[CONFIG_ITEM_BRAND] = true;\n    this.value = void 0;\n    this.options = void 0;\n    this.dirname = void 0;\n    this.name = void 0;\n    this.file = void 0;\n    this._descriptor = descriptor;\n    Object.defineProperty(this, \"_descriptor\", {\n      enumerable: false\n    });\n    Object.defineProperty(this, CONFIG_ITEM_BRAND, {\n      enumerable: false\n    });\n    this.value = this._descriptor.value;\n    this.options = this._descriptor.options;\n    this.dirname = this._descriptor.dirname;\n    this.name = this._descriptor.name;\n    this.file = this._descriptor.file ? {\n      request: this._descriptor.file.request,\n      resolved: this._descriptor.file.resolved\n    } : undefined;\n    Object.freeze(this);\n  }\n}\nObject.freeze(ConfigItem.prototype);\n0 && 0;\n\n//# sourceMappingURL=item.js.map\n",
    "lib/errors/rewrite-stack-trace.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.beginHiddenCallStack = beginHiddenCallStack;\nexports.endHiddenCallStack = endHiddenCallStack;\nexports.expectedError = expectedError;\nexports.injectVirtualStackFrame = injectVirtualStackFrame;\nvar _Object$getOwnPropert;\nconst ErrorToString = Function.call.bind(Error.prototype.toString);\nconst SUPPORTED = !!Error.captureStackTrace && ((_Object$getOwnPropert = Object.getOwnPropertyDescriptor(Error, \"stackTraceLimit\")) == null ? void 0 : _Object$getOwnPropert.writable) === true;\nconst START_HIDING = \"startHiding - secret - don't use this - v1\";\nconst STOP_HIDING = \"stopHiding - secret - don't use this - v1\";\nconst expectedErrors = new WeakSet();\nconst virtualFrames = new WeakMap();\nfunction CallSite(filename) {\n  return Object.create({\n    isNative: () => false,\n    isConstructor: () => false,\n    isToplevel: () => true,\n    getFileName: () => filename,\n    getLineNumber: () => undefined,\n    getColumnNumber: () => undefined,\n    getFunctionName: () => undefined,\n    getMethodName: () => undefined,\n    getTypeName: () => undefined,\n    toString: () => filename\n  });\n}\nfunction injectVirtualStackFrame(error, filename) {\n  if (!SUPPORTED) return;\n  let frames = virtualFrames.get(error);\n  if (!frames) virtualFrames.set(error, frames = []);\n  frames.push(CallSite(filename));\n  return error;\n}\nfunction expectedError(error) {\n  if (!SUPPORTED) return;\n  expectedErrors.add(error);\n  return error;\n}\nfunction beginHiddenCallStack(fn) {\n  if (!SUPPORTED) return fn;\n  return Object.defineProperty(function (...args) {\n    setupPrepareStackTrace();\n    return fn(...args);\n  }, \"name\", {\n    value: STOP_HIDING\n  });\n}\nfunction endHiddenCallStack(fn) {\n  if (!SUPPORTED) return fn;\n  return Object.defineProperty(function (...args) {\n    return fn(...args);\n  }, \"name\", {\n    value: START_HIDING\n  });\n}\nfunction setupPrepareStackTrace() {\n  setupPrepareStackTrace = () => {};\n  const {\n    prepareStackTrace = defaultPrepareStackTrace\n  } = Error;\n  const MIN_STACK_TRACE_LIMIT = 50;\n  Error.stackTraceLimit && (Error.stackTraceLimit = Math.max(Error.stackTraceLimit, MIN_STACK_TRACE_LIMIT));\n  Error.prepareStackTrace = function stackTraceRewriter(err, trace) {\n    let newTrace = [];\n    const isExpected = expectedErrors.has(err);\n    let status = isExpected ? \"hiding\" : \"unknown\";\n    for (let i = 0; i < trace.length; i++) {\n      const name = trace[i].getFunctionName();\n      if (name === START_HIDING) {\n        status = \"hiding\";\n      } else if (name === STOP_HIDING) {\n        if (status === \"hiding\") {\n          status = \"showing\";\n          if (virtualFrames.has(err)) {\n            newTrace.unshift(...virtualFrames.get(err));\n          }\n        } else if (status === \"unknown\") {\n          newTrace = trace;\n          break;\n        }\n      } else if (status !== \"hiding\") {\n        newTrace.push(trace[i]);\n      }\n    }\n    return prepareStackTrace(err, newTrace);\n  };\n}\nfunction defaultPrepareStackTrace(err, trace) {\n  if (trace.length === 0) return ErrorToString(err);\n  return `${ErrorToString(err)}\\n    at ${trace.join(\"\\n    at \")}`;\n}\n0 && 0;\n\n//# sourceMappingURL=rewrite-stack-trace.js.map\n",
    "lib/transformation/index.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.run = run;\nfunction _traverse() {\n  const data = require(\"@babel/traverse\");\n  _traverse = function () {\n    return data;\n  };\n  return data;\n}\nvar _pluginPass = require(\"./plugin-pass.js\");\nvar _blockHoistPlugin = require(\"./block-hoist-plugin.js\");\nvar _normalizeOpts = require(\"./normalize-opts.js\");\nvar _normalizeFile = require(\"./normalize-file.js\");\nvar _generate = require(\"./file/generate.js\");\nvar _deepArray = require(\"../config/helpers/deep-array.js\");\nfunction* run(config, code, ast) {\n  const file = yield* (0, _normalizeFile.default)(config.passes, (0, _normalizeOpts.default)(config), code, ast);\n  const opts = file.opts;\n  try {\n    yield* transformFile(file, config.passes);\n  } catch (e) {\n    var _opts$filename;\n    e.message = `${(_opts$filename = opts.filename) != null ? _opts$filename : \"unknown file\"}: ${e.message}`;\n    if (!e.code) {\n      e.code = \"BABEL_TRANSFORM_ERROR\";\n    }\n    throw e;\n  }\n  let outputCode, outputMap;\n  try {\n    if (opts.code !== false) {\n      ({\n        outputCode,\n        outputMap\n      } = (0, _generate.default)(config.passes, file));\n    }\n  } catch (e) {\n    var _opts$filename2;\n    e.message = `${(_opts$filename2 = opts.filename) != null ? _opts$filename2 : \"unknown file\"}: ${e.message}`;\n    if (!e.code) {\n      e.code = \"BABEL_GENERATE_ERROR\";\n    }\n    throw e;\n  }\n  return {\n    metadata: file.metadata,\n    options: opts,\n    ast: opts.ast === true ? file.ast : null,\n    code: outputCode === undefined ? null : outputCode,\n    map: outputMap === undefined ? null : outputMap,\n    sourceType: file.ast.program.sourceType,\n    externalDependencies: (0, _deepArray.flattenToSet)(config.externalDependencies)\n  };\n}\nfunction* transformFile(file, pluginPasses) {\n  for (const pluginPairs of pluginPasses) {\n    const passPairs = [];\n    const passes = [];\n    const visitors = [];\n    for (const plugin of pluginPairs.concat([(0, _blockHoistPlugin.default)()])) {\n      const pass = new _pluginPass.default(file, plugin.key, plugin.options);\n      passPairs.push([plugin, pass]);\n      passes.push(pass);\n      visitors.push(plugin.visitor);\n    }\n    for (const [plugin, pass] of passPairs) {\n      const fn = plugin.pre;\n      if (fn) {\n        const result = fn.call(pass, file);\n        yield* [];\n        if (isThenable(result)) {\n          throw new Error(`You appear to be using an plugin with an async .pre, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, you may need to upgrade ` + `your @babel/core version.`);\n        }\n      }\n    }\n    const visitor = _traverse().default.visitors.merge(visitors, passes, file.opts.wrapPluginVisitorMethod);\n    {\n      (0, _traverse().default)(file.ast, visitor, file.scope);\n    }\n    for (const [plugin, pass] of passPairs) {\n      const fn = plugin.post;\n      if (fn) {\n        const result = fn.call(pass, file);\n        yield* [];\n        if (isThenable(result)) {\n          throw new Error(`You appear to be using an plugin with an async .post, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, you may need to upgrade ` + `your @babel/core version.`);\n        }\n      }\n    }\n  }\n}\nfunction isThenable(val) {\n  return !!val && (typeof val === \"object\" || typeof val === \"function\") && !!val.then && typeof val.then === \"function\";\n}\n0 && 0;\n\n//# sourceMappingURL=index.js.map\n",
    "lib/parser/index.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = parser;\nfunction _parser() {\n  const data = require(\"@babel/parser\");\n  _parser = function () {\n    return data;\n  };\n  return data;\n}\nfunction _codeFrame() {\n  const data = require(\"@babel/code-frame\");\n  _codeFrame = function () {\n    return data;\n  };\n  return data;\n}\nvar _missingPluginHelper = require(\"./util/missing-plugin-helper.js\");\nfunction* parser(pluginPasses, {\n  parserOpts,\n  highlightCode = true,\n  filename = \"unknown\"\n}, code) {\n  try {\n    const results = [];\n    for (const plugins of pluginPasses) {\n      for (const plugin of plugins) {\n        const {\n          parserOverride\n        } = plugin;\n        if (parserOverride) {\n          const ast = parserOverride(code, parserOpts, _parser().parse);\n          if (ast !== undefined) results.push(ast);\n        }\n      }\n    }\n    if (results.length === 0) {\n      return (0, _parser().parse)(code, parserOpts);\n    } else if (results.length === 1) {\n      yield* [];\n      if (typeof results[0].then === \"function\") {\n        throw new Error(`You appear to be using an async parser plugin, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, you may need to upgrade ` + `your @babel/core version.`);\n      }\n      return results[0];\n    }\n    throw new Error(\"More than one plugin attempted to override parsing.\");\n  } catch (err) {\n    if (err.code === \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\") {\n      err.message += \"\\nConsider renaming the file to '.mjs', or setting sourceType:module \" + \"or sourceType:unambiguous in your Babel config for this file.\";\n    }\n    const {\n      loc,\n      missingPlugin\n    } = err;\n    if (loc) {\n      const codeFrame = (0, _codeFrame().codeFrameColumns)(code, {\n        start: {\n          line: loc.line,\n          column: loc.column + 1\n        }\n      }, {\n        highlightCode\n      });\n      if (missingPlugin) {\n        err.message = `${filename}: ` + (0, _missingPluginHelper.default)(missingPlugin[0], loc, codeFrame);\n      } else {\n        err.message = `${filename}: ${err.message}\\n\\n` + codeFrame;\n      }\n      err.code = \"BABEL_PARSE_ERROR\";\n    }\n    throw err;\n  }\n}\n0 && 0;\n\n//# sourceMappingURL=index.js.map\n",
    "lib/transformation/normalize-opts.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = normalizeOptions;\nfunction _path() {\n  const data = require(\"path\");\n  _path = function () {\n    return data;\n  };\n  return data;\n}\nfunction normalizeOptions(config) {\n  const {\n    filename,\n    cwd,\n    filenameRelative = typeof filename === \"string\" ? _path().relative(cwd, filename) : \"unknown\",\n    sourceType = \"module\",\n    inputSourceMap,\n    sourceMaps = !!inputSourceMap,\n    sourceRoot = config.options.moduleRoot,\n    sourceFileName = _path().basename(filenameRelative),\n    comments = true,\n    compact = \"auto\"\n  } = config.options;\n  const opts = config.options;\n  const options = Object.assign({}, opts, {\n    parserOpts: Object.assign({\n      sourceType: _path().extname(filenameRelative) === \".mjs\" ? \"module\" : sourceType,\n      sourceFileName: filename,\n      plugins: []\n    }, opts.parserOpts),\n    generatorOpts: Object.assign({\n      filename,\n      auxiliaryCommentBefore: opts.auxiliaryCommentBefore,\n      auxiliaryCommentAfter: opts.auxiliaryCommentAfter,\n      retainLines: opts.retainLines,\n      comments,\n      shouldPrintComment: opts.shouldPrintComment,\n      compact,\n      minified: opts.minified,\n      sourceMaps,\n      sourceRoot,\n      sourceFileName\n    }, opts.generatorOpts)\n  });\n  for (const plugins of config.passes) {\n    for (const plugin of plugins) {\n      if (plugin.manipulateOptions) {\n        plugin.manipulateOptions(options, options.parserOpts);\n      }\n    }\n  }\n  return options;\n}\n0 && 0;\n\n//# sourceMappingURL=normalize-opts.js.map\n",
    "lib/gensync-utils/async.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.forwardAsync = forwardAsync;\nexports.isAsync = void 0;\nexports.isThenable = isThenable;\nexports.maybeAsync = maybeAsync;\nexports.waitFor = exports.onFirstPause = void 0;\nfunction _gensync() {\n  const data = require(\"gensync\");\n  _gensync = function () {\n    return data;\n  };\n  return data;\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nconst runGenerator = _gensync()(function* (item) {\n  return yield* item;\n});\nconst isAsync = _gensync()({\n  sync: () => false,\n  errback: cb => cb(null, true)\n});\nexports.isAsync = isAsync;\nfunction maybeAsync(fn, message) {\n  return _gensync()({\n    sync(...args) {\n      const result = fn.apply(this, args);\n      if (isThenable(result)) throw new Error(message);\n      return result;\n    },\n    async(...args) {\n      return Promise.resolve(fn.apply(this, args));\n    }\n  });\n}\nconst withKind = _gensync()({\n  sync: cb => cb(\"sync\"),\n  async: function () {\n    var _ref = _asyncToGenerator(function* (cb) {\n      return cb(\"async\");\n    });\n    return function async(_x) {\n      return _ref.apply(this, arguments);\n    };\n  }()\n});\nfunction forwardAsync(action, cb) {\n  const g = _gensync()(action);\n  return withKind(kind => {\n    const adapted = g[kind];\n    return cb(adapted);\n  });\n}\nconst onFirstPause = _gensync()({\n  name: \"onFirstPause\",\n  arity: 2,\n  sync: function (item) {\n    return runGenerator.sync(item);\n  },\n  errback: function (item, firstPause, cb) {\n    let completed = false;\n    runGenerator.errback(item, (err, value) => {\n      completed = true;\n      cb(err, value);\n    });\n    if (!completed) {\n      firstPause();\n    }\n  }\n});\nexports.onFirstPause = onFirstPause;\nconst waitFor = _gensync()({\n  sync: x => x,\n  async: function () {\n    var _ref2 = _asyncToGenerator(function* (x) {\n      return x;\n    });\n    return function async(_x2) {\n      return _ref2.apply(this, arguments);\n    };\n  }()\n});\nexports.waitFor = waitFor;\nfunction isThenable(val) {\n  return !!val && (typeof val === \"object\" || typeof val === \"function\") && !!val.then && typeof val.then === \"function\";\n}\n0 && 0;\n\n//# sourceMappingURL=async.js.map\n",
    "lib/config/util.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isIterableIterator = isIterableIterator;\nexports.mergeOptions = mergeOptions;\nfunction mergeOptions(target, source) {\n  for (const k of Object.keys(source)) {\n    if ((k === \"parserOpts\" || k === \"generatorOpts\" || k === \"assumptions\") && source[k]) {\n      const parserOpts = source[k];\n      const targetObj = target[k] || (target[k] = {});\n      mergeDefaultFields(targetObj, parserOpts);\n    } else {\n      const val = source[k];\n      if (val !== undefined) target[k] = val;\n    }\n  }\n}\nfunction mergeDefaultFields(target, source) {\n  for (const k of Object.keys(source)) {\n    const val = source[k];\n    if (val !== undefined) target[k] = val;\n  }\n}\nfunction isIterableIterator(value) {\n  return !!value && typeof value.next === \"function\" && typeof value[Symbol.iterator] === \"function\";\n}\n0 && 0;\n\n//# sourceMappingURL=util.js.map\n",
    "lib/config/plugin.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _deepArray = require(\"./helpers/deep-array.js\");\nclass Plugin {\n  constructor(plugin, options, key, externalDependencies = (0, _deepArray.finalize)([])) {\n    this.key = void 0;\n    this.manipulateOptions = void 0;\n    this.post = void 0;\n    this.pre = void 0;\n    this.visitor = void 0;\n    this.parserOverride = void 0;\n    this.generatorOverride = void 0;\n    this.options = void 0;\n    this.externalDependencies = void 0;\n    this.key = plugin.name || key;\n    this.manipulateOptions = plugin.manipulateOptions;\n    this.post = plugin.post;\n    this.pre = plugin.pre;\n    this.visitor = plugin.visitor || {};\n    this.parserOverride = plugin.parserOverride;\n    this.generatorOverride = plugin.generatorOverride;\n    this.options = options;\n    this.externalDependencies = externalDependencies;\n  }\n}\nexports.default = Plugin;\n0 && 0;\n\n//# sourceMappingURL=plugin.js.map\n",
    "lib/config/config-chain.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildPresetChain = buildPresetChain;\nexports.buildPresetChainWalker = void 0;\nexports.buildRootChain = buildRootChain;\nfunction _path() {\n  const data = require(\"path\");\n  _path = function () {\n    return data;\n  };\n  return data;\n}\nfunction _debug() {\n  const data = require(\"debug\");\n  _debug = function () {\n    return data;\n  };\n  return data;\n}\nvar _options = require(\"./validation/options.js\");\nvar _patternToRegex = require(\"./pattern-to-regex.js\");\nvar _printer = require(\"./printer.js\");\nvar _rewriteStackTrace = require(\"../errors/rewrite-stack-trace.js\");\nvar _configError = require(\"../errors/config-error.js\");\nvar _index = require(\"./files/index.js\");\nvar _caching = require(\"./caching.js\");\nvar _configDescriptors = require(\"./config-descriptors.js\");\nconst debug = _debug()(\"babel:config:config-chain\");\nfunction* buildPresetChain(arg, context) {\n  const chain = yield* buildPresetChainWalker(arg, context);\n  if (!chain) return null;\n  return {\n    plugins: dedupDescriptors(chain.plugins),\n    presets: dedupDescriptors(chain.presets),\n    options: chain.options.map(o => normalizeOptions(o)),\n    files: new Set()\n  };\n}\nconst buildPresetChainWalker = makeChainWalker({\n  root: preset => loadPresetDescriptors(preset),\n  env: (preset, envName) => loadPresetEnvDescriptors(preset)(envName),\n  overrides: (preset, index) => loadPresetOverridesDescriptors(preset)(index),\n  overridesEnv: (preset, index, envName) => loadPresetOverridesEnvDescriptors(preset)(index)(envName),\n  createLogger: () => () => {}\n});\nexports.buildPresetChainWalker = buildPresetChainWalker;\nconst loadPresetDescriptors = (0, _caching.makeWeakCacheSync)(preset => buildRootDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors));\nconst loadPresetEnvDescriptors = (0, _caching.makeWeakCacheSync)(preset => (0, _caching.makeStrongCacheSync)(envName => buildEnvDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, envName)));\nconst loadPresetOverridesDescriptors = (0, _caching.makeWeakCacheSync)(preset => (0, _caching.makeStrongCacheSync)(index => buildOverrideDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, index)));\nconst loadPresetOverridesEnvDescriptors = (0, _caching.makeWeakCacheSync)(preset => (0, _caching.makeStrongCacheSync)(index => (0, _caching.makeStrongCacheSync)(envName => buildOverrideEnvDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, index, envName))));\nfunction* buildRootChain(opts, context) {\n  let configReport, babelRcReport;\n  const programmaticLogger = new _printer.ConfigPrinter();\n  const programmaticChain = yield* loadProgrammaticChain({\n    options: opts,\n    dirname: context.cwd\n  }, context, undefined, programmaticLogger);\n  if (!programmaticChain) return null;\n  const programmaticReport = yield* programmaticLogger.output();\n  let configFile;\n  if (typeof opts.configFile === \"string\") {\n    configFile = yield* (0, _index.loadConfig)(opts.configFile, context.cwd, context.envName, context.caller);\n  } else if (opts.configFile !== false) {\n    configFile = yield* (0, _index.findRootConfig)(context.root, context.envName, context.caller);\n  }\n  let {\n    babelrc,\n    babelrcRoots\n  } = opts;\n  let babelrcRootsDirectory = context.cwd;\n  const configFileChain = emptyChain();\n  const configFileLogger = new _printer.ConfigPrinter();\n  if (configFile) {\n    const validatedFile = validateConfigFile(configFile);\n    const result = yield* loadFileChain(validatedFile, context, undefined, configFileLogger);\n    if (!result) return null;\n    configReport = yield* configFileLogger.output();\n    if (babelrc === undefined) {\n      babelrc = validatedFile.options.babelrc;\n    }\n    if (babelrcRoots === undefined) {\n      babelrcRootsDirectory = validatedFile.dirname;\n      babelrcRoots = validatedFile.options.babelrcRoots;\n    }\n    mergeChain(configFileChain, result);\n  }\n  let ignoreFile, babelrcFile;\n  let isIgnored = false;\n  const fileChain = emptyChain();\n  if ((babelrc === true || babelrc === undefined) && typeof context.filename === \"string\") {\n    const pkgData = yield* (0, _index.findPackageData)(context.filename);\n    if (pkgData && babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory)) {\n      ({\n        ignore: ignoreFile,\n        config: babelrcFile\n      } = yield* (0, _index.findRelativeConfig)(pkgData, context.envName, context.caller));\n      if (ignoreFile) {\n        fileChain.files.add(ignoreFile.filepath);\n      }\n      if (ignoreFile && shouldIgnore(context, ignoreFile.ignore, null, ignoreFile.dirname)) {\n        isIgnored = true;\n      }\n      if (babelrcFile && !isIgnored) {\n        const validatedFile = validateBabelrcFile(babelrcFile);\n        const babelrcLogger = new _printer.ConfigPrinter();\n        const result = yield* loadFileChain(validatedFile, context, undefined, babelrcLogger);\n        if (!result) {\n          isIgnored = true;\n        } else {\n          babelRcReport = yield* babelrcLogger.output();\n          mergeChain(fileChain, result);\n        }\n      }\n      if (babelrcFile && isIgnored) {\n        fileChain.files.add(babelrcFile.filepath);\n      }\n    }\n  }\n  if (context.showConfig) {\n    console.log(`Babel configs on \"${context.filename}\" (ascending priority):\\n` + [configReport, babelRcReport, programmaticReport].filter(x => !!x).join(\"\\n\\n\") + \"\\n-----End Babel configs-----\");\n  }\n  const chain = mergeChain(mergeChain(mergeChain(emptyChain(), configFileChain), fileChain), programmaticChain);\n  return {\n    plugins: isIgnored ? [] : dedupDescriptors(chain.plugins),\n    presets: isIgnored ? [] : dedupDescriptors(chain.presets),\n    options: isIgnored ? [] : chain.options.map(o => normalizeOptions(o)),\n    fileHandling: isIgnored ? \"ignored\" : \"transpile\",\n    ignore: ignoreFile || undefined,\n    babelrc: babelrcFile || undefined,\n    config: configFile || undefined,\n    files: chain.files\n  };\n}\nfunction babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory) {\n  if (typeof babelrcRoots === \"boolean\") return babelrcRoots;\n  const absoluteRoot = context.root;\n  if (babelrcRoots === undefined) {\n    return pkgData.directories.indexOf(absoluteRoot) !== -1;\n  }\n  let babelrcPatterns = babelrcRoots;\n  if (!Array.isArray(babelrcPatterns)) {\n    babelrcPatterns = [babelrcPatterns];\n  }\n  babelrcPatterns = babelrcPatterns.map(pat => {\n    return typeof pat === \"string\" ? _path().resolve(babelrcRootsDirectory, pat) : pat;\n  });\n  if (babelrcPatterns.length === 1 && babelrcPatterns[0] === absoluteRoot) {\n    return pkgData.directories.indexOf(absoluteRoot) !== -1;\n  }\n  return babelrcPatterns.some(pat => {\n    if (typeof pat === \"string\") {\n      pat = (0, _patternToRegex.default)(pat, babelrcRootsDirectory);\n    }\n    return pkgData.directories.some(directory => {\n      return matchPattern(pat, babelrcRootsDirectory, directory, context);\n    });\n  });\n}\nconst validateConfigFile = (0, _caching.makeWeakCacheSync)(file => ({\n  filepath: file.filepath,\n  dirname: file.dirname,\n  options: (0, _options.validate)(\"configfile\", file.options, file.filepath)\n}));\nconst validateBabelrcFile = (0, _caching.makeWeakCacheSync)(file => ({\n  filepath: file.filepath,\n  dirname: file.dirname,\n  options: (0, _options.validate)(\"babelrcfile\", file.options, file.filepath)\n}));\nconst validateExtendFile = (0, _caching.makeWeakCacheSync)(file => ({\n  filepath: file.filepath,\n  dirname: file.dirname,\n  options: (0, _options.validate)(\"extendsfile\", file.options, file.filepath)\n}));\nconst loadProgrammaticChain = makeChainWalker({\n  root: input => buildRootDescriptors(input, \"base\", _configDescriptors.createCachedDescriptors),\n  env: (input, envName) => buildEnvDescriptors(input, \"base\", _configDescriptors.createCachedDescriptors, envName),\n  overrides: (input, index) => buildOverrideDescriptors(input, \"base\", _configDescriptors.createCachedDescriptors, index),\n  overridesEnv: (input, index, envName) => buildOverrideEnvDescriptors(input, \"base\", _configDescriptors.createCachedDescriptors, index, envName),\n  createLogger: (input, context, baseLogger) => buildProgrammaticLogger(input, context, baseLogger)\n});\nconst loadFileChainWalker = makeChainWalker({\n  root: file => loadFileDescriptors(file),\n  env: (file, envName) => loadFileEnvDescriptors(file)(envName),\n  overrides: (file, index) => loadFileOverridesDescriptors(file)(index),\n  overridesEnv: (file, index, envName) => loadFileOverridesEnvDescriptors(file)(index)(envName),\n  createLogger: (file, context, baseLogger) => buildFileLogger(file.filepath, context, baseLogger)\n});\nfunction* loadFileChain(input, context, files, baseLogger) {\n  const chain = yield* loadFileChainWalker(input, context, files, baseLogger);\n  chain == null ? void 0 : chain.files.add(input.filepath);\n  return chain;\n}\nconst loadFileDescriptors = (0, _caching.makeWeakCacheSync)(file => buildRootDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors));\nconst loadFileEnvDescriptors = (0, _caching.makeWeakCacheSync)(file => (0, _caching.makeStrongCacheSync)(envName => buildEnvDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, envName)));\nconst loadFileOverridesDescriptors = (0, _caching.makeWeakCacheSync)(file => (0, _caching.makeStrongCacheSync)(index => buildOverrideDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, index)));\nconst loadFileOverridesEnvDescriptors = (0, _caching.makeWeakCacheSync)(file => (0, _caching.makeStrongCacheSync)(index => (0, _caching.makeStrongCacheSync)(envName => buildOverrideEnvDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, index, envName))));\nfunction buildFileLogger(filepath, context, baseLogger) {\n  if (!baseLogger) {\n    return () => {};\n  }\n  return baseLogger.configure(context.showConfig, _printer.ChainFormatter.Config, {\n    filepath\n  });\n}\nfunction buildRootDescriptors({\n  dirname,\n  options\n}, alias, descriptors) {\n  return descriptors(dirname, options, alias);\n}\nfunction buildProgrammaticLogger(_, context, baseLogger) {\n  var _context$caller;\n  if (!baseLogger) {\n    return () => {};\n  }\n  return baseLogger.configure(context.showConfig, _printer.ChainFormatter.Programmatic, {\n    callerName: (_context$caller = context.caller) == null ? void 0 : _context$caller.name\n  });\n}\nfunction buildEnvDescriptors({\n  dirname,\n  options\n}, alias, descriptors, envName) {\n  var _options$env;\n  const opts = (_options$env = options.env) == null ? void 0 : _options$env[envName];\n  return opts ? descriptors(dirname, opts, `${alias}.env[\"${envName}\"]`) : null;\n}\nfunction buildOverrideDescriptors({\n  dirname,\n  options\n}, alias, descriptors, index) {\n  var _options$overrides;\n  const opts = (_options$overrides = options.overrides) == null ? void 0 : _options$overrides[index];\n  if (!opts) throw new Error(\"Assertion failure - missing override\");\n  return descriptors(dirname, opts, `${alias}.overrides[${index}]`);\n}\nfunction buildOverrideEnvDescriptors({\n  dirname,\n  options\n}, alias, descriptors, index, envName) {\n  var _options$overrides2, _override$env;\n  const override = (_options$overrides2 = options.overrides) == null ? void 0 : _options$overrides2[index];\n  if (!override) throw new Error(\"Assertion failure - missing override\");\n  const opts = (_override$env = override.env) == null ? void 0 : _override$env[envName];\n  return opts ? descriptors(dirname, opts, `${alias}.overrides[${index}].env[\"${envName}\"]`) : null;\n}\nfunction makeChainWalker({\n  root,\n  env,\n  overrides,\n  overridesEnv,\n  createLogger\n}) {\n  return function* chainWalker(input, context, files = new Set(), baseLogger) {\n    const {\n      dirname\n    } = input;\n    const flattenedConfigs = [];\n    const rootOpts = root(input);\n    if (configIsApplicable(rootOpts, dirname, context, input.filepath)) {\n      flattenedConfigs.push({\n        config: rootOpts,\n        envName: undefined,\n        index: undefined\n      });\n      const envOpts = env(input, context.envName);\n      if (envOpts && configIsApplicable(envOpts, dirname, context, input.filepath)) {\n        flattenedConfigs.push({\n          config: envOpts,\n          envName: context.envName,\n          index: undefined\n        });\n      }\n      (rootOpts.options.overrides || []).forEach((_, index) => {\n        const overrideOps = overrides(input, index);\n        if (configIsApplicable(overrideOps, dirname, context, input.filepath)) {\n          flattenedConfigs.push({\n            config: overrideOps,\n            index,\n            envName: undefined\n          });\n          const overrideEnvOpts = overridesEnv(input, index, context.envName);\n          if (overrideEnvOpts && configIsApplicable(overrideEnvOpts, dirname, context, input.filepath)) {\n            flattenedConfigs.push({\n              config: overrideEnvOpts,\n              index,\n              envName: context.envName\n            });\n          }\n        }\n      });\n    }\n    if (flattenedConfigs.some(({\n      config: {\n        options: {\n          ignore,\n          only\n        }\n      }\n    }) => shouldIgnore(context, ignore, only, dirname))) {\n      return null;\n    }\n    const chain = emptyChain();\n    const logger = createLogger(input, context, baseLogger);\n    for (const {\n      config,\n      index,\n      envName\n    } of flattenedConfigs) {\n      if (!(yield* mergeExtendsChain(chain, config.options, dirname, context, files, baseLogger))) {\n        return null;\n      }\n      logger(config, index, envName);\n      yield* mergeChainOpts(chain, config);\n    }\n    return chain;\n  };\n}\nfunction* mergeExtendsChain(chain, opts, dirname, context, files, baseLogger) {\n  if (opts.extends === undefined) return true;\n  const file = yield* (0, _index.loadConfig)(opts.extends, dirname, context.envName, context.caller);\n  if (files.has(file)) {\n    throw new Error(`Configuration cycle detected loading ${file.filepath}.\\n` + `File already loaded following the config chain:\\n` + Array.from(files, file => ` - ${file.filepath}`).join(\"\\n\"));\n  }\n  files.add(file);\n  const fileChain = yield* loadFileChain(validateExtendFile(file), context, files, baseLogger);\n  files.delete(file);\n  if (!fileChain) return false;\n  mergeChain(chain, fileChain);\n  return true;\n}\nfunction mergeChain(target, source) {\n  target.options.push(...source.options);\n  target.plugins.push(...source.plugins);\n  target.presets.push(...source.presets);\n  for (const file of source.files) {\n    target.files.add(file);\n  }\n  return target;\n}\nfunction* mergeChainOpts(target, {\n  options,\n  plugins,\n  presets\n}) {\n  target.options.push(options);\n  target.plugins.push(...(yield* plugins()));\n  target.presets.push(...(yield* presets()));\n  return target;\n}\nfunction emptyChain() {\n  return {\n    options: [],\n    presets: [],\n    plugins: [],\n    files: new Set()\n  };\n}\nfunction normalizeOptions(opts) {\n  const options = Object.assign({}, opts);\n  delete options.extends;\n  delete options.env;\n  delete options.overrides;\n  delete options.plugins;\n  delete options.presets;\n  delete options.passPerPreset;\n  delete options.ignore;\n  delete options.only;\n  delete options.test;\n  delete options.include;\n  delete options.exclude;\n  if (Object.prototype.hasOwnProperty.call(options, \"sourceMap\")) {\n    options.sourceMaps = options.sourceMap;\n    delete options.sourceMap;\n  }\n  return options;\n}\nfunction dedupDescriptors(items) {\n  const map = new Map();\n  const descriptors = [];\n  for (const item of items) {\n    if (typeof item.value === \"function\") {\n      const fnKey = item.value;\n      let nameMap = map.get(fnKey);\n      if (!nameMap) {\n        nameMap = new Map();\n        map.set(fnKey, nameMap);\n      }\n      let desc = nameMap.get(item.name);\n      if (!desc) {\n        desc = {\n          value: item\n        };\n        descriptors.push(desc);\n        if (!item.ownPass) nameMap.set(item.name, desc);\n      } else {\n        desc.value = item;\n      }\n    } else {\n      descriptors.push({\n        value: item\n      });\n    }\n  }\n  return descriptors.reduce((acc, desc) => {\n    acc.push(desc.value);\n    return acc;\n  }, []);\n}\nfunction configIsApplicable({\n  options\n}, dirname, context, configName) {\n  return (options.test === undefined || configFieldIsApplicable(context, options.test, dirname, configName)) && (options.include === undefined || configFieldIsApplicable(context, options.include, dirname, configName)) && (options.exclude === undefined || !configFieldIsApplicable(context, options.exclude, dirname, configName));\n}\nfunction configFieldIsApplicable(context, test, dirname, configName) {\n  const patterns = Array.isArray(test) ? test : [test];\n  return matchesPatterns(context, patterns, dirname, configName);\n}\nfunction ignoreListReplacer(_key, value) {\n  if (value instanceof RegExp) {\n    return String(value);\n  }\n  return value;\n}\nfunction shouldIgnore(context, ignore, only, dirname) {\n  if (ignore && matchesPatterns(context, ignore, dirname)) {\n    var _context$filename;\n    const message = `No config is applied to \"${(_context$filename = context.filename) != null ? _context$filename : \"(unknown)\"}\" because it matches one of \\`ignore: ${JSON.stringify(ignore, ignoreListReplacer)}\\` from \"${dirname}\"`;\n    debug(message);\n    if (context.showConfig) {\n      console.log(message);\n    }\n    return true;\n  }\n  if (only && !matchesPatterns(context, only, dirname)) {\n    var _context$filename2;\n    const message = `No config is applied to \"${(_context$filename2 = context.filename) != null ? _context$filename2 : \"(unknown)\"}\" because it fails to match one of \\`only: ${JSON.stringify(only, ignoreListReplacer)}\\` from \"${dirname}\"`;\n    debug(message);\n    if (context.showConfig) {\n      console.log(message);\n    }\n    return true;\n  }\n  return false;\n}\nfunction matchesPatterns(context, patterns, dirname, configName) {\n  return patterns.some(pattern => matchPattern(pattern, dirname, context.filename, context, configName));\n}\nfunction matchPattern(pattern, dirname, pathToTest, context, configName) {\n  if (typeof pattern === \"function\") {\n    return !!(0, _rewriteStackTrace.endHiddenCallStack)(pattern)(pathToTest, {\n      dirname,\n      envName: context.envName,\n      caller: context.caller\n    });\n  }\n  if (typeof pathToTest !== \"string\") {\n    throw new _configError.default(`Configuration contains string/RegExp pattern, but no filename was passed to Babel`, configName);\n  }\n  if (typeof pattern === \"string\") {\n    pattern = (0, _patternToRegex.default)(pattern, dirname);\n  }\n  return pattern.test(pathToTest);\n}\n0 && 0;\n\n//# sourceMappingURL=config-chain.js.map\n",
    "lib/config/helpers/deep-array.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.finalize = finalize;\nexports.flattenToSet = flattenToSet;\nfunction finalize(deepArr) {\n  return Object.freeze(deepArr);\n}\nfunction flattenToSet(arr) {\n  const result = new Set();\n  const stack = [arr];\n  while (stack.length > 0) {\n    for (const el of stack.pop()) {\n      if (Array.isArray(el)) stack.push(el);else result.add(el);\n    }\n  }\n  return result;\n}\n0 && 0;\n\n//# sourceMappingURL=deep-array.js.map\n",
    "lib/config/caching.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertSimpleType = assertSimpleType;\nexports.makeStrongCache = makeStrongCache;\nexports.makeStrongCacheSync = makeStrongCacheSync;\nexports.makeWeakCache = makeWeakCache;\nexports.makeWeakCacheSync = makeWeakCacheSync;\nfunction _gensync() {\n  const data = require(\"gensync\");\n  _gensync = function () {\n    return data;\n  };\n  return data;\n}\nvar _async = require(\"../gensync-utils/async.js\");\nvar _util = require(\"./util.js\");\nconst synchronize = gen => {\n  return _gensync()(gen).sync;\n};\nfunction* genTrue() {\n  return true;\n}\nfunction makeWeakCache(handler) {\n  return makeCachedFunction(WeakMap, handler);\n}\nfunction makeWeakCacheSync(handler) {\n  return synchronize(makeWeakCache(handler));\n}\nfunction makeStrongCache(handler) {\n  return makeCachedFunction(Map, handler);\n}\nfunction makeStrongCacheSync(handler) {\n  return synchronize(makeStrongCache(handler));\n}\nfunction makeCachedFunction(CallCache, handler) {\n  const callCacheSync = new CallCache();\n  const callCacheAsync = new CallCache();\n  const futureCache = new CallCache();\n  return function* cachedFunction(arg, data) {\n    const asyncContext = yield* (0, _async.isAsync)();\n    const callCache = asyncContext ? callCacheAsync : callCacheSync;\n    const cached = yield* getCachedValueOrWait(asyncContext, callCache, futureCache, arg, data);\n    if (cached.valid) return cached.value;\n    const cache = new CacheConfigurator(data);\n    const handlerResult = handler(arg, cache);\n    let finishLock;\n    let value;\n    if ((0, _util.isIterableIterator)(handlerResult)) {\n      value = yield* (0, _async.onFirstPause)(handlerResult, () => {\n        finishLock = setupAsyncLocks(cache, futureCache, arg);\n      });\n    } else {\n      value = handlerResult;\n    }\n    updateFunctionCache(callCache, cache, arg, value);\n    if (finishLock) {\n      futureCache.delete(arg);\n      finishLock.release(value);\n    }\n    return value;\n  };\n}\nfunction* getCachedValue(cache, arg, data) {\n  const cachedValue = cache.get(arg);\n  if (cachedValue) {\n    for (const {\n      value,\n      valid\n    } of cachedValue) {\n      if (yield* valid(data)) return {\n        valid: true,\n        value\n      };\n    }\n  }\n  return {\n    valid: false,\n    value: null\n  };\n}\nfunction* getCachedValueOrWait(asyncContext, callCache, futureCache, arg, data) {\n  const cached = yield* getCachedValue(callCache, arg, data);\n  if (cached.valid) {\n    return cached;\n  }\n  if (asyncContext) {\n    const cached = yield* getCachedValue(futureCache, arg, data);\n    if (cached.valid) {\n      const value = yield* (0, _async.waitFor)(cached.value.promise);\n      return {\n        valid: true,\n        value\n      };\n    }\n  }\n  return {\n    valid: false,\n    value: null\n  };\n}\nfunction setupAsyncLocks(config, futureCache, arg) {\n  const finishLock = new Lock();\n  updateFunctionCache(futureCache, config, arg, finishLock);\n  return finishLock;\n}\nfunction updateFunctionCache(cache, config, arg, value) {\n  if (!config.configured()) config.forever();\n  let cachedValue = cache.get(arg);\n  config.deactivate();\n  switch (config.mode()) {\n    case \"forever\":\n      cachedValue = [{\n        value,\n        valid: genTrue\n      }];\n      cache.set(arg, cachedValue);\n      break;\n    case \"invalidate\":\n      cachedValue = [{\n        value,\n        valid: config.validator()\n      }];\n      cache.set(arg, cachedValue);\n      break;\n    case \"valid\":\n      if (cachedValue) {\n        cachedValue.push({\n          value,\n          valid: config.validator()\n        });\n      } else {\n        cachedValue = [{\n          value,\n          valid: config.validator()\n        }];\n        cache.set(arg, cachedValue);\n      }\n  }\n}\nclass CacheConfigurator {\n  constructor(data) {\n    this._active = true;\n    this._never = false;\n    this._forever = false;\n    this._invalidate = false;\n    this._configured = false;\n    this._pairs = [];\n    this._data = void 0;\n    this._data = data;\n  }\n  simple() {\n    return makeSimpleConfigurator(this);\n  }\n  mode() {\n    if (this._never) return \"never\";\n    if (this._forever) return \"forever\";\n    if (this._invalidate) return \"invalidate\";\n    return \"valid\";\n  }\n  forever() {\n    if (!this._active) {\n      throw new Error(\"Cannot change caching after evaluation has completed.\");\n    }\n    if (this._never) {\n      throw new Error(\"Caching has already been configured with .never()\");\n    }\n    this._forever = true;\n    this._configured = true;\n  }\n  never() {\n    if (!this._active) {\n      throw new Error(\"Cannot change caching after evaluation has completed.\");\n    }\n    if (this._forever) {\n      throw new Error(\"Caching has already been configured with .forever()\");\n    }\n    this._never = true;\n    this._configured = true;\n  }\n  using(handler) {\n    if (!this._active) {\n      throw new Error(\"Cannot change caching after evaluation has completed.\");\n    }\n    if (this._never || this._forever) {\n      throw new Error(\"Caching has already been configured with .never or .forever()\");\n    }\n    this._configured = true;\n    const key = handler(this._data);\n    const fn = (0, _async.maybeAsync)(handler, `You appear to be using an async cache handler, but Babel has been called synchronously`);\n    if ((0, _async.isThenable)(key)) {\n      return key.then(key => {\n        this._pairs.push([key, fn]);\n        return key;\n      });\n    }\n    this._pairs.push([key, fn]);\n    return key;\n  }\n  invalidate(handler) {\n    this._invalidate = true;\n    return this.using(handler);\n  }\n  validator() {\n    const pairs = this._pairs;\n    return function* (data) {\n      for (const [key, fn] of pairs) {\n        if (key !== (yield* fn(data))) return false;\n      }\n      return true;\n    };\n  }\n  deactivate() {\n    this._active = false;\n  }\n  configured() {\n    return this._configured;\n  }\n}\nfunction makeSimpleConfigurator(cache) {\n  function cacheFn(val) {\n    if (typeof val === \"boolean\") {\n      if (val) cache.forever();else cache.never();\n      return;\n    }\n    return cache.using(() => assertSimpleType(val()));\n  }\n  cacheFn.forever = () => cache.forever();\n  cacheFn.never = () => cache.never();\n  cacheFn.using = cb => cache.using(() => assertSimpleType(cb()));\n  cacheFn.invalidate = cb => cache.invalidate(() => assertSimpleType(cb()));\n  return cacheFn;\n}\nfunction assertSimpleType(value) {\n  if ((0, _async.isThenable)(value)) {\n    throw new Error(`You appear to be using an async cache handler, ` + `which your current version of Babel does not support. ` + `We may add support for this in the future, ` + `but if you're on the most recent version of @babel/core and still ` + `seeing this error, then you'll need to synchronously handle your caching logic.`);\n  }\n  if (value != null && typeof value !== \"string\" && typeof value !== \"boolean\" && typeof value !== \"number\") {\n    throw new Error(\"Cache keys must be either string, boolean, number, null, or undefined.\");\n  }\n  return value;\n}\nclass Lock {\n  constructor() {\n    this.released = false;\n    this.promise = void 0;\n    this._resolve = void 0;\n    this.promise = new Promise(resolve => {\n      this._resolve = resolve;\n    });\n  }\n  release(value) {\n    this.released = true;\n    this._resolve(value);\n  }\n}\n0 && 0;\n\n//# sourceMappingURL=caching.js.map\n",
    "lib/config/validation/options.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assumptionsNames = void 0;\nexports.checkNoUnwrappedItemOptionPairs = checkNoUnwrappedItemOptionPairs;\nexports.validate = validate;\nvar _removed = require(\"./removed.js\");\nvar _optionAssertions = require(\"./option-assertions.js\");\nvar _configError = require(\"../../errors/config-error.js\");\nconst ROOT_VALIDATORS = {\n  cwd: _optionAssertions.assertString,\n  root: _optionAssertions.assertString,\n  rootMode: _optionAssertions.assertRootMode,\n  configFile: _optionAssertions.assertConfigFileSearch,\n  caller: _optionAssertions.assertCallerMetadata,\n  filename: _optionAssertions.assertString,\n  filenameRelative: _optionAssertions.assertString,\n  code: _optionAssertions.assertBoolean,\n  ast: _optionAssertions.assertBoolean,\n  cloneInputAst: _optionAssertions.assertBoolean,\n  envName: _optionAssertions.assertString\n};\nconst BABELRC_VALIDATORS = {\n  babelrc: _optionAssertions.assertBoolean,\n  babelrcRoots: _optionAssertions.assertBabelrcSearch\n};\nconst NONPRESET_VALIDATORS = {\n  extends: _optionAssertions.assertString,\n  ignore: _optionAssertions.assertIgnoreList,\n  only: _optionAssertions.assertIgnoreList,\n  targets: _optionAssertions.assertTargets,\n  browserslistConfigFile: _optionAssertions.assertConfigFileSearch,\n  browserslistEnv: _optionAssertions.assertString\n};\nconst COMMON_VALIDATORS = {\n  inputSourceMap: _optionAssertions.assertInputSourceMap,\n  presets: _optionAssertions.assertPluginList,\n  plugins: _optionAssertions.assertPluginList,\n  passPerPreset: _optionAssertions.assertBoolean,\n  assumptions: _optionAssertions.assertAssumptions,\n  env: assertEnvSet,\n  overrides: assertOverridesList,\n  test: _optionAssertions.assertConfigApplicableTest,\n  include: _optionAssertions.assertConfigApplicableTest,\n  exclude: _optionAssertions.assertConfigApplicableTest,\n  retainLines: _optionAssertions.assertBoolean,\n  comments: _optionAssertions.assertBoolean,\n  shouldPrintComment: _optionAssertions.assertFunction,\n  compact: _optionAssertions.assertCompact,\n  minified: _optionAssertions.assertBoolean,\n  auxiliaryCommentBefore: _optionAssertions.assertString,\n  auxiliaryCommentAfter: _optionAssertions.assertString,\n  sourceType: _optionAssertions.assertSourceType,\n  wrapPluginVisitorMethod: _optionAssertions.assertFunction,\n  highlightCode: _optionAssertions.assertBoolean,\n  sourceMaps: _optionAssertions.assertSourceMaps,\n  sourceMap: _optionAssertions.assertSourceMaps,\n  sourceFileName: _optionAssertions.assertString,\n  sourceRoot: _optionAssertions.assertString,\n  parserOpts: _optionAssertions.assertObject,\n  generatorOpts: _optionAssertions.assertObject\n};\n{\n  Object.assign(COMMON_VALIDATORS, {\n    getModuleId: _optionAssertions.assertFunction,\n    moduleRoot: _optionAssertions.assertString,\n    moduleIds: _optionAssertions.assertBoolean,\n    moduleId: _optionAssertions.assertString\n  });\n}\nconst knownAssumptions = [\"arrayLikeIsIterable\", \"constantReexports\", \"constantSuper\", \"enumerableModuleMeta\", \"ignoreFunctionLength\", \"ignoreToPrimitiveHint\", \"iterableIsArray\", \"mutableTemplateObject\", \"noClassCalls\", \"noDocumentAll\", \"noIncompleteNsImportDetection\", \"noNewArrows\", \"objectRestNoSymbols\", \"privateFieldsAsSymbols\", \"privateFieldsAsProperties\", \"pureGetters\", \"setClassMethods\", \"setComputedProperties\", \"setPublicClassFields\", \"setSpreadProperties\", \"skipForOfIteratorClosing\", \"superIsCallableConstructor\"];\nconst assumptionsNames = new Set(knownAssumptions);\nexports.assumptionsNames = assumptionsNames;\nfunction getSource(loc) {\n  return loc.type === \"root\" ? loc.source : getSource(loc.parent);\n}\nfunction validate(type, opts, filename) {\n  try {\n    return validateNested({\n      type: \"root\",\n      source: type\n    }, opts);\n  } catch (error) {\n    const configError = new _configError.default(error.message, filename);\n    if (error.code) configError.code = error.code;\n    throw configError;\n  }\n}\nfunction validateNested(loc, opts) {\n  const type = getSource(loc);\n  assertNoDuplicateSourcemap(opts);\n  Object.keys(opts).forEach(key => {\n    const optLoc = {\n      type: \"option\",\n      name: key,\n      parent: loc\n    };\n    if (type === \"preset\" && NONPRESET_VALIDATORS[key]) {\n      throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is not allowed in preset options`);\n    }\n    if (type !== \"arguments\" && ROOT_VALIDATORS[key]) {\n      throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is only allowed in root programmatic options`);\n    }\n    if (type !== \"arguments\" && type !== \"configfile\" && BABELRC_VALIDATORS[key]) {\n      if (type === \"babelrcfile\" || type === \"extendsfile\") {\n        throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is not allowed in .babelrc or \"extends\"ed files, only in root programmatic options, ` + `or babel.config.js/config file options`);\n      }\n      throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is only allowed in root programmatic options, or babel.config.js/config file options`);\n    }\n    const validator = COMMON_VALIDATORS[key] || NONPRESET_VALIDATORS[key] || BABELRC_VALIDATORS[key] || ROOT_VALIDATORS[key] || throwUnknownError;\n    validator(optLoc, opts[key]);\n  });\n  return opts;\n}\nfunction throwUnknownError(loc) {\n  const key = loc.name;\n  if (_removed.default[key]) {\n    const {\n      message,\n      version = 5\n    } = _removed.default[key];\n    throw new Error(`Using removed Babel ${version} option: ${(0, _optionAssertions.msg)(loc)} - ${message}`);\n  } else {\n    const unknownOptErr = new Error(`Unknown option: ${(0, _optionAssertions.msg)(loc)}. Check out https://babeljs.io/docs/en/babel-core/#options for more information about options.`);\n    unknownOptErr.code = \"BABEL_UNKNOWN_OPTION\";\n    throw unknownOptErr;\n  }\n}\nfunction has(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\nfunction assertNoDuplicateSourcemap(opts) {\n  if (has(opts, \"sourceMap\") && has(opts, \"sourceMaps\")) {\n    throw new Error(\".sourceMap is an alias for .sourceMaps, cannot use both\");\n  }\n}\nfunction assertEnvSet(loc, value) {\n  if (loc.parent.type === \"env\") {\n    throw new Error(`${(0, _optionAssertions.msg)(loc)} is not allowed inside of another .env block`);\n  }\n  const parent = loc.parent;\n  const obj = (0, _optionAssertions.assertObject)(loc, value);\n  if (obj) {\n    for (const envName of Object.keys(obj)) {\n      const env = (0, _optionAssertions.assertObject)((0, _optionAssertions.access)(loc, envName), obj[envName]);\n      if (!env) continue;\n      const envLoc = {\n        type: \"env\",\n        name: envName,\n        parent\n      };\n      validateNested(envLoc, env);\n    }\n  }\n  return obj;\n}\nfunction assertOverridesList(loc, value) {\n  if (loc.parent.type === \"env\") {\n    throw new Error(`${(0, _optionAssertions.msg)(loc)} is not allowed inside an .env block`);\n  }\n  if (loc.parent.type === \"overrides\") {\n    throw new Error(`${(0, _optionAssertions.msg)(loc)} is not allowed inside an .overrides block`);\n  }\n  const parent = loc.parent;\n  const arr = (0, _optionAssertions.assertArray)(loc, value);\n  if (arr) {\n    for (const [index, item] of arr.entries()) {\n      const objLoc = (0, _optionAssertions.access)(loc, index);\n      const env = (0, _optionAssertions.assertObject)(objLoc, item);\n      if (!env) throw new Error(`${(0, _optionAssertions.msg)(objLoc)} must be an object`);\n      const overridesLoc = {\n        type: \"overrides\",\n        index,\n        parent\n      };\n      validateNested(overridesLoc, env);\n    }\n  }\n  return arr;\n}\nfunction checkNoUnwrappedItemOptionPairs(items, index, type, e) {\n  if (index === 0) return;\n  const lastItem = items[index - 1];\n  const thisItem = items[index];\n  if (lastItem.file && lastItem.options === undefined && typeof thisItem.value === \"object\") {\n    e.message += `\\n- Maybe you meant to use\\n` + `\"${type}s\": [\\n  [\"${lastItem.file.request}\", ${JSON.stringify(thisItem.value, undefined, 2)}]\\n]\\n` + `To be a valid ${type}, its name and options should be wrapped in a pair of brackets`;\n  }\n}\n0 && 0;\n\n//# sourceMappingURL=options.js.map\n",
    "lib/config/validation/plugins.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validatePluginObject = validatePluginObject;\nvar _optionAssertions = require(\"./option-assertions.js\");\nconst VALIDATORS = {\n  name: _optionAssertions.assertString,\n  manipulateOptions: _optionAssertions.assertFunction,\n  pre: _optionAssertions.assertFunction,\n  post: _optionAssertions.assertFunction,\n  inherits: _optionAssertions.assertFunction,\n  visitor: assertVisitorMap,\n  parserOverride: _optionAssertions.assertFunction,\n  generatorOverride: _optionAssertions.assertFunction\n};\nfunction assertVisitorMap(loc, value) {\n  const obj = (0, _optionAssertions.assertObject)(loc, value);\n  if (obj) {\n    Object.keys(obj).forEach(prop => {\n      if (prop !== \"_exploded\" && prop !== \"_verified\") {\n        assertVisitorHandler(prop, obj[prop]);\n      }\n    });\n    if (obj.enter || obj.exit) {\n      throw new Error(`${(0, _optionAssertions.msg)(loc)} cannot contain catch-all \"enter\" or \"exit\" handlers. Please target individual nodes.`);\n    }\n  }\n  return obj;\n}\nfunction assertVisitorHandler(key, value) {\n  if (value && typeof value === \"object\") {\n    Object.keys(value).forEach(handler => {\n      if (handler !== \"enter\" && handler !== \"exit\") {\n        throw new Error(`.visitor[\"${key}\"] may only have .enter and/or .exit handlers.`);\n      }\n    });\n  } else if (typeof value !== \"function\") {\n    throw new Error(`.visitor[\"${key}\"] must be a function`);\n  }\n}\nfunction validatePluginObject(obj) {\n  const rootPath = {\n    type: \"root\",\n    source: \"plugin\"\n  };\n  Object.keys(obj).forEach(key => {\n    const validator = VALIDATORS[key];\n    if (validator) {\n      const optLoc = {\n        type: \"option\",\n        name: key,\n        parent: rootPath\n      };\n      validator(optLoc, obj[key]);\n    } else {\n      const invalidPluginPropertyError = new Error(`.${key} is not a valid Plugin property`);\n      invalidPluginPropertyError.code = \"BABEL_UNKNOWN_PLUGIN_PROPERTY\";\n      throw invalidPluginPropertyError;\n    }\n  });\n  return obj;\n}\n0 && 0;\n\n//# sourceMappingURL=plugins.js.map\n",
    "lib/config/helpers/config-api.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.makeConfigAPI = makeConfigAPI;\nexports.makePluginAPI = makePluginAPI;\nexports.makePresetAPI = makePresetAPI;\nfunction _semver() {\n  const data = require(\"semver\");\n  _semver = function () {\n    return data;\n  };\n  return data;\n}\nvar _index = require(\"../../index.js\");\nvar _caching = require(\"../caching.js\");\nfunction makeConfigAPI(cache) {\n  const env = value => cache.using(data => {\n    if (typeof value === \"undefined\") return data.envName;\n    if (typeof value === \"function\") {\n      return (0, _caching.assertSimpleType)(value(data.envName));\n    }\n    return (Array.isArray(value) ? value : [value]).some(entry => {\n      if (typeof entry !== \"string\") {\n        throw new Error(\"Unexpected non-string value\");\n      }\n      return entry === data.envName;\n    });\n  });\n  const caller = cb => cache.using(data => (0, _caching.assertSimpleType)(cb(data.caller)));\n  return {\n    version: _index.version,\n    cache: cache.simple(),\n    env,\n    async: () => false,\n    caller,\n    assertVersion\n  };\n}\nfunction makePresetAPI(cache, externalDependencies) {\n  const targets = () => JSON.parse(cache.using(data => JSON.stringify(data.targets)));\n  const addExternalDependency = ref => {\n    externalDependencies.push(ref);\n  };\n  return Object.assign({}, makeConfigAPI(cache), {\n    targets,\n    addExternalDependency\n  });\n}\nfunction makePluginAPI(cache, externalDependencies) {\n  const assumption = name => cache.using(data => data.assumptions[name]);\n  return Object.assign({}, makePresetAPI(cache, externalDependencies), {\n    assumption\n  });\n}\nfunction assertVersion(range) {\n  if (typeof range === \"number\") {\n    if (!Number.isInteger(range)) {\n      throw new Error(\"Expected string or integer value.\");\n    }\n    range = `^${range}.0.0-0`;\n  }\n  if (typeof range !== \"string\") {\n    throw new Error(\"Expected string or integer value.\");\n  }\n  ;\n  if (_semver().satisfies(_index.version, range)) return;\n  const limit = Error.stackTraceLimit;\n  if (typeof limit === \"number\" && limit < 25) {\n    Error.stackTraceLimit = 25;\n  }\n  const err = new Error(`Requires Babel \"${range}\", but was loaded with \"${_index.version}\". ` + `If you are sure you have a compatible version of @babel/core, ` + `it is likely that something in your build process is loading the ` + `wrong version. Inspect the stack trace of this error to look for ` + `the first entry that doesn't mention \"@babel/core\" or \"babel-core\" ` + `to see what is calling Babel.`);\n  if (typeof limit === \"number\") {\n    Error.stackTraceLimit = limit;\n  }\n  throw Object.assign(err, {\n    code: \"BABEL_VERSION_UNSUPPORTED\",\n    version: _index.version,\n    range\n  });\n}\n0 && 0;\n\n//# sourceMappingURL=config-api.js.map\n",
    "lib/errors/config-error.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _rewriteStackTrace = require(\"./rewrite-stack-trace.js\");\nclass ConfigError extends Error {\n  constructor(message, filename) {\n    super(message);\n    (0, _rewriteStackTrace.expectedError)(this);\n    if (filename) (0, _rewriteStackTrace.injectVirtualStackFrame)(this, filename);\n  }\n}\nexports.default = ConfigError;\n0 && 0;\n\n//# sourceMappingURL=config-error.js.map\n",
    "lib/config/resolve-targets-browser.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveBrowserslistConfigFile = resolveBrowserslistConfigFile;\nexports.resolveTargets = resolveTargets;\nfunction _helperCompilationTargets() {\n  const data = require(\"@babel/helper-compilation-targets\");\n  _helperCompilationTargets = function () {\n    return data;\n  };\n  return data;\n}\nfunction resolveBrowserslistConfigFile(browserslistConfigFile, configFilePath) {\n  return undefined;\n}\nfunction resolveTargets(options, root) {\n  const optTargets = options.targets;\n  let targets;\n  if (typeof optTargets === \"string\" || Array.isArray(optTargets)) {\n    targets = {\n      browsers: optTargets\n    };\n  } else if (optTargets) {\n    if (\"esmodules\" in optTargets) {\n      targets = Object.assign({}, optTargets, {\n        esmodules: \"intersect\"\n      });\n    } else {\n      targets = optTargets;\n    }\n  }\n  return (0, _helperCompilationTargets().default)(targets, {\n    ignoreBrowserslistConfig: true,\n    browserslistEnv: options.browserslistEnv\n  });\n}\n0 && 0;\n\n//# sourceMappingURL=resolve-targets-browser.js.map\n",
    "lib/config/config-descriptors.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createCachedDescriptors = createCachedDescriptors;\nexports.createDescriptor = createDescriptor;\nexports.createUncachedDescriptors = createUncachedDescriptors;\nfunction _gensync() {\n  const data = require(\"gensync\");\n  _gensync = function () {\n    return data;\n  };\n  return data;\n}\nvar _functional = require(\"../gensync-utils/functional.js\");\nvar _index = require(\"./files/index.js\");\nvar _item = require(\"./item.js\");\nvar _caching = require(\"./caching.js\");\nvar _resolveTargets = require(\"./resolve-targets.js\");\nfunction isEqualDescriptor(a, b) {\n  var _a$file, _b$file, _a$file2, _b$file2;\n  return a.name === b.name && a.value === b.value && a.options === b.options && a.dirname === b.dirname && a.alias === b.alias && a.ownPass === b.ownPass && ((_a$file = a.file) == null ? void 0 : _a$file.request) === ((_b$file = b.file) == null ? void 0 : _b$file.request) && ((_a$file2 = a.file) == null ? void 0 : _a$file2.resolved) === ((_b$file2 = b.file) == null ? void 0 : _b$file2.resolved);\n}\nfunction* handlerOf(value) {\n  return value;\n}\nfunction optionsWithResolvedBrowserslistConfigFile(options, dirname) {\n  if (typeof options.browserslistConfigFile === \"string\") {\n    options.browserslistConfigFile = (0, _resolveTargets.resolveBrowserslistConfigFile)(options.browserslistConfigFile, dirname);\n  }\n  return options;\n}\nfunction createCachedDescriptors(dirname, options, alias) {\n  const {\n    plugins,\n    presets,\n    passPerPreset\n  } = options;\n  return {\n    options: optionsWithResolvedBrowserslistConfigFile(options, dirname),\n    plugins: plugins ? () => createCachedPluginDescriptors(plugins, dirname)(alias) : () => handlerOf([]),\n    presets: presets ? () => createCachedPresetDescriptors(presets, dirname)(alias)(!!passPerPreset) : () => handlerOf([])\n  };\n}\nfunction createUncachedDescriptors(dirname, options, alias) {\n  return {\n    options: optionsWithResolvedBrowserslistConfigFile(options, dirname),\n    plugins: (0, _functional.once)(() => createPluginDescriptors(options.plugins || [], dirname, alias)),\n    presets: (0, _functional.once)(() => createPresetDescriptors(options.presets || [], dirname, alias, !!options.passPerPreset))\n  };\n}\nconst PRESET_DESCRIPTOR_CACHE = new WeakMap();\nconst createCachedPresetDescriptors = (0, _caching.makeWeakCacheSync)((items, cache) => {\n  const dirname = cache.using(dir => dir);\n  return (0, _caching.makeStrongCacheSync)(alias => (0, _caching.makeStrongCache)(function* (passPerPreset) {\n    const descriptors = yield* createPresetDescriptors(items, dirname, alias, passPerPreset);\n    return descriptors.map(desc => loadCachedDescriptor(PRESET_DESCRIPTOR_CACHE, desc));\n  }));\n});\nconst PLUGIN_DESCRIPTOR_CACHE = new WeakMap();\nconst createCachedPluginDescriptors = (0, _caching.makeWeakCacheSync)((items, cache) => {\n  const dirname = cache.using(dir => dir);\n  return (0, _caching.makeStrongCache)(function* (alias) {\n    const descriptors = yield* createPluginDescriptors(items, dirname, alias);\n    return descriptors.map(desc => loadCachedDescriptor(PLUGIN_DESCRIPTOR_CACHE, desc));\n  });\n});\nconst DEFAULT_OPTIONS = {};\nfunction loadCachedDescriptor(cache, desc) {\n  const {\n    value,\n    options = DEFAULT_OPTIONS\n  } = desc;\n  if (options === false) return desc;\n  let cacheByOptions = cache.get(value);\n  if (!cacheByOptions) {\n    cacheByOptions = new WeakMap();\n    cache.set(value, cacheByOptions);\n  }\n  let possibilities = cacheByOptions.get(options);\n  if (!possibilities) {\n    possibilities = [];\n    cacheByOptions.set(options, possibilities);\n  }\n  if (possibilities.indexOf(desc) === -1) {\n    const matches = possibilities.filter(possibility => isEqualDescriptor(possibility, desc));\n    if (matches.length > 0) {\n      return matches[0];\n    }\n    possibilities.push(desc);\n  }\n  return desc;\n}\nfunction* createPresetDescriptors(items, dirname, alias, passPerPreset) {\n  return yield* createDescriptors(\"preset\", items, dirname, alias, passPerPreset);\n}\nfunction* createPluginDescriptors(items, dirname, alias) {\n  return yield* createDescriptors(\"plugin\", items, dirname, alias);\n}\nfunction* createDescriptors(type, items, dirname, alias, ownPass) {\n  const descriptors = yield* _gensync().all(items.map((item, index) => createDescriptor(item, dirname, {\n    type,\n    alias: `${alias}$${index}`,\n    ownPass: !!ownPass\n  })));\n  assertNoDuplicates(descriptors);\n  return descriptors;\n}\nfunction* createDescriptor(pair, dirname, {\n  type,\n  alias,\n  ownPass\n}) {\n  const desc = (0, _item.getItemDescriptor)(pair);\n  if (desc) {\n    return desc;\n  }\n  let name;\n  let options;\n  let value = pair;\n  if (Array.isArray(value)) {\n    if (value.length === 3) {\n      [value, options, name] = value;\n    } else {\n      [value, options] = value;\n    }\n  }\n  let file = undefined;\n  let filepath = null;\n  if (typeof value === \"string\") {\n    if (typeof type !== \"string\") {\n      throw new Error(\"To resolve a string-based item, the type of item must be given\");\n    }\n    const resolver = type === \"plugin\" ? _index.loadPlugin : _index.loadPreset;\n    const request = value;\n    ({\n      filepath,\n      value\n    } = yield* resolver(value, dirname));\n    file = {\n      request,\n      resolved: filepath\n    };\n  }\n  if (!value) {\n    throw new Error(`Unexpected falsy value: ${String(value)}`);\n  }\n  if (typeof value === \"object\" && value.__esModule) {\n    if (value.default) {\n      value = value.default;\n    } else {\n      throw new Error(\"Must export a default export when using ES6 modules.\");\n    }\n  }\n  if (typeof value !== \"object\" && typeof value !== \"function\") {\n    throw new Error(`Unsupported format: ${typeof value}. Expected an object or a function.`);\n  }\n  if (filepath !== null && typeof value === \"object\" && value) {\n    throw new Error(`Plugin/Preset files are not allowed to export objects, only functions. In ${filepath}`);\n  }\n  return {\n    name,\n    alias: filepath || alias,\n    value,\n    options,\n    dirname,\n    ownPass,\n    file\n  };\n}\nfunction assertNoDuplicates(items) {\n  const map = new Map();\n  for (const item of items) {\n    if (typeof item.value !== \"function\") continue;\n    let nameMap = map.get(item.value);\n    if (!nameMap) {\n      nameMap = new Set();\n      map.set(item.value, nameMap);\n    }\n    if (nameMap.has(item.name)) {\n      const conflicts = items.filter(i => i.value === item.value);\n      throw new Error([`Duplicate plugin/preset detected.`, `If you'd like to use two separate instances of a plugin,`, `they need separate names, e.g.`, ``, `  plugins: [`, `    ['some-plugin', {}],`, `    ['some-plugin', {}, 'some unique name'],`, `  ]`, ``, `Duplicates detected are:`, `${JSON.stringify(conflicts, null, 2)}`].join(\"\\n\"));\n    }\n    nameMap.add(item.name);\n  }\n}\n0 && 0;\n\n//# sourceMappingURL=config-descriptors.js.map\n",
    "lib/transformation/plugin-pass.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nclass PluginPass {\n  constructor(file, key, options) {\n    this._map = new Map();\n    this.key = void 0;\n    this.file = void 0;\n    this.opts = void 0;\n    this.cwd = void 0;\n    this.filename = void 0;\n    this.key = key;\n    this.file = file;\n    this.opts = options || {};\n    this.cwd = file.opts.cwd;\n    this.filename = file.opts.filename;\n  }\n  set(key, val) {\n    this._map.set(key, val);\n  }\n  get(key) {\n    return this._map.get(key);\n  }\n  availableHelper(name, versionRange) {\n    return this.file.availableHelper(name, versionRange);\n  }\n  addHelper(name) {\n    return this.file.addHelper(name);\n  }\n  buildCodeFrameError(node, msg, _Error) {\n    return this.file.buildCodeFrameError(node, msg, _Error);\n  }\n}\nexports.default = PluginPass;\n{\n  PluginPass.prototype.getModuleName = function getModuleName() {\n    return this.file.getModuleName();\n  };\n  PluginPass.prototype.addImport = function addImport() {\n    this.file.addImport();\n  };\n}\n0 && 0;\n\n//# sourceMappingURL=plugin-pass.js.map\n",
    "lib/transformation/block-hoist-plugin.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = loadBlockHoistPlugin;\nfunction _traverse() {\n  const data = require(\"@babel/traverse\");\n  _traverse = function () {\n    return data;\n  };\n  return data;\n}\nvar _plugin = require(\"../config/plugin.js\");\nlet LOADED_PLUGIN;\nconst blockHoistPlugin = {\n  name: \"internal.blockHoist\",\n  visitor: {\n    Block: {\n      exit({\n        node\n      }) {\n        const {\n          body\n        } = node;\n        let max = Math.pow(2, 30) - 1;\n        let hasChange = false;\n        for (let i = 0; i < body.length; i++) {\n          const n = body[i];\n          const p = priority(n);\n          if (p > max) {\n            hasChange = true;\n            break;\n          }\n          max = p;\n        }\n        if (!hasChange) return;\n        node.body = stableSort(body.slice());\n      }\n    }\n  }\n};\nfunction loadBlockHoistPlugin() {\n  if (!LOADED_PLUGIN) {\n    LOADED_PLUGIN = new _plugin.default(Object.assign({}, blockHoistPlugin, {\n      visitor: _traverse().default.explode(blockHoistPlugin.visitor)\n    }), {});\n  }\n  return LOADED_PLUGIN;\n}\nfunction priority(bodyNode) {\n  const priority = bodyNode == null ? void 0 : bodyNode._blockHoist;\n  if (priority == null) return 1;\n  if (priority === true) return 2;\n  return priority;\n}\nfunction stableSort(body) {\n  const buckets = Object.create(null);\n  for (let i = 0; i < body.length; i++) {\n    const n = body[i];\n    const p = priority(n);\n    const bucket = buckets[p] || (buckets[p] = []);\n    bucket.push(n);\n  }\n  const keys = Object.keys(buckets).map(k => +k).sort((a, b) => b - a);\n  let index = 0;\n  for (const key of keys) {\n    const bucket = buckets[key];\n    for (const n of bucket) {\n      body[index++] = n;\n    }\n  }\n  return body;\n}\n0 && 0;\n\n//# sourceMappingURL=block-hoist-plugin.js.map\n",
    "lib/transformation/normalize-file.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = normalizeFile;\nfunction _fs() {\n  const data = require(\"fs\");\n  _fs = function () {\n    return data;\n  };\n  return data;\n}\nfunction _path() {\n  const data = require(\"path\");\n  _path = function () {\n    return data;\n  };\n  return data;\n}\nfunction _debug() {\n  const data = require(\"debug\");\n  _debug = function () {\n    return data;\n  };\n  return data;\n}\nfunction _t() {\n  const data = require(\"@babel/types\");\n  _t = function () {\n    return data;\n  };\n  return data;\n}\nfunction _convertSourceMap() {\n  const data = require(\"convert-source-map\");\n  _convertSourceMap = function () {\n    return data;\n  };\n  return data;\n}\nvar _file = require(\"./file/file.js\");\nvar _index = require(\"../parser/index.js\");\nvar _cloneDeep = require(\"./util/clone-deep.js\");\nconst {\n  file,\n  traverseFast\n} = _t();\nconst debug = _debug()(\"babel:transform:file\");\nconst INLINE_SOURCEMAP_REGEX = /^[@#]\\s+sourceMappingURL=data:(?:application|text)\\/json;(?:charset[:=]\\S+?;)?base64,(?:.*)$/;\nconst EXTERNAL_SOURCEMAP_REGEX = /^[@#][ \\t]+sourceMappingURL=([^\\s'\"`]+)[ \\t]*$/;\nfunction* normalizeFile(pluginPasses, options, code, ast) {\n  code = `${code || \"\"}`;\n  if (ast) {\n    if (ast.type === \"Program\") {\n      ast = file(ast, [], []);\n    } else if (ast.type !== \"File\") {\n      throw new Error(\"AST root must be a Program or File node\");\n    }\n    if (options.cloneInputAst) {\n      ast = (0, _cloneDeep.default)(ast);\n    }\n  } else {\n    ast = yield* (0, _index.default)(pluginPasses, options, code);\n  }\n  let inputMap = null;\n  if (options.inputSourceMap !== false) {\n    if (typeof options.inputSourceMap === \"object\") {\n      inputMap = _convertSourceMap().fromObject(options.inputSourceMap);\n    }\n    if (!inputMap) {\n      const lastComment = extractComments(INLINE_SOURCEMAP_REGEX, ast);\n      if (lastComment) {\n        try {\n          inputMap = _convertSourceMap().fromComment(\"//\" + lastComment);\n        } catch (err) {\n          {\n            debug(\"discarding unknown inline input sourcemap\");\n          }\n        }\n      }\n    }\n    if (!inputMap) {\n      const lastComment = extractComments(EXTERNAL_SOURCEMAP_REGEX, ast);\n      if (typeof options.filename === \"string\" && lastComment) {\n        try {\n          const match = EXTERNAL_SOURCEMAP_REGEX.exec(lastComment);\n          const inputMapContent = _fs().readFileSync(_path().resolve(_path().dirname(options.filename), match[1]), \"utf8\");\n          inputMap = _convertSourceMap().fromJSON(inputMapContent);\n        } catch (err) {\n          debug(\"discarding unknown file input sourcemap\", err);\n        }\n      } else if (lastComment) {\n        debug(\"discarding un-loadable file input sourcemap\");\n      }\n    }\n  }\n  return new _file.default(options, {\n    code,\n    ast: ast,\n    inputMap\n  });\n}\nfunction extractCommentsFromList(regex, comments, lastComment) {\n  if (comments) {\n    comments = comments.filter(({\n      value\n    }) => {\n      if (regex.test(value)) {\n        lastComment = value;\n        return false;\n      }\n      return true;\n    });\n  }\n  return [comments, lastComment];\n}\nfunction extractComments(regex, ast) {\n  let lastComment = null;\n  traverseFast(ast, node => {\n    [node.leadingComments, lastComment] = extractCommentsFromList(regex, node.leadingComments, lastComment);\n    [node.innerComments, lastComment] = extractCommentsFromList(regex, node.innerComments, lastComment);\n    [node.trailingComments, lastComment] = extractCommentsFromList(regex, node.trailingComments, lastComment);\n  });\n  return lastComment;\n}\n0 && 0;\n\n//# sourceMappingURL=normalize-file.js.map\n",
    "lib/transformation/file/generate.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = generateCode;\nfunction _convertSourceMap() {\n  const data = require(\"convert-source-map\");\n  _convertSourceMap = function () {\n    return data;\n  };\n  return data;\n}\nfunction _generator() {\n  const data = require(\"@babel/generator\");\n  _generator = function () {\n    return data;\n  };\n  return data;\n}\nvar _mergeMap = require(\"./merge-map.js\");\nfunction generateCode(pluginPasses, file) {\n  const {\n    opts,\n    ast,\n    code,\n    inputMap\n  } = file;\n  const {\n    generatorOpts\n  } = opts;\n  generatorOpts.inputSourceMap = inputMap == null ? void 0 : inputMap.toObject();\n  const results = [];\n  for (const plugins of pluginPasses) {\n    for (const plugin of plugins) {\n      const {\n        generatorOverride\n      } = plugin;\n      if (generatorOverride) {\n        const result = generatorOverride(ast, generatorOpts, code, _generator().default);\n        if (result !== undefined) results.push(result);\n      }\n    }\n  }\n  let result;\n  if (results.length === 0) {\n    result = (0, _generator().default)(ast, generatorOpts, code);\n  } else if (results.length === 1) {\n    result = results[0];\n    if (typeof result.then === \"function\") {\n      throw new Error(`You appear to be using an async codegen plugin, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, ` + `you may need to upgrade your @babel/core version.`);\n    }\n  } else {\n    throw new Error(\"More than one plugin attempted to override codegen.\");\n  }\n  let {\n    code: outputCode,\n    decodedMap: outputMap = result.map\n  } = result;\n  if (result.__mergedMap) {\n    outputMap = Object.assign({}, result.map);\n  } else {\n    if (outputMap) {\n      if (inputMap) {\n        outputMap = (0, _mergeMap.default)(inputMap.toObject(), outputMap, generatorOpts.sourceFileName);\n      } else {\n        outputMap = result.map;\n      }\n    }\n  }\n  if (opts.sourceMaps === \"inline\" || opts.sourceMaps === \"both\") {\n    outputCode += \"\\n\" + _convertSourceMap().fromObject(outputMap).toComment();\n  }\n  if (opts.sourceMaps === \"inline\") {\n    outputMap = null;\n  }\n  return {\n    outputCode,\n    outputMap\n  };\n}\n0 && 0;\n\n//# sourceMappingURL=generate.js.map\n",
    "lib/parser/util/missing-plugin-helper.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = generateMissingPluginMessage;\nconst pluginNameMap = {\n  asyncDoExpressions: {\n    syntax: {\n      name: \"@babel/plugin-syntax-async-do-expressions\",\n      url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-do-expressions\"\n    }\n  },\n  decimal: {\n    syntax: {\n      name: \"@babel/plugin-syntax-decimal\",\n      url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decimal\"\n    }\n  },\n  decorators: {\n    syntax: {\n      name: \"@babel/plugin-syntax-decorators\",\n      url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decorators\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-decorators\",\n      url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-decorators\"\n    }\n  },\n  doExpressions: {\n    syntax: {\n      name: \"@babel/plugin-syntax-do-expressions\",\n      url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-do-expressions\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-do-expressions\",\n      url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-do-expressions\"\n    }\n  },\n  exportDefaultFrom: {\n    syntax: {\n      name: \"@babel/plugin-syntax-export-default-from\",\n      url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-default-from\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-export-default-from\",\n      url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-export-default-from\"\n    }\n  },\n  flow: {\n    syntax: {\n      name: \"@babel/plugin-syntax-flow\",\n      url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-flow\"\n    },\n    transform: {\n      name: \"@babel/preset-flow\",\n      url: \"https://github.com/babel/babel/tree/main/packages/babel-preset-flow\"\n    }\n  },\n  functionBind: {\n    syntax: {\n      name: \"@babel/plugin-syntax-function-bind\",\n      url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-bind\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-function-bind\",\n      url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-bind\"\n    }\n  },\n  functionSent: {\n    syntax: {\n      name: \"@babel/plugin-syntax-function-sent\",\n      url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-sent\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-function-sent\",\n      url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-sent\"\n    }\n  },\n  jsx: {\n    syntax: {\n      name: \"@babel/plugin-syntax-jsx\",\n      url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-jsx\"\n    },\n    transform: {\n      name: \"@babel/preset-react\",\n      url: \"https://github.com/babel/babel/tree/main/packages/babel-preset-react\"\n    }\n  },\n  importAttributes: {\n    syntax: {\n      name: \"@babel/plugin-syntax-import-attributes\",\n      url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-attributes\"\n    }\n  },\n  pipelineOperator: {\n    syntax: {\n      name: \"@babel/plugin-syntax-pipeline-operator\",\n      url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-pipeline-operator\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-pipeline-operator\",\n      url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-pipeline-operator\"\n    }\n  },\n  recordAndTuple: {\n    syntax: {\n      name: \"@babel/plugin-syntax-record-and-tuple\",\n      url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-record-and-tuple\"\n    }\n  },\n  throwExpressions: {\n    syntax: {\n      name: \"@babel/plugin-syntax-throw-expressions\",\n      url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-throw-expressions\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-throw-expressions\",\n      url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-throw-expressions\"\n    }\n  },\n  typescript: {\n    syntax: {\n      name: \"@babel/plugin-syntax-typescript\",\n      url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-typescript\"\n    },\n    transform: {\n      name: \"@babel/preset-typescript\",\n      url: \"https://github.com/babel/babel/tree/main/packages/babel-preset-typescript\"\n    }\n  }\n};\n{\n  Object.assign(pluginNameMap, {\n    asyncGenerators: {\n      syntax: {\n        name: \"@babel/plugin-syntax-async-generators\",\n        url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-generators\"\n      },\n      transform: {\n        name: \"@babel/plugin-transform-async-generator-functions\",\n        url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-async-generator-functions\"\n      }\n    },\n    classProperties: {\n      syntax: {\n        name: \"@babel/plugin-syntax-class-properties\",\n        url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties\"\n      },\n      transform: {\n        name: \"@babel/plugin-transform-class-properties\",\n        url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-class-properties\"\n      }\n    },\n    classPrivateProperties: {\n      syntax: {\n        name: \"@babel/plugin-syntax-class-properties\",\n        url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties\"\n      },\n      transform: {\n        name: \"@babel/plugin-transform-class-properties\",\n        url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-class-properties\"\n      }\n    },\n    classPrivateMethods: {\n      syntax: {\n        name: \"@babel/plugin-syntax-class-properties\",\n        url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties\"\n      },\n      transform: {\n        name: \"@babel/plugin-transform-private-methods\",\n        url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-private-methods\"\n      }\n    },\n    classStaticBlock: {\n      syntax: {\n        name: \"@babel/plugin-syntax-class-static-block\",\n        url: \"https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-syntax-class-static-block\"\n      },\n      transform: {\n        name: \"@babel/plugin-transform-class-static-block\",\n        url: \"https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-transform-class-static-block\"\n      }\n    },\n    dynamicImport: {\n      syntax: {\n        name: \"@babel/plugin-syntax-dynamic-import\",\n        url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-dynamic-import\"\n      }\n    },\n    exportNamespaceFrom: {\n      syntax: {\n        name: \"@babel/plugin-syntax-export-namespace-from\",\n        url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-namespace-from\"\n      },\n      transform: {\n        name: \"@babel/plugin-transform-export-namespace-from\",\n        url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-export-namespace-from\"\n      }\n    },\n    importAssertions: {\n      syntax: {\n        name: \"@babel/plugin-syntax-import-assertions\",\n        url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-assertions\"\n      }\n    },\n    importMeta: {\n      syntax: {\n        name: \"@babel/plugin-syntax-import-meta\",\n        url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-meta\"\n      }\n    },\n    logicalAssignment: {\n      syntax: {\n        name: \"@babel/plugin-syntax-logical-assignment-operators\",\n        url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-logical-assignment-operators\"\n      },\n      transform: {\n        name: \"@babel/plugin-transform-logical-assignment-operators\",\n        url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-logical-assignment-operators\"\n      }\n    },\n    moduleStringNames: {\n      syntax: {\n        name: \"@babel/plugin-syntax-module-string-names\",\n        url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-module-string-names\"\n      }\n    },\n    numericSeparator: {\n      syntax: {\n        name: \"@babel/plugin-syntax-numeric-separator\",\n        url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-numeric-separator\"\n      },\n      transform: {\n        name: \"@babel/plugin-transform-numeric-separator\",\n        url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-numeric-separator\"\n      }\n    },\n    nullishCoalescingOperator: {\n      syntax: {\n        name: \"@babel/plugin-syntax-nullish-coalescing-operator\",\n        url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-nullish-coalescing-operator\"\n      },\n      transform: {\n        name: \"@babel/plugin-transform-nullish-coalescing-operator\",\n        url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-nullish-coalescing-opearator\"\n      }\n    },\n    objectRestSpread: {\n      syntax: {\n        name: \"@babel/plugin-syntax-object-rest-spread\",\n        url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-object-rest-spread\"\n      },\n      transform: {\n        name: \"@babel/plugin-transform-object-rest-spread\",\n        url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-object-rest-spread\"\n      }\n    },\n    optionalCatchBinding: {\n      syntax: {\n        name: \"@babel/plugin-syntax-optional-catch-binding\",\n        url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-catch-binding\"\n      },\n      transform: {\n        name: \"@babel/plugin-transform-optional-catch-binding\",\n        url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-optional-catch-binding\"\n      }\n    },\n    optionalChaining: {\n      syntax: {\n        name: \"@babel/plugin-syntax-optional-chaining\",\n        url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-chaining\"\n      },\n      transform: {\n        name: \"@babel/plugin-transform-optional-chaining\",\n        url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-optional-chaining\"\n      }\n    },\n    privateIn: {\n      syntax: {\n        name: \"@babel/plugin-syntax-private-property-in-object\",\n        url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-private-property-in-object\"\n      },\n      transform: {\n        name: \"@babel/plugin-transform-private-property-in-object\",\n        url: \"https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-private-property-in-object\"\n      }\n    },\n    regexpUnicodeSets: {\n      syntax: {\n        name: \"@babel/plugin-syntax-unicode-sets-regex\",\n        url: \"https://github.com/babel/babel/blob/main/packages/babel-plugin-syntax-unicode-sets-regex/README.md\"\n      },\n      transform: {\n        name: \"@babel/plugin-transform-unicode-sets-regex\",\n        url: \"https://github.com/babel/babel/blob/main/packages/babel-plugin-proposalunicode-sets-regex/README.md\"\n      }\n    }\n  });\n}\nconst getNameURLCombination = ({\n  name,\n  url\n}) => `${name} (${url})`;\nfunction generateMissingPluginMessage(missingPluginName, loc, codeFrame) {\n  let helpMessage = `Support for the experimental syntax '${missingPluginName}' isn't currently enabled ` + `(${loc.line}:${loc.column + 1}):\\n\\n` + codeFrame;\n  const pluginInfo = pluginNameMap[missingPluginName];\n  if (pluginInfo) {\n    const {\n      syntax: syntaxPlugin,\n      transform: transformPlugin\n    } = pluginInfo;\n    if (syntaxPlugin) {\n      const syntaxPluginInfo = getNameURLCombination(syntaxPlugin);\n      if (transformPlugin) {\n        const transformPluginInfo = getNameURLCombination(transformPlugin);\n        const sectionType = transformPlugin.name.startsWith(\"@babel/plugin\") ? \"plugins\" : \"presets\";\n        helpMessage += `\\n\\nAdd ${transformPluginInfo} to the '${sectionType}' section of your Babel config to enable transformation.\nIf you want to leave it as-is, add ${syntaxPluginInfo} to the 'plugins' section to enable parsing.`;\n      } else {\n        helpMessage += `\\n\\nAdd ${syntaxPluginInfo} to the 'plugins' section of your Babel config ` + `to enable parsing.`;\n      }\n    }\n  }\n  return helpMessage;\n}\n0 && 0;\n\n//# sourceMappingURL=missing-plugin-helper.js.map\n",
    "lib/config/pattern-to-regex.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = pathToPattern;\nfunction _path() {\n  const data = require(\"path\");\n  _path = function () {\n    return data;\n  };\n  return data;\n}\nconst sep = `\\\\${_path().sep}`;\nconst endSep = `(?:${sep}|$)`;\nconst substitution = `[^${sep}]+`;\nconst starPat = `(?:${substitution}${sep})`;\nconst starPatLast = `(?:${substitution}${endSep})`;\nconst starStarPat = `${starPat}*?`;\nconst starStarPatLast = `${starPat}*?${starPatLast}?`;\nfunction escapeRegExp(string) {\n  return string.replace(/[|\\\\{}()[\\]^$+*?.]/g, \"\\\\$&\");\n}\nfunction pathToPattern(pattern, dirname) {\n  const parts = _path().resolve(dirname, pattern).split(_path().sep);\n  return new RegExp([\"^\", ...parts.map((part, i) => {\n    const last = i === parts.length - 1;\n    if (part === \"**\") return last ? starStarPatLast : starStarPat;\n    if (part === \"*\") return last ? starPatLast : starPat;\n    if (part.indexOf(\"*.\") === 0) {\n      return substitution + escapeRegExp(part.slice(1)) + (last ? endSep : sep);\n    }\n    return escapeRegExp(part) + (last ? endSep : sep);\n  })].join(\"\"));\n}\n0 && 0;\n\n//# sourceMappingURL=pattern-to-regex.js.map\n",
    "lib/config/printer.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ConfigPrinter = exports.ChainFormatter = void 0;\nfunction _gensync() {\n  const data = require(\"gensync\");\n  _gensync = function () {\n    return data;\n  };\n  return data;\n}\nconst ChainFormatter = {\n  Programmatic: 0,\n  Config: 1\n};\nexports.ChainFormatter = ChainFormatter;\nconst Formatter = {\n  title(type, callerName, filepath) {\n    let title = \"\";\n    if (type === ChainFormatter.Programmatic) {\n      title = \"programmatic options\";\n      if (callerName) {\n        title += \" from \" + callerName;\n      }\n    } else {\n      title = \"config \" + filepath;\n    }\n    return title;\n  },\n  loc(index, envName) {\n    let loc = \"\";\n    if (index != null) {\n      loc += `.overrides[${index}]`;\n    }\n    if (envName != null) {\n      loc += `.env[\"${envName}\"]`;\n    }\n    return loc;\n  },\n  *optionsAndDescriptors(opt) {\n    const content = Object.assign({}, opt.options);\n    delete content.overrides;\n    delete content.env;\n    const pluginDescriptors = [...(yield* opt.plugins())];\n    if (pluginDescriptors.length) {\n      content.plugins = pluginDescriptors.map(d => descriptorToConfig(d));\n    }\n    const presetDescriptors = [...(yield* opt.presets())];\n    if (presetDescriptors.length) {\n      content.presets = [...presetDescriptors].map(d => descriptorToConfig(d));\n    }\n    return JSON.stringify(content, undefined, 2);\n  }\n};\nfunction descriptorToConfig(d) {\n  var _d$file;\n  let name = (_d$file = d.file) == null ? void 0 : _d$file.request;\n  if (name == null) {\n    if (typeof d.value === \"object\") {\n      name = d.value;\n    } else if (typeof d.value === \"function\") {\n      name = `[Function: ${d.value.toString().slice(0, 50)} ... ]`;\n    }\n  }\n  if (name == null) {\n    name = \"[Unknown]\";\n  }\n  if (d.options === undefined) {\n    return name;\n  } else if (d.name == null) {\n    return [name, d.options];\n  } else {\n    return [name, d.options, d.name];\n  }\n}\nclass ConfigPrinter {\n  constructor() {\n    this._stack = [];\n  }\n  configure(enabled, type, {\n    callerName,\n    filepath\n  }) {\n    if (!enabled) return () => {};\n    return (content, index, envName) => {\n      this._stack.push({\n        type,\n        callerName,\n        filepath,\n        content,\n        index,\n        envName\n      });\n    };\n  }\n  static *format(config) {\n    let title = Formatter.title(config.type, config.callerName, config.filepath);\n    const loc = Formatter.loc(config.index, config.envName);\n    if (loc) title += ` ${loc}`;\n    const content = yield* Formatter.optionsAndDescriptors(config.content);\n    return `${title}\\n${content}`;\n  }\n  *output() {\n    if (this._stack.length === 0) return \"\";\n    const configs = yield* _gensync().all(this._stack.map(s => ConfigPrinter.format(s)));\n    return configs.join(\"\\n\\n\");\n  }\n}\nexports.ConfigPrinter = ConfigPrinter;\n0 && 0;\n\n//# sourceMappingURL=printer.js.map\n",
    "lib/config/validation/removed.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _default = {\n  auxiliaryComment: {\n    message: \"Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`\"\n  },\n  blacklist: {\n    message: \"Put the specific transforms you want in the `plugins` option\"\n  },\n  breakConfig: {\n    message: \"This is not a necessary option in Babel 6\"\n  },\n  experimental: {\n    message: \"Put the specific transforms you want in the `plugins` option\"\n  },\n  externalHelpers: {\n    message: \"Use the `external-helpers` plugin instead. \" + \"Check out http://babeljs.io/docs/plugins/external-helpers/\"\n  },\n  extra: {\n    message: \"\"\n  },\n  jsxPragma: {\n    message: \"use the `pragma` option in the `react-jsx` plugin. \" + \"Check out http://babeljs.io/docs/plugins/transform-react-jsx/\"\n  },\n  loose: {\n    message: \"Specify the `loose` option for the relevant plugin you are using \" + \"or use a preset that sets the option.\"\n  },\n  metadataUsedHelpers: {\n    message: \"Not required anymore as this is enabled by default\"\n  },\n  modules: {\n    message: \"Use the corresponding module transform plugin in the `plugins` option. \" + \"Check out http://babeljs.io/docs/plugins/#modules\"\n  },\n  nonStandard: {\n    message: \"Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. \" + \"Also check out the react preset http://babeljs.io/docs/plugins/preset-react/\"\n  },\n  optional: {\n    message: \"Put the specific transforms you want in the `plugins` option\"\n  },\n  sourceMapName: {\n    message: \"The `sourceMapName` option has been removed because it makes more sense for the \" + \"tooling that calls Babel to assign `map.file` themselves.\"\n  },\n  stage: {\n    message: \"Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets\"\n  },\n  whitelist: {\n    message: \"Put the specific transforms you want in the `plugins` option\"\n  },\n  resolveModuleSource: {\n    version: 6,\n    message: \"Use `babel-plugin-module-resolver@3`'s 'resolvePath' options\"\n  },\n  metadata: {\n    version: 6,\n    message: \"Generated plugin metadata is always included in the output result\"\n  },\n  sourceMapTarget: {\n    version: 6,\n    message: \"The `sourceMapTarget` option has been removed because it makes more sense for the tooling \" + \"that calls Babel to assign `map.file` themselves.\"\n  }\n};\nexports.default = _default;\n0 && 0;\n\n//# sourceMappingURL=removed.js.map\n",
    "lib/config/validation/option-assertions.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.access = access;\nexports.assertArray = assertArray;\nexports.assertAssumptions = assertAssumptions;\nexports.assertBabelrcSearch = assertBabelrcSearch;\nexports.assertBoolean = assertBoolean;\nexports.assertCallerMetadata = assertCallerMetadata;\nexports.assertCompact = assertCompact;\nexports.assertConfigApplicableTest = assertConfigApplicableTest;\nexports.assertConfigFileSearch = assertConfigFileSearch;\nexports.assertFunction = assertFunction;\nexports.assertIgnoreList = assertIgnoreList;\nexports.assertInputSourceMap = assertInputSourceMap;\nexports.assertObject = assertObject;\nexports.assertPluginList = assertPluginList;\nexports.assertRootMode = assertRootMode;\nexports.assertSourceMaps = assertSourceMaps;\nexports.assertSourceType = assertSourceType;\nexports.assertString = assertString;\nexports.assertTargets = assertTargets;\nexports.msg = msg;\nfunction _helperCompilationTargets() {\n  const data = require(\"@babel/helper-compilation-targets\");\n  _helperCompilationTargets = function () {\n    return data;\n  };\n  return data;\n}\nvar _options = require(\"./options.js\");\nfunction msg(loc) {\n  switch (loc.type) {\n    case \"root\":\n      return ``;\n    case \"env\":\n      return `${msg(loc.parent)}.env[\"${loc.name}\"]`;\n    case \"overrides\":\n      return `${msg(loc.parent)}.overrides[${loc.index}]`;\n    case \"option\":\n      return `${msg(loc.parent)}.${loc.name}`;\n    case \"access\":\n      return `${msg(loc.parent)}[${JSON.stringify(loc.name)}]`;\n    default:\n      throw new Error(`Assertion failure: Unknown type ${loc.type}`);\n  }\n}\nfunction access(loc, name) {\n  return {\n    type: \"access\",\n    name,\n    parent: loc\n  };\n}\nfunction assertRootMode(loc, value) {\n  if (value !== undefined && value !== \"root\" && value !== \"upward\" && value !== \"upward-optional\") {\n    throw new Error(`${msg(loc)} must be a \"root\", \"upward\", \"upward-optional\" or undefined`);\n  }\n  return value;\n}\nfunction assertSourceMaps(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\" && value !== \"inline\" && value !== \"both\") {\n    throw new Error(`${msg(loc)} must be a boolean, \"inline\", \"both\", or undefined`);\n  }\n  return value;\n}\nfunction assertCompact(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\" && value !== \"auto\") {\n    throw new Error(`${msg(loc)} must be a boolean, \"auto\", or undefined`);\n  }\n  return value;\n}\nfunction assertSourceType(loc, value) {\n  if (value !== undefined && value !== \"module\" && value !== \"script\" && value !== \"unambiguous\") {\n    throw new Error(`${msg(loc)} must be \"module\", \"script\", \"unambiguous\", or undefined`);\n  }\n  return value;\n}\nfunction assertCallerMetadata(loc, value) {\n  const obj = assertObject(loc, value);\n  if (obj) {\n    if (typeof obj.name !== \"string\") {\n      throw new Error(`${msg(loc)} set but does not contain \"name\" property string`);\n    }\n    for (const prop of Object.keys(obj)) {\n      const propLoc = access(loc, prop);\n      const value = obj[prop];\n      if (value != null && typeof value !== \"boolean\" && typeof value !== \"string\" && typeof value !== \"number\") {\n        throw new Error(`${msg(propLoc)} must be null, undefined, a boolean, a string, or a number.`);\n      }\n    }\n  }\n  return value;\n}\nfunction assertInputSourceMap(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\" && (typeof value !== \"object\" || !value)) {\n    throw new Error(`${msg(loc)} must be a boolean, object, or undefined`);\n  }\n  return value;\n}\nfunction assertString(loc, value) {\n  if (value !== undefined && typeof value !== \"string\") {\n    throw new Error(`${msg(loc)} must be a string, or undefined`);\n  }\n  return value;\n}\nfunction assertFunction(loc, value) {\n  if (value !== undefined && typeof value !== \"function\") {\n    throw new Error(`${msg(loc)} must be a function, or undefined`);\n  }\n  return value;\n}\nfunction assertBoolean(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\") {\n    throw new Error(`${msg(loc)} must be a boolean, or undefined`);\n  }\n  return value;\n}\nfunction assertObject(loc, value) {\n  if (value !== undefined && (typeof value !== \"object\" || Array.isArray(value) || !value)) {\n    throw new Error(`${msg(loc)} must be an object, or undefined`);\n  }\n  return value;\n}\nfunction assertArray(loc, value) {\n  if (value != null && !Array.isArray(value)) {\n    throw new Error(`${msg(loc)} must be an array, or undefined`);\n  }\n  return value;\n}\nfunction assertIgnoreList(loc, value) {\n  const arr = assertArray(loc, value);\n  arr == null ? void 0 : arr.forEach((item, i) => assertIgnoreItem(access(loc, i), item));\n  return arr;\n}\nfunction assertIgnoreItem(loc, value) {\n  if (typeof value !== \"string\" && typeof value !== \"function\" && !(value instanceof RegExp)) {\n    throw new Error(`${msg(loc)} must be an array of string/Function/RegExp values, or undefined`);\n  }\n  return value;\n}\nfunction assertConfigApplicableTest(loc, value) {\n  if (value === undefined) {\n    return value;\n  }\n  if (Array.isArray(value)) {\n    value.forEach((item, i) => {\n      if (!checkValidTest(item)) {\n        throw new Error(`${msg(access(loc, i))} must be a string/Function/RegExp.`);\n      }\n    });\n  } else if (!checkValidTest(value)) {\n    throw new Error(`${msg(loc)} must be a string/Function/RegExp, or an array of those`);\n  }\n  return value;\n}\nfunction checkValidTest(value) {\n  return typeof value === \"string\" || typeof value === \"function\" || value instanceof RegExp;\n}\nfunction assertConfigFileSearch(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\" && typeof value !== \"string\") {\n    throw new Error(`${msg(loc)} must be a undefined, a boolean, a string, ` + `got ${JSON.stringify(value)}`);\n  }\n  return value;\n}\nfunction assertBabelrcSearch(loc, value) {\n  if (value === undefined || typeof value === \"boolean\") {\n    return value;\n  }\n  if (Array.isArray(value)) {\n    value.forEach((item, i) => {\n      if (!checkValidTest(item)) {\n        throw new Error(`${msg(access(loc, i))} must be a string/Function/RegExp.`);\n      }\n    });\n  } else if (!checkValidTest(value)) {\n    throw new Error(`${msg(loc)} must be a undefined, a boolean, a string/Function/RegExp ` + `or an array of those, got ${JSON.stringify(value)}`);\n  }\n  return value;\n}\nfunction assertPluginList(loc, value) {\n  const arr = assertArray(loc, value);\n  if (arr) {\n    arr.forEach((item, i) => assertPluginItem(access(loc, i), item));\n  }\n  return arr;\n}\nfunction assertPluginItem(loc, value) {\n  if (Array.isArray(value)) {\n    if (value.length === 0) {\n      throw new Error(`${msg(loc)} must include an object`);\n    }\n    if (value.length > 3) {\n      throw new Error(`${msg(loc)} may only be a two-tuple or three-tuple`);\n    }\n    assertPluginTarget(access(loc, 0), value[0]);\n    if (value.length > 1) {\n      const opts = value[1];\n      if (opts !== undefined && opts !== false && (typeof opts !== \"object\" || Array.isArray(opts) || opts === null)) {\n        throw new Error(`${msg(access(loc, 1))} must be an object, false, or undefined`);\n      }\n    }\n    if (value.length === 3) {\n      const name = value[2];\n      if (name !== undefined && typeof name !== \"string\") {\n        throw new Error(`${msg(access(loc, 2))} must be a string, or undefined`);\n      }\n    }\n  } else {\n    assertPluginTarget(loc, value);\n  }\n  return value;\n}\nfunction assertPluginTarget(loc, value) {\n  if ((typeof value !== \"object\" || !value) && typeof value !== \"string\" && typeof value !== \"function\") {\n    throw new Error(`${msg(loc)} must be a string, object, function`);\n  }\n  return value;\n}\nfunction assertTargets(loc, value) {\n  if ((0, _helperCompilationTargets().isBrowsersQueryValid)(value)) return value;\n  if (typeof value !== \"object\" || !value || Array.isArray(value)) {\n    throw new Error(`${msg(loc)} must be a string, an array of strings or an object`);\n  }\n  const browsersLoc = access(loc, \"browsers\");\n  const esmodulesLoc = access(loc, \"esmodules\");\n  assertBrowsersList(browsersLoc, value.browsers);\n  assertBoolean(esmodulesLoc, value.esmodules);\n  for (const key of Object.keys(value)) {\n    const val = value[key];\n    const subLoc = access(loc, key);\n    if (key === \"esmodules\") assertBoolean(subLoc, val);else if (key === \"browsers\") assertBrowsersList(subLoc, val);else if (!Object.hasOwnProperty.call(_helperCompilationTargets().TargetNames, key)) {\n      const validTargets = Object.keys(_helperCompilationTargets().TargetNames).join(\", \");\n      throw new Error(`${msg(subLoc)} is not a valid target. Supported targets are ${validTargets}`);\n    } else assertBrowserVersion(subLoc, val);\n  }\n  return value;\n}\nfunction assertBrowsersList(loc, value) {\n  if (value !== undefined && !(0, _helperCompilationTargets().isBrowsersQueryValid)(value)) {\n    throw new Error(`${msg(loc)} must be undefined, a string or an array of strings`);\n  }\n}\nfunction assertBrowserVersion(loc, value) {\n  if (typeof value === \"number\" && Math.round(value) === value) return;\n  if (typeof value === \"string\") return;\n  throw new Error(`${msg(loc)} must be a string or an integer number`);\n}\nfunction assertAssumptions(loc, value) {\n  if (value === undefined) return;\n  if (typeof value !== \"object\" || value === null) {\n    throw new Error(`${msg(loc)} must be an object or undefined.`);\n  }\n  let root = loc;\n  do {\n    root = root.parent;\n  } while (root.type !== \"root\");\n  const inPreset = root.source === \"preset\";\n  for (const name of Object.keys(value)) {\n    const subLoc = access(loc, name);\n    if (!_options.assumptionsNames.has(name)) {\n      throw new Error(`${msg(subLoc)} is not a supported assumption.`);\n    }\n    if (typeof value[name] !== \"boolean\") {\n      throw new Error(`${msg(subLoc)} must be a boolean.`);\n    }\n    if (inPreset && value[name] === false) {\n      throw new Error(`${msg(subLoc)} cannot be set to 'false' inside presets.`);\n    }\n  }\n  return value;\n}\n0 && 0;\n\n//# sourceMappingURL=option-assertions.js.map\n",
    "lib/gensync-utils/functional.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.once = once;\nvar _async = require(\"./async.js\");\nfunction once(fn) {\n  let result;\n  let resultP;\n  return function* () {\n    if (result) return result;\n    if (!(yield* (0, _async.isAsync)())) return result = yield* fn();\n    if (resultP) return yield* (0, _async.waitFor)(resultP);\n    let resolve, reject;\n    resultP = new Promise((res, rej) => {\n      resolve = res;\n      reject = rej;\n    });\n    try {\n      result = yield* fn();\n      resultP = null;\n      resolve(result);\n      return result;\n    } catch (error) {\n      reject(error);\n      throw error;\n    }\n  };\n}\n0 && 0;\n\n//# sourceMappingURL=functional.js.map\n",
    "lib/transformation/util/clone-deep.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\nfunction deepClone(value, cache) {\n  if (value !== null) {\n    if (cache.has(value)) return cache.get(value);\n    let cloned;\n    if (Array.isArray(value)) {\n      cloned = new Array(value.length);\n      cache.set(value, cloned);\n      for (let i = 0; i < value.length; i++) {\n        cloned[i] = typeof value[i] !== \"object\" ? value[i] : deepClone(value[i], cache);\n      }\n    } else {\n      cloned = {};\n      cache.set(value, cloned);\n      const keys = Object.keys(value);\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        cloned[key] = typeof value[key] !== \"object\" ? value[key] : deepClone(value[key], cache);\n      }\n    }\n    return cloned;\n  }\n  return value;\n}\nfunction _default(value) {\n  if (typeof value !== \"object\") return value;\n  return deepClone(value, new Map());\n}\n0 && 0;\n\n//# sourceMappingURL=clone-deep.js.map\n",
    "lib/transformation/file/merge-map.js": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = mergeSourceMap;\nfunction _remapping() {\n  const data = require(\"@ampproject/remapping\");\n  _remapping = function () {\n    return data;\n  };\n  return data;\n}\nfunction mergeSourceMap(inputMap, map, sourceFileName) {\n  const source = sourceFileName.replace(/\\\\/g, \"/\");\n  let found = false;\n  const result = _remapping()(rootless(map), (s, ctx) => {\n    if (s === source && !found) {\n      found = true;\n      ctx.source = \"\";\n      return rootless(inputMap);\n    }\n    return null;\n  });\n  if (typeof inputMap.sourceRoot === \"string\") {\n    result.sourceRoot = inputMap.sourceRoot;\n  }\n  return Object.assign({}, result);\n}\nfunction rootless(map) {\n  return Object.assign({}, map, {\n    sourceRoot: null\n  });\n}\n0 && 0;\n\n//# sourceMappingURL=merge-map.js.map\n"
  },
  "externals": [
    "@babel/types",
    "@babel/parser",
    "@babel/traverse",
    "@babel/template",
    "@babel/helpers",
    "@babel/code-frame",
    "@babel/helper-module-transforms",
    "semver",
    "@babel/generator",
    "gensync",
    "path",
    "debug",
    "@babel/helper-compilation-targets",
    "fs",
    "convert-source-map",
    "@ampproject/remapping"
  ]
}
