{
  "packageName": "@rollup/pluginutils",
  "packageVersion": "5.0.4",
  "request": "@rollup/pluginutils",
  "resolved": "dist/es/index.js",
  "files": {
    "dist/es/index.js": "\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.normalizePath = exports.makeLegalIdentifier = exports.extractAssignedNames = exports.default = exports.dataToEsm = exports.createFilter = exports.attachScopes = exports.addExtension = void 0;\nconst path_1 = require(\"path\");\nconst estree_walker_1 = require(\"estree-walker\");\nconst picomatch_1 = __importDefault(require(\"picomatch\"));\nconst addExtension = function addExtension(filename, ext = '.js') {\n    let result = `${filename}`;\n    if (!(0, path_1.extname)(filename))\n        result += ext;\n    return result;\n};\nexports.addExtension = addExtension;\nconst extractors = {\n    ArrayPattern(names, param) {\n        for (const element of param.elements) {\n            if (element)\n                extractors[element.type](names, element);\n        }\n    },\n    AssignmentPattern(names, param) {\n        extractors[param.left.type](names, param.left);\n    },\n    Identifier(names, param) {\n        names.push(param.name);\n    },\n    MemberExpression() { },\n    ObjectPattern(names, param) {\n        for (const prop of param.properties) {\n            // @ts-ignore Typescript reports that this is not a valid type\n            if (prop.type === 'RestElement') {\n                extractors.RestElement(names, prop);\n            }\n            else {\n                extractors[prop.value.type](names, prop.value);\n            }\n        }\n    },\n    RestElement(names, param) {\n        extractors[param.argument.type](names, param.argument);\n    }\n};\nconst extractAssignedNames = function extractAssignedNames(param) {\n    const names = [];\n    extractors[param.type](names, param);\n    return names;\n};\nexports.extractAssignedNames = extractAssignedNames;\nconst blockDeclarations = {\n    const: true,\n    let: true\n};\nclass Scope {\n    constructor(options = {}) {\n        this.parent = options.parent;\n        this.isBlockScope = !!options.block;\n        this.declarations = Object.create(null);\n        if (options.params) {\n            options.params.forEach((param) => {\n                extractAssignedNames(param).forEach((name) => {\n                    this.declarations[name] = true;\n                });\n            });\n        }\n    }\n    addDeclaration(node, isBlockDeclaration, isVar) {\n        if (!isBlockDeclaration && this.isBlockScope) {\n            // it's a `var` or function node, and this\n            // is a block scope, so we need to go up\n            this.parent.addDeclaration(node, isBlockDeclaration, isVar);\n        }\n        else if (node.id) {\n            extractAssignedNames(node.id).forEach((name) => {\n                this.declarations[name] = true;\n            });\n        }\n    }\n    contains(name) {\n        return this.declarations[name] || (this.parent ? this.parent.contains(name) : false);\n    }\n}\nconst attachScopes = function attachScopes(ast, propertyName = 'scope') {\n    let scope = new Scope();\n    (0, estree_walker_1.walk)(ast, {\n        enter(n, parent) {\n            const node = n;\n            // function foo () {...}\n            // class Foo {...}\n            if (/(Function|Class)Declaration/.test(node.type)) {\n                scope.addDeclaration(node, false, false);\n            }\n            // var foo = 1\n            if (node.type === 'VariableDeclaration') {\n                const { kind } = node;\n                const isBlockDeclaration = blockDeclarations[kind];\n                node.declarations.forEach((declaration) => {\n                    scope.addDeclaration(declaration, isBlockDeclaration, true);\n                });\n            }\n            let newScope;\n            // create new function scope\n            if (/Function/.test(node.type)) {\n                const func = node;\n                newScope = new Scope({\n                    parent: scope,\n                    block: false,\n                    params: func.params\n                });\n                // named function expressions - the name is considered\n                // part of the function's scope\n                if (func.type === 'FunctionExpression' && func.id) {\n                    newScope.addDeclaration(func, false, false);\n                }\n            }\n            // create new for scope\n            if (/For(In|Of)?Statement/.test(node.type)) {\n                newScope = new Scope({\n                    parent: scope,\n                    block: true\n                });\n            }\n            // create new block scope\n            if (node.type === 'BlockStatement' && !/Function/.test(parent.type)) {\n                newScope = new Scope({\n                    parent: scope,\n                    block: true\n                });\n            }\n            // catch clause has its own block scope\n            if (node.type === 'CatchClause') {\n                newScope = new Scope({\n                    parent: scope,\n                    params: node.param ? [node.param] : [],\n                    block: true\n                });\n            }\n            if (newScope) {\n                Object.defineProperty(node, propertyName, {\n                    value: newScope,\n                    configurable: true\n                });\n                scope = newScope;\n            }\n        },\n        leave(n) {\n            const node = n;\n            if (node[propertyName])\n                scope = scope.parent;\n        }\n    });\n    return scope;\n};\nexports.attachScopes = attachScopes;\n// Helper since Typescript can't detect readonly arrays with Array.isArray\nfunction isArray(arg) {\n    return Array.isArray(arg);\n}\nfunction ensureArray(thing) {\n    if (isArray(thing))\n        return thing;\n    if (thing == null)\n        return [];\n    return [thing];\n}\nconst normalizePath = function normalizePath(filename) {\n    return filename.split(path_1.win32.sep).join(path_1.posix.sep);\n};\nexports.normalizePath = normalizePath;\nfunction getMatcherString(id, resolutionBase) {\n    if (resolutionBase === false || (0, path_1.isAbsolute)(id) || id.startsWith('**')) {\n        return normalizePath(id);\n    }\n    // resolve('') is valid and will default to process.cwd()\n    const basePath = normalizePath((0, path_1.resolve)(resolutionBase || ''))\n        // escape all possible (posix + win) path characters that might interfere with regex\n        .replace(/[-^$*+?.()|[\\]{}]/g, '\\\\$&');\n    // Note that we use posix.join because:\n    // 1. the basePath has been normalized to use /\n    // 2. the incoming glob (id) matcher, also uses /\n    // otherwise Node will force backslash (\\) on windows\n    return path_1.posix.join(basePath, normalizePath(id));\n}\nconst createFilter = function createFilter(include, exclude, options) {\n    const resolutionBase = options && options.resolve;\n    const getMatcher = (id) => id instanceof RegExp\n        ? id\n        : {\n            test: (what) => {\n                // this refactor is a tad overly verbose but makes for easy debugging\n                const pattern = getMatcherString(id, resolutionBase);\n                const fn = (0, picomatch_1.default)(pattern, { dot: true });\n                const result = fn(what);\n                return result;\n            }\n        };\n    const includeMatchers = ensureArray(include).map(getMatcher);\n    const excludeMatchers = ensureArray(exclude).map(getMatcher);\n    return function result(id) {\n        if (typeof id !== 'string')\n            return false;\n        if (/\\0/.test(id))\n            return false;\n        const pathId = normalizePath(id);\n        for (let i = 0; i < excludeMatchers.length; ++i) {\n            const matcher = excludeMatchers[i];\n            if (matcher.test(pathId))\n                return false;\n        }\n        for (let i = 0; i < includeMatchers.length; ++i) {\n            const matcher = includeMatchers[i];\n            if (matcher.test(pathId))\n                return true;\n        }\n        return !includeMatchers.length;\n    };\n};\nexports.createFilter = createFilter;\nconst reservedWords = 'break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public';\nconst builtins = 'arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl';\nconst forbiddenIdentifiers = new Set(`${reservedWords} ${builtins}`.split(' '));\nforbiddenIdentifiers.add('');\nconst makeLegalIdentifier = function makeLegalIdentifier(str) {\n    let identifier = str\n        .replace(/-(\\w)/g, (_, letter) => letter.toUpperCase())\n        .replace(/[^$_a-zA-Z0-9]/g, '_');\n    if (/\\d/.test(identifier[0]) || forbiddenIdentifiers.has(identifier)) {\n        identifier = `_${identifier}`;\n    }\n    return identifier || '_';\n};\nexports.makeLegalIdentifier = makeLegalIdentifier;\nfunction stringify(obj) {\n    return (JSON.stringify(obj) || 'undefined').replace(/[\\u2028\\u2029]/g, (char) => `\\\\u${`000${char.charCodeAt(0).toString(16)}`.slice(-4)}`);\n}\nfunction serializeArray(arr, indent, baseIndent) {\n    let output = '[';\n    const separator = indent ? `\\n${baseIndent}${indent}` : '';\n    for (let i = 0; i < arr.length; i++) {\n        const key = arr[i];\n        output += `${i > 0 ? ',' : ''}${separator}${serialize(key, indent, baseIndent + indent)}`;\n    }\n    return `${output}${indent ? `\\n${baseIndent}` : ''}]`;\n}\nfunction serializeObject(obj, indent, baseIndent) {\n    let output = '{';\n    const separator = indent ? `\\n${baseIndent}${indent}` : '';\n    const entries = Object.entries(obj);\n    for (let i = 0; i < entries.length; i++) {\n        const [key, value] = entries[i];\n        const stringKey = makeLegalIdentifier(key) === key ? key : stringify(key);\n        output += `${i > 0 ? ',' : ''}${separator}${stringKey}:${indent ? ' ' : ''}${serialize(value, indent, baseIndent + indent)}`;\n    }\n    return `${output}${indent ? `\\n${baseIndent}` : ''}}`;\n}\nfunction serialize(obj, indent, baseIndent) {\n    if (typeof obj === 'object' && obj !== null) {\n        if (Array.isArray(obj))\n            return serializeArray(obj, indent, baseIndent);\n        if (obj instanceof Date)\n            return `new Date(${obj.getTime()})`;\n        if (obj instanceof RegExp)\n            return obj.toString();\n        return serializeObject(obj, indent, baseIndent);\n    }\n    if (typeof obj === 'number') {\n        if (obj === Infinity)\n            return 'Infinity';\n        if (obj === -Infinity)\n            return '-Infinity';\n        if (obj === 0)\n            return 1 / obj === Infinity ? '0' : '-0';\n        if (obj !== obj)\n            return 'NaN'; // eslint-disable-line no-self-compare\n    }\n    if (typeof obj === 'symbol') {\n        const key = Symbol.keyFor(obj);\n        // eslint-disable-next-line no-undefined\n        if (key !== undefined)\n            return `Symbol.for(${stringify(key)})`;\n    }\n    if (typeof obj === 'bigint')\n        return `${obj}n`;\n    return stringify(obj);\n}\nconst dataToEsm = function dataToEsm(data, options = {}) {\n    const t = options.compact ? '' : 'indent' in options ? options.indent : '\\t';\n    const _ = options.compact ? '' : ' ';\n    const n = options.compact ? '' : '\\n';\n    const declarationType = options.preferConst ? 'const' : 'var';\n    if (options.namedExports === false ||\n        typeof data !== 'object' ||\n        Array.isArray(data) ||\n        data instanceof Date ||\n        data instanceof RegExp ||\n        data === null) {\n        const code = serialize(data, options.compact ? null : t, '');\n        const magic = _ || (/^[{[\\-\\/]/.test(code) ? '' : ' '); // eslint-disable-line no-useless-escape\n        return `export default${magic}${code};`;\n    }\n    let namedExportCode = '';\n    const defaultExportRows = [];\n    for (const [key, value] of Object.entries(data)) {\n        if (key === makeLegalIdentifier(key)) {\n            if (options.objectShorthand)\n                defaultExportRows.push(key);\n            else\n                defaultExportRows.push(`${key}:${_}${key}`);\n            namedExportCode += `export ${declarationType} ${key}${_}=${_}${serialize(value, options.compact ? null : t, '')};${n}`;\n        }\n        else {\n            defaultExportRows.push(`${stringify(key)}:${_}${serialize(value, options.compact ? null : t, '')}`);\n        }\n    }\n    return `${namedExportCode}export default${_}{${n}${t}${defaultExportRows.join(`,${n}${t}`)}${n}};${n}`;\n};\nexports.dataToEsm = dataToEsm;\n// TODO: remove this in next major\nvar index = {\n    addExtension,\n    attachScopes,\n    createFilter,\n    dataToEsm,\n    extractAssignedNames,\n    makeLegalIdentifier,\n    normalizePath\n};\nexports.default = index;\n//# sourceMappingURL=index.js.map\n",
    "package.json": "{\n  \"name\": \"@rollup/pluginutils\",\n  \"version\": \"5.0.4\",\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"description\": \"A set of utility functions commonly used by Rollup plugins\",\n  \"license\": \"MIT\",\n  \"repository\": {\n    \"url\": \"rollup/plugins\",\n    \"directory\": \"packages/pluginutils\"\n  },\n  \"author\": \"Rich Harris <richard.a.harris@gmail.com>\",\n  \"homepage\": \"https://github.com/rollup/plugins/tree/master/packages/pluginutils#readme\",\n  \"bugs\": {\n    \"url\": \"https://github.com/rollup/plugins/issues\"\n  },\n  \"main\": \"./dist/cjs/index.js\",\n  \"module\": \"./dist/es/index.js\",\n  \"type\": \"commonjs\",\n  \"exports\": {\n    \"types\": \"./types/index.d.ts\",\n    \"import\": \"./dist/es/index.js\",\n    \"default\": \"./dist/cjs/index.js\"\n  },\n  \"engines\": {\n    \"node\": \">=14.0.0\"\n  },\n  \"scripts\": {\n    \"build\": \"rollup -c\",\n    \"ci:coverage\": \"nyc pnpm test && nyc report --reporter=text-lcov > coverage.lcov\",\n    \"ci:lint\": \"pnpm build && pnpm lint\",\n    \"ci:lint:commits\": \"commitlint --from=${CIRCLE_BRANCH} --to=${CIRCLE_SHA1}\",\n    \"ci:test\": \"pnpm test -- --verbose\",\n    \"prebuild\": \"del-cli dist\",\n    \"prepare\": \"if [ ! -d 'dist' ]; then pnpm build; fi\",\n    \"prerelease\": \"pnpm build\",\n    \"pretest\": \"pnpm build --sourcemap\",\n    \"release\": \"pnpm --workspace-root plugin:release --pkg $npm_package_name\",\n    \"test\": \"ava\",\n    \"test:ts\": \"tsc --noEmit\"\n  },\n  \"files\": [\n    \"dist\",\n    \"!dist/**/*.map\",\n    \"types\",\n    \"README.md\",\n    \"LICENSE\"\n  ],\n  \"keywords\": [\n    \"rollup\",\n    \"plugin\",\n    \"utils\"\n  ],\n  \"peerDependencies\": {\n    \"rollup\": \"^1.20.0||^2.0.0||^3.0.0\"\n  },\n  \"peerDependenciesMeta\": {\n    \"rollup\": {\n      \"optional\": true\n    }\n  },\n  \"dependencies\": {\n    \"@types/estree\": \"^1.0.0\",\n    \"estree-walker\": \"^2.0.2\",\n    \"picomatch\": \"^2.3.1\"\n  },\n  \"devDependencies\": {\n    \"@rollup/plugin-commonjs\": \"^23.0.0\",\n    \"@rollup/plugin-node-resolve\": \"^15.0.0\",\n    \"@rollup/plugin-typescript\": \"^9.0.1\",\n    \"@types/node\": \"^14.18.30\",\n    \"@types/picomatch\": \"^2.3.0\",\n    \"acorn\": \"^8.8.0\",\n    \"rollup\": \"^3.2.3\",\n    \"typescript\": \"^4.8.3\"\n  },\n  \"types\": \"./types/index.d.ts\",\n  \"ava\": {\n    \"extensions\": [\n      \"ts\"\n    ],\n    \"require\": [\n      \"ts-node/register\"\n    ],\n    \"workerThreads\": false,\n    \"files\": [\n      \"!**/fixtures/**\",\n      \"!**/helpers/**\",\n      \"!**/recipes/**\",\n      \"!**/types.ts\"\n    ]\n  },\n  \"nyc\": {\n    \"extension\": [\n      \".js\",\n      \".ts\"\n    ]\n  }\n}\n",
    "dist/es/package.json": "{\"type\":\"module\"}"
  },
  "externals": [
    "path",
    "estree-walker",
    "picomatch"
  ]
}
