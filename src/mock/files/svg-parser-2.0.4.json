{
  "packageName": "svg-parser",
  "packageVersion": "2.0.4",
  "request": "svg-parser",
  "resolved": "dist/svg-parser.esm.js",
  "files": {
    "dist/svg-parser.esm.js": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parse = void 0;\nfunction getLocator(source, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var offsetLine = options.offsetLine || 0;\n    var offsetColumn = options.offsetColumn || 0;\n    var originalLines = source.split('\\n');\n    var start = 0;\n    var lineRanges = originalLines.map(function (line, i) {\n        var end = start + line.length + 1;\n        var range = { start: start, end: end, line: i };\n        start = end;\n        return range;\n    });\n    var i = 0;\n    function rangeContains(range, index) {\n        return range.start <= index && index < range.end;\n    }\n    function getLocation(range, index) {\n        return { line: offsetLine + range.line, column: offsetColumn + index - range.start, character: index };\n    }\n    function locate(search, startIndex) {\n        if (typeof search === 'string') {\n            search = source.indexOf(search, startIndex || 0);\n        }\n        var range = lineRanges[i];\n        var d = search >= range.end ? 1 : -1;\n        while (range) {\n            if (rangeContains(range, search))\n                return getLocation(range, search);\n            i += d;\n            range = lineRanges[i];\n        }\n    }\n    return locate;\n}\nfunction locate(source, search, options) {\n    if (typeof options === 'number') {\n        throw new Error('locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument');\n    }\n    return getLocator(source, options)(search, options && options.startIndex);\n}\nvar validNameCharacters = /[a-zA-Z0-9:_-]/;\nvar whitespace = /[\\s\\t\\r\\n]/;\nvar quotemark = /['\"]/;\nfunction repeat(str, i) {\n    var result = '';\n    while (i--) {\n        result += str;\n    }\n    return result;\n}\nfunction parse(source) {\n    var header = '';\n    var stack = [];\n    var state = metadata;\n    var currentElement = null;\n    var root = null;\n    function error(message) {\n        var ref = locate(source, i);\n        var line = ref.line;\n        var column = ref.column;\n        var before = source.slice(0, i);\n        var beforeLine = /(^|\\n).*$/.exec(before)[0].replace(/\\t/g, '  ');\n        var after = source.slice(i);\n        var afterLine = /.*(\\n|$)/.exec(after)[0];\n        var snippet = \"\" + beforeLine + afterLine + \"\\n\" + (repeat(' ', beforeLine.length)) + \"^\";\n        throw new Error((message + \" (\" + line + \":\" + column + \"). If this is valid SVG, it's probably a bug in svg-parser. Please raise an issue at https://github.com/Rich-Harris/svg-parser/issues â€“ thanks!\\n\\n\" + snippet));\n    }\n    function metadata() {\n        while ((i < source.length && source[i] !== '<') || !validNameCharacters.test(source[i + 1])) {\n            header += source[i++];\n        }\n        return neutral();\n    }\n    function neutral() {\n        var text = '';\n        while (i < source.length && source[i] !== '<') {\n            text += source[i++];\n        }\n        if (/\\S/.test(text)) {\n            currentElement.children.push({ type: 'text', value: text });\n        }\n        if (source[i] === '<') {\n            return tag;\n        }\n        return neutral;\n    }\n    function tag() {\n        var char = source[i];\n        if (char === '?') {\n            return neutral;\n        } // <?xml...\n        if (char === '!') {\n            if (source.slice(i + 1, i + 3) === '--') {\n                return comment;\n            }\n            if (source.slice(i + 1, i + 8) === '[CDATA[') {\n                return cdata;\n            }\n            if (/doctype/i.test(source.slice(i + 1, i + 8))) {\n                return neutral;\n            }\n        }\n        if (char === '/') {\n            return closingTag;\n        }\n        var tagName = getName();\n        var element = {\n            type: 'element',\n            tagName: tagName,\n            properties: {},\n            children: []\n        };\n        if (currentElement) {\n            currentElement.children.push(element);\n        }\n        else {\n            root = element;\n        }\n        var attribute;\n        while (i < source.length && (attribute = getAttribute())) {\n            element.properties[attribute.name] = attribute.value;\n        }\n        var selfClosing = false;\n        if (source[i] === '/') {\n            i += 1;\n            selfClosing = true;\n        }\n        if (source[i] !== '>') {\n            error('Expected >');\n        }\n        if (!selfClosing) {\n            currentElement = element;\n            stack.push(element);\n        }\n        return neutral;\n    }\n    function comment() {\n        var index = source.indexOf('-->', i);\n        if (!~index) {\n            error('expected -->');\n        }\n        i = index + 2;\n        return neutral;\n    }\n    function cdata() {\n        var index = source.indexOf(']]>', i);\n        if (!~index) {\n            error('expected ]]>');\n        }\n        currentElement.children.push(source.slice(i + 7, index));\n        i = index + 2;\n        return neutral;\n    }\n    function closingTag() {\n        var tagName = getName();\n        if (!tagName) {\n            error('Expected tag name');\n        }\n        if (tagName !== currentElement.tagName) {\n            error((\"Expected closing tag </\" + tagName + \"> to match opening tag <\" + (currentElement.tagName) + \">\"));\n        }\n        allowSpaces();\n        if (source[i] !== '>') {\n            error('Expected >');\n        }\n        stack.pop();\n        currentElement = stack[stack.length - 1];\n        return neutral;\n    }\n    function getName() {\n        var name = '';\n        while (i < source.length && validNameCharacters.test(source[i])) {\n            name += source[i++];\n        }\n        return name;\n    }\n    function getAttribute() {\n        if (!whitespace.test(source[i])) {\n            return null;\n        }\n        allowSpaces();\n        var name = getName();\n        if (!name) {\n            return null;\n        }\n        var value = true;\n        allowSpaces();\n        if (source[i] === '=') {\n            i += 1;\n            allowSpaces();\n            value = getAttributeValue();\n            if (!isNaN(value) && value.trim() !== '') {\n                value = +value;\n            } // TODO whitelist numeric attributes?\n        }\n        return { name: name, value: value };\n    }\n    function getAttributeValue() {\n        return quotemark.test(source[i]) ? getQuotedAttributeValue() : getUnquotedAttributeValue();\n    }\n    function getUnquotedAttributeValue() {\n        var value = '';\n        do {\n            var char = source[i];\n            if (char === ' ' || char === '>' || char === '/') {\n                return value;\n            }\n            value += char;\n            i += 1;\n        } while (i < source.length);\n        return value;\n    }\n    function getQuotedAttributeValue() {\n        var quotemark = source[i++];\n        var value = '';\n        var escaped = false;\n        while (i < source.length) {\n            var char = source[i++];\n            if (char === quotemark && !escaped) {\n                return value;\n            }\n            if (char === '\\\\' && !escaped) {\n                escaped = true;\n            }\n            value += escaped ? (\"\\\\\" + char) : char;\n            escaped = false;\n        }\n    }\n    function allowSpaces() {\n        while (i < source.length && whitespace.test(source[i])) {\n            i += 1;\n        }\n    }\n    var i = metadata.length;\n    while (i < source.length) {\n        if (!state) {\n            error('Unexpected character');\n        }\n        state = state();\n        i += 1;\n    }\n    if (state !== neutral) {\n        error('Unexpected end of input');\n    }\n    if (root.tagName === 'svg') {\n        root.metadata = header;\n    }\n    return {\n        type: 'root',\n        children: [root]\n    };\n}\nexports.parse = parse;\n//# sourceMappingURL=svg-parser.esm.js.map\n",
    "package.json": "{\n  \"name\": \"svg-parser\",\n  \"version\": \"2.0.4\",\n  \"description\": \"Create a JSON-friendly object from an SVG string\",\n  \"main\": \"dist/svg-parser.umd.js\",\n  \"jsnext:main\": \"dist/svg-parser.esm.js\",\n  \"module\": \"dist/svg-parser.esm.js\",\n  \"files\": [\n    \"dist\",\n    \"README.md\"\n  ],\n  \"scripts\": {\n    \"test\": \"mocha\",\n    \"build\": \"rm -rf dist && rollup -c\",\n    \"pretest\": \"npm run build\",\n    \"prepublish\": \"npm run lint && npm test\",\n    \"lint\": \"eslint src\"\n  },\n  \"prettier\": {\n    \"singleQuote\": true,\n    \"useTabs\": true,\n    \"printWidth\": 100\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/Rich-Harris/svg-parser.git\"\n  },\n  \"keywords\": [\n    \"SVG\",\n    \"parser\",\n    \"JSON\",\n    \"object\"\n  ],\n  \"author\": \"Rich Harris\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/Rich-Harris/svg-parser/issues\"\n  },\n  \"homepage\": \"https://github.com/Rich-Harris/svg-parser#README\",\n  \"devDependencies\": {\n    \"@rollup/plugin-buble\": \"^0.21.0\",\n    \"@rollup/plugin-node-resolve\": \"^7.0.0\",\n    \"eslint\": \"^3.2.2\",\n    \"locate-character\": \"^2.0.5\",\n    \"mocha\": \"^3.0.1\",\n    \"prettier\": \"^1.18.2\",\n    \"rollup\": \"^1.29.0\",\n    \"source-map-support\": \"^0.4.2\"\n  }\n}\n"
  },
  "externals": []
}
