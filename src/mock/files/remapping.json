{
  "packageName": "@ampproject/remapping",
  "packageVersion": "2.2.1",
  "request": "@ampproject/remapping",
  "resolved": "dist/remapping.umd.js",
  "files": {
    "dist/remapping.umd.js": "(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('@jridgewell/trace-mapping'), require('@jridgewell/gen-mapping')) :\n    typeof define === 'function' && define.amd ? define(['@jridgewell/trace-mapping', '@jridgewell/gen-mapping'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.remapping = factory(global.traceMapping, global.genMapping));\n})(this, (function (traceMapping, genMapping) { 'use strict';\n\n    const SOURCELESS_MAPPING = /* #__PURE__ */ SegmentObject('', -1, -1, '', null);\n    const EMPTY_SOURCES = [];\n    function SegmentObject(source, line, column, name, content) {\n        return { source, line, column, name, content };\n    }\n    function Source(map, sources, source, content) {\n        return {\n            map,\n            sources,\n            source,\n            content,\n        };\n    }\n    /**\n     * MapSource represents a single sourcemap, with the ability to trace mappings into its child nodes\n     * (which may themselves be SourceMapTrees).\n     */\n    function MapSource(map, sources) {\n        return Source(map, sources, '', null);\n    }\n    /**\n     * A \"leaf\" node in the sourcemap tree, representing an original, unmodified source file. Recursive\n     * segment tracing ends at the `OriginalSource`.\n     */\n    function OriginalSource(source, content) {\n        return Source(null, EMPTY_SOURCES, source, content);\n    }\n    /**\n     * traceMappings is only called on the root level SourceMapTree, and begins the process of\n     * resolving each mapping in terms of the original source files.\n     */\n    function traceMappings(tree) {\n        // TODO: Eventually support sourceRoot, which has to be removed because the sources are already\n        // fully resolved. We'll need to make sources relative to the sourceRoot before adding them.\n        const gen = new genMapping.GenMapping({ file: tree.map.file });\n        const { sources: rootSources, map } = tree;\n        const rootNames = map.names;\n        const rootMappings = traceMapping.decodedMappings(map);\n        for (let i = 0; i < rootMappings.length; i++) {\n            const segments = rootMappings[i];\n            for (let j = 0; j < segments.length; j++) {\n                const segment = segments[j];\n                const genCol = segment[0];\n                let traced = SOURCELESS_MAPPING;\n                // 1-length segments only move the current generated column, there's no source information\n                // to gather from it.\n                if (segment.length !== 1) {\n                    const source = rootSources[segment[1]];\n                    traced = originalPositionFor(source, segment[2], segment[3], segment.length === 5 ? rootNames[segment[4]] : '');\n                    // If the trace is invalid, then the trace ran into a sourcemap that doesn't contain a\n                    // respective segment into an original source.\n                    if (traced == null)\n                        continue;\n                }\n                const { column, line, name, content, source } = traced;\n                genMapping.maybeAddSegment(gen, i, genCol, source, line, column, name);\n                if (source && content != null)\n                    genMapping.setSourceContent(gen, source, content);\n            }\n        }\n        return gen;\n    }\n    /**\n     * originalPositionFor is only called on children SourceMapTrees. It recurses down into its own\n     * child SourceMapTrees, until we find the original source map.\n     */\n    function originalPositionFor(source, line, column, name) {\n        if (!source.map) {\n            return SegmentObject(source.source, line, column, name, source.content);\n        }\n        const segment = traceMapping.traceSegment(source.map, line, column);\n        // If we couldn't find a segment, then this doesn't exist in the sourcemap.\n        if (segment == null)\n            return null;\n        // 1-length segments only move the current generated column, there's no source information\n        // to gather from it.\n        if (segment.length === 1)\n            return SOURCELESS_MAPPING;\n        return originalPositionFor(source.sources[segment[1]], segment[2], segment[3], segment.length === 5 ? source.map.names[segment[4]] : name);\n    }\n\n    function asArray(value) {\n        if (Array.isArray(value))\n            return value;\n        return [value];\n    }\n    /**\n     * Recursively builds a tree structure out of sourcemap files, with each node\n     * being either an `OriginalSource` \"leaf\" or a `SourceMapTree` composed of\n     * `OriginalSource`s and `SourceMapTree`s.\n     *\n     * Every sourcemap is composed of a collection of source files and mappings\n     * into locations of those source files. When we generate a `SourceMapTree` for\n     * the sourcemap, we attempt to load each source file's own sourcemap. If it\n     * does not have an associated sourcemap, it is considered an original,\n     * unmodified source file.\n     */\n    function buildSourceMapTree(input, loader) {\n        const maps = asArray(input).map((m) => new traceMapping.TraceMap(m, ''));\n        const map = maps.pop();\n        for (let i = 0; i < maps.length; i++) {\n            if (maps[i].sources.length > 1) {\n                throw new Error(`Transformation map ${i} must have exactly one source file.\\n` +\n                    'Did you specify these with the most recent transformation maps first?');\n            }\n        }\n        let tree = build(map, loader, '', 0);\n        for (let i = maps.length - 1; i >= 0; i--) {\n            tree = MapSource(maps[i], [tree]);\n        }\n        return tree;\n    }\n    function build(map, loader, importer, importerDepth) {\n        const { resolvedSources, sourcesContent } = map;\n        const depth = importerDepth + 1;\n        const children = resolvedSources.map((sourceFile, i) => {\n            // The loading context gives the loader more information about why this file is being loaded\n            // (eg, from which importer). It also allows the loader to override the location of the loaded\n            // sourcemap/original source, or to override the content in the sourcesContent field if it's\n            // an unmodified source file.\n            const ctx = {\n                importer,\n                depth,\n                source: sourceFile || '',\n                content: undefined,\n            };\n            // Use the provided loader callback to retrieve the file's sourcemap.\n            // TODO: We should eventually support async loading of sourcemap files.\n            const sourceMap = loader(ctx.source, ctx);\n            const { source, content } = ctx;\n            // If there is a sourcemap, then we need to recurse into it to load its source files.\n            if (sourceMap)\n                return build(new traceMapping.TraceMap(sourceMap, source), loader, source, depth);\n            // Else, it's an an unmodified source file.\n            // The contents of this unmodified source file can be overridden via the loader context,\n            // allowing it to be explicitly null or a string. If it remains undefined, we fall back to\n            // the importing sourcemap's `sourcesContent` field.\n            const sourceContent = content !== undefined ? content : sourcesContent ? sourcesContent[i] : null;\n            return OriginalSource(source, sourceContent);\n        });\n        return MapSource(map, children);\n    }\n\n    /**\n     * A SourceMap v3 compatible sourcemap, which only includes fields that were\n     * provided to it.\n     */\n    class SourceMap {\n        constructor(map, options) {\n            const out = options.decodedMappings ? genMapping.toDecodedMap(map) : genMapping.toEncodedMap(map);\n            this.version = out.version; // SourceMap spec says this should be first.\n            this.file = out.file;\n            this.mappings = out.mappings;\n            this.names = out.names;\n            this.sourceRoot = out.sourceRoot;\n            this.sources = out.sources;\n            if (!options.excludeContent) {\n                this.sourcesContent = out.sourcesContent;\n            }\n        }\n        toString() {\n            return JSON.stringify(this);\n        }\n    }\n\n    /**\n     * Traces through all the mappings in the root sourcemap, through the sources\n     * (and their sourcemaps), all the way back to the original source location.\n     *\n     * `loader` will be called every time we encounter a source file. If it returns\n     * a sourcemap, we will recurse into that sourcemap to continue the trace. If\n     * it returns a falsey value, that source file is treated as an original,\n     * unmodified source file.\n     *\n     * Pass `excludeContent` to exclude any self-containing source file content\n     * from the output sourcemap.\n     *\n     * Pass `decodedMappings` to receive a SourceMap with decoded (instead of\n     * VLQ encoded) mappings.\n     */\n    function remapping(input, loader, options) {\n        const opts = typeof options === 'object' ? options : { excludeContent: !!options, decodedMappings: false };\n        const tree = buildSourceMapTree(input, loader);\n        return new SourceMap(traceMappings(tree), opts);\n    }\n\n    return remapping;\n\n}));\n//# sourceMappingURL=remapping.umd.js.map\n",
    "package.json": "{\n  \"name\": \"@ampproject/remapping\",\n  \"version\": \"2.2.1\",\n  \"description\": \"Remap sequential sourcemaps through transformations to point at the original source code\",\n  \"keywords\": [\n    \"source\",\n    \"map\",\n    \"remap\"\n  ],\n  \"main\": \"dist/remapping.umd.js\",\n  \"module\": \"dist/remapping.mjs\",\n  \"types\": \"dist/types/remapping.d.ts\",\n  \"exports\": {\n    \".\": [\n      {\n        \"types\": \"./dist/types/remapping.d.ts\",\n        \"browser\": \"./dist/remapping.umd.js\",\n        \"require\": \"./dist/remapping.umd.js\",\n        \"import\": \"./dist/remapping.mjs\"\n      },\n      \"./dist/remapping.umd.js\"\n    ],\n    \"./package.json\": \"./package.json\"\n  },\n  \"files\": [\n    \"dist\"\n  ],\n  \"author\": \"Justin Ridgewell <jridgewell@google.com>\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/ampproject/remapping.git\"\n  },\n  \"license\": \"Apache-2.0\",\n  \"engines\": {\n    \"node\": \">=6.0.0\"\n  },\n  \"scripts\": {\n    \"build\": \"run-s -n build:*\",\n    \"build:rollup\": \"rollup -c rollup.config.js\",\n    \"build:ts\": \"tsc --project tsconfig.build.json\",\n    \"lint\": \"run-s -n lint:*\",\n    \"lint:prettier\": \"npm run test:lint:prettier -- --write\",\n    \"lint:ts\": \"npm run test:lint:ts -- --fix\",\n    \"prebuild\": \"rm -rf dist\",\n    \"prepublishOnly\": \"npm run preversion\",\n    \"preversion\": \"run-s test build\",\n    \"test\": \"run-s -n test:lint test:only\",\n    \"test:debug\": \"node --inspect-brk node_modules/.bin/jest --runInBand\",\n    \"test:lint\": \"run-s -n test:lint:*\",\n    \"test:lint:prettier\": \"prettier --check '{src,test}/**/*.ts'\",\n    \"test:lint:ts\": \"eslint '{src,test}/**/*.ts'\",\n    \"test:only\": \"jest --coverage\",\n    \"test:watch\": \"jest --coverage --watch\"\n  },\n  \"devDependencies\": {\n    \"@rollup/plugin-typescript\": \"8.3.2\",\n    \"@types/jest\": \"27.4.1\",\n    \"@typescript-eslint/eslint-plugin\": \"5.20.0\",\n    \"@typescript-eslint/parser\": \"5.20.0\",\n    \"eslint\": \"8.14.0\",\n    \"eslint-config-prettier\": \"8.5.0\",\n    \"jest\": \"27.5.1\",\n    \"jest-config\": \"27.5.1\",\n    \"npm-run-all\": \"4.1.5\",\n    \"prettier\": \"2.6.2\",\n    \"rollup\": \"2.70.2\",\n    \"ts-jest\": \"27.1.4\",\n    \"tslib\": \"2.4.0\",\n    \"typescript\": \"4.6.3\"\n  },\n  \"dependencies\": {\n    \"@jridgewell/gen-mapping\": \"^0.3.0\",\n    \"@jridgewell/trace-mapping\": \"^0.3.9\"\n  }\n}\n"
  },
  "externals": [
    "@jridgewell/trace-mapping",
    "@jridgewell/gen-mapping"
  ]
}
