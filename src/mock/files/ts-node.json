{
  "packageName": "ts-node",
  "packageVersion": "10.9.2",
  "request": "ts-node",
  "resolved": "dist/index.js",
  "files": {
    "dist/index.js": "\"use strict\";\nvar _a, _b;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createEsmHooks = exports.createFromPreloadedConfig = exports.create = exports.register = exports.TSError = exports.DEFAULTS = exports.VERSION = exports.debug = exports.INSPECT_CUSTOM = exports.env = exports.REGISTER_INSTANCE = exports.createRepl = void 0;\nconst path_1 = require(\"path\");\nconst module_1 = require(\"module\");\nconst util = require(\"util\");\nconst url_1 = require(\"url\");\nconst make_error_1 = require(\"make-error\");\nconst util_1 = require(\"./util\");\nconst configuration_1 = require(\"./configuration\");\nconst module_type_classifier_1 = require(\"./module-type-classifier\");\nconst resolver_functions_1 = require(\"./resolver-functions\");\nconst cjs_resolve_hooks_1 = require(\"./cjs-resolve-hooks\");\nconst node_module_type_classifier_1 = require(\"./node-module-type-classifier\");\nconst file_extensions_1 = require(\"./file-extensions\");\nconst ts_transpile_module_1 = require(\"./ts-transpile-module\");\nvar repl_1 = require(\"./repl\");\nObject.defineProperty(exports, \"createRepl\", { enumerable: true, get: function () { return repl_1.createRepl; } });\n/**\n * Does this version of node obey the package.json \"type\" field\n * and throw ERR_REQUIRE_ESM when attempting to require() an ESM modules.\n */\nconst engineSupportsPackageTypeField = parseInt(process.versions.node.split('.')[0], 10) >= 12;\n/**\n * Assert that script can be loaded as CommonJS when we attempt to require it.\n * If it should be loaded as ESM, throw ERR_REQUIRE_ESM like node does.\n *\n * Loaded conditionally so we don't need to support older node versions\n */\nlet assertScriptCanLoadAsCJS = engineSupportsPackageTypeField\n    ? require('../dist-raw/node-internal-modules-cjs-loader').assertScriptCanLoadAsCJSImpl\n    : () => {\n        /* noop */\n    };\n/**\n * Registered `ts-node` instance information.\n */\nexports.REGISTER_INSTANCE = Symbol.for('ts-node.register.instance');\n/** @internal */\nexports.env = process.env;\n/**\n * @internal\n */\nexports.INSPECT_CUSTOM = util.inspect.custom || 'inspect';\n/**\n * Debugging `ts-node`.\n */\nconst shouldDebug = (0, util_1.yn)(exports.env.TS_NODE_DEBUG);\n/** @internal */\nexports.debug = shouldDebug\n    ? (...args) => console.log(`[ts-node ${new Date().toISOString()}]`, ...args)\n    : () => undefined;\nconst debugFn = shouldDebug\n    ? (key, fn) => {\n        let i = 0;\n        return (x) => {\n            (0, exports.debug)(key, x, ++i);\n            return fn(x);\n        };\n    }\n    : (_, fn) => fn;\n/**\n * Export the current version.\n */\nexports.VERSION = require('../package.json').version;\n/**\n * Default register options, including values specified via environment\n * variables.\n * @internal\n */\nexports.DEFAULTS = {\n    cwd: (_a = exports.env.TS_NODE_CWD) !== null && _a !== void 0 ? _a : exports.env.TS_NODE_DIR,\n    emit: (0, util_1.yn)(exports.env.TS_NODE_EMIT),\n    scope: (0, util_1.yn)(exports.env.TS_NODE_SCOPE),\n    scopeDir: exports.env.TS_NODE_SCOPE_DIR,\n    files: (0, util_1.yn)(exports.env.TS_NODE_FILES),\n    pretty: (0, util_1.yn)(exports.env.TS_NODE_PRETTY),\n    compiler: exports.env.TS_NODE_COMPILER,\n    compilerOptions: (0, util_1.parse)(exports.env.TS_NODE_COMPILER_OPTIONS),\n    ignore: (0, util_1.split)(exports.env.TS_NODE_IGNORE),\n    project: exports.env.TS_NODE_PROJECT,\n    skipProject: (0, util_1.yn)(exports.env.TS_NODE_SKIP_PROJECT),\n    skipIgnore: (0, util_1.yn)(exports.env.TS_NODE_SKIP_IGNORE),\n    preferTsExts: (0, util_1.yn)(exports.env.TS_NODE_PREFER_TS_EXTS),\n    ignoreDiagnostics: (0, util_1.split)(exports.env.TS_NODE_IGNORE_DIAGNOSTICS),\n    transpileOnly: (0, util_1.yn)(exports.env.TS_NODE_TRANSPILE_ONLY),\n    typeCheck: (0, util_1.yn)(exports.env.TS_NODE_TYPE_CHECK),\n    compilerHost: (0, util_1.yn)(exports.env.TS_NODE_COMPILER_HOST),\n    logError: (0, util_1.yn)(exports.env.TS_NODE_LOG_ERROR),\n    experimentalReplAwait: (_b = (0, util_1.yn)(exports.env.TS_NODE_EXPERIMENTAL_REPL_AWAIT)) !== null && _b !== void 0 ? _b : undefined,\n    tsTrace: console.log.bind(console),\n};\n/**\n * TypeScript diagnostics error.\n */\nclass TSError extends make_error_1.BaseError {\n    constructor(diagnosticText, diagnosticCodes, diagnostics = []) {\n        super(`тип Unable to compile TypeScript:\\n${diagnosticText}`);\n        this.diagnosticCodes = diagnosticCodes;\n        this.name = 'TSError';\n        Object.defineProperty(this, 'diagnosticText', {\n            configurable: true,\n            writable: true,\n            value: diagnosticText,\n        });\n        Object.defineProperty(this, 'diagnostics', {\n            configurable: true,\n            writable: true,\n            value: diagnostics,\n        });\n    }\n    /**\n     * @internal\n     */\n    [exports.INSPECT_CUSTOM]() {\n        return this.diagnosticText;\n    }\n}\nexports.TSError = TSError;\nconst TS_NODE_SERVICE_BRAND = Symbol('TS_NODE_SERVICE_BRAND');\nfunction register(serviceOrOpts) {\n    // Is this a Service or a RegisterOptions?\n    let service = serviceOrOpts;\n    if (!(serviceOrOpts === null || serviceOrOpts === void 0 ? void 0 : serviceOrOpts[TS_NODE_SERVICE_BRAND])) {\n        // Not a service; is options\n        service = create((serviceOrOpts !== null && serviceOrOpts !== void 0 ? serviceOrOpts : {}));\n    }\n    const originalJsHandler = require.extensions['.js'];\n    // Expose registered instance globally.\n    process[exports.REGISTER_INSTANCE] = service;\n    // Register the extensions.\n    registerExtensions(service.options.preferTsExts, service.extensions.compiled, service, originalJsHandler);\n    (0, cjs_resolve_hooks_1.installCommonjsResolveHooksIfNecessary)(service);\n    // Require specified modules before start-up.\n    module_1.Module._preloadModules(service.options.require);\n    return service;\n}\nexports.register = register;\n/**\n * Create TypeScript compiler instance.\n *\n * @category Basic\n */\nfunction create(rawOptions = {}) {\n    const foundConfigResult = (0, configuration_1.findAndReadConfig)(rawOptions);\n    return createFromPreloadedConfig(foundConfigResult);\n}\nexports.create = create;\n/** @internal */\nfunction createFromPreloadedConfig(foundConfigResult) {\n    var _a, _b, _c, _d;\n    const { configFilePath, cwd, options, config, compiler, projectLocalResolveDir, optionBasePaths, } = foundConfigResult;\n    const projectLocalResolveHelper = (0, util_1.createProjectLocalResolveHelper)(projectLocalResolveDir);\n    const ts = (0, configuration_1.loadCompiler)(compiler);\n    // Experimental REPL await is not compatible targets lower than ES2018\n    const targetSupportsTla = config.options.target >= ts.ScriptTarget.ES2018;\n    if (options.experimentalReplAwait === true && !targetSupportsTla) {\n        throw new Error('Experimental REPL await is not compatible with targets lower than ES2018');\n    }\n    // Top-level await was added in TS 3.8\n    const tsVersionSupportsTla = (0, util_1.versionGteLt)(ts.version, '3.8.0');\n    if (options.experimentalReplAwait === true && !tsVersionSupportsTla) {\n        throw new Error('Experimental REPL await is not compatible with TypeScript versions older than 3.8');\n    }\n    const shouldReplAwait = options.experimentalReplAwait !== false &&\n        tsVersionSupportsTla &&\n        targetSupportsTla;\n    // swc implies two other options\n    // typeCheck option was implemented specifically to allow overriding tsconfig transpileOnly from the command-line\n    // So we should allow using typeCheck to override swc\n    if (options.swc && !options.typeCheck) {\n        if (options.transpileOnly === false) {\n            throw new Error(\"Cannot enable 'swc' option with 'transpileOnly: false'.  'swc' implies 'transpileOnly'.\");\n        }\n        if (options.transpiler) {\n            throw new Error(\"Cannot specify both 'swc' and 'transpiler' options.  'swc' uses the built-in swc transpiler.\");\n        }\n    }\n    const readFile = options.readFile || ts.sys.readFile;\n    const fileExists = options.fileExists || ts.sys.fileExists;\n    // typeCheck can override transpileOnly, useful for CLI flag to override config file\n    const transpileOnly = (options.transpileOnly === true || options.swc === true) &&\n        options.typeCheck !== true;\n    let transpiler = undefined;\n    let transpilerBasePath = undefined;\n    if (options.transpiler) {\n        transpiler = options.transpiler;\n        transpilerBasePath = optionBasePaths.transpiler;\n    }\n    else if (options.swc) {\n        transpiler = require.resolve('./transpilers/swc.js');\n        transpilerBasePath = optionBasePaths.swc;\n    }\n    const transformers = options.transformers || undefined;\n    const diagnosticFilters = [\n        {\n            appliesToAllFiles: true,\n            filenamesAbsolute: [],\n            diagnosticsIgnored: [\n                6059,\n                18002,\n                18003,\n                ...(options.experimentalTsImportSpecifiers\n                    ? [\n                        2691, // \"An import path cannot end with a '.ts' extension. Consider importing '<specifier without ext>' instead.\"\n                    ]\n                    : []),\n                ...(options.ignoreDiagnostics || []),\n            ].map(Number),\n        },\n    ];\n    const configDiagnosticList = filterDiagnostics(config.errors, diagnosticFilters);\n    const outputCache = new Map();\n    const configFileDirname = configFilePath ? (0, path_1.dirname)(configFilePath) : null;\n    const scopeDir = (_c = (_b = (_a = options.scopeDir) !== null && _a !== void 0 ? _a : config.options.rootDir) !== null && _b !== void 0 ? _b : configFileDirname) !== null && _c !== void 0 ? _c : cwd;\n    const ignoreBaseDir = configFileDirname !== null && configFileDirname !== void 0 ? configFileDirname : cwd;\n    const isScoped = options.scope\n        ? (fileName) => (0, path_1.relative)(scopeDir, fileName).charAt(0) !== '.'\n        : () => true;\n    const shouldIgnore = createIgnore(ignoreBaseDir, options.skipIgnore\n        ? []\n        : (options.ignore || ['(?:^|/)node_modules/']).map((str) => new RegExp(str)));\n    const diagnosticHost = {\n        getNewLine: () => ts.sys.newLine,\n        getCurrentDirectory: () => cwd,\n        // TODO switch to getCanonicalFileName we already create later in scope\n        getCanonicalFileName: ts.sys.useCaseSensitiveFileNames\n            ? (x) => x\n            : (x) => x.toLowerCase(),\n    };\n    if (options.transpileOnly && typeof transformers === 'function') {\n        throw new TypeError('Transformers function is unavailable in \"--transpile-only\"');\n    }\n    let createTranspiler = initializeTranspilerFactory();\n    function initializeTranspilerFactory() {\n        var _a;\n        if (transpiler) {\n            if (!transpileOnly)\n                throw new Error('Custom transpiler can only be used when transpileOnly is enabled.');\n            const transpilerName = typeof transpiler === 'string' ? transpiler : transpiler[0];\n            const transpilerOptions = typeof transpiler === 'string' ? {} : (_a = transpiler[1]) !== null && _a !== void 0 ? _a : {};\n            const transpilerConfigLocalResolveHelper = transpilerBasePath\n                ? (0, util_1.createProjectLocalResolveHelper)(transpilerBasePath)\n                : projectLocalResolveHelper;\n            const transpilerPath = transpilerConfigLocalResolveHelper(transpilerName, true);\n            const transpilerFactory = require(transpilerPath)\n                .create;\n            return createTranspiler;\n            function createTranspiler(compilerOptions, nodeModuleEmitKind) {\n                return transpilerFactory === null || transpilerFactory === void 0 ? void 0 : transpilerFactory({\n                    service: {\n                        options,\n                        config: {\n                            ...config,\n                            options: compilerOptions,\n                        },\n                        projectLocalResolveHelper,\n                    },\n                    transpilerConfigLocalResolveHelper,\n                    nodeModuleEmitKind,\n                    ...transpilerOptions,\n                });\n            }\n        }\n    }\n    /**\n     * True if require() hooks should interop with experimental ESM loader.\n     * Enabled explicitly via a flag since it is a breaking change.\n     */\n    let experimentalEsmLoader = false;\n    function enableExperimentalEsmLoaderInterop() {\n        experimentalEsmLoader = true;\n    }\n    // Install source map support and read from memory cache.\n    installSourceMapSupport();\n    function installSourceMapSupport() {\n        const sourceMapSupport = require('@cspotcode/source-map-support');\n        sourceMapSupport.install({\n            environment: 'node',\n            retrieveFile(pathOrUrl) {\n                var _a;\n                let path = pathOrUrl;\n                // If it's a file URL, convert to local path\n                // Note: fileURLToPath does not exist on early node v10\n                // I could not find a way to handle non-URLs except to swallow an error\n                if (experimentalEsmLoader && path.startsWith('file://')) {\n                    try {\n                        path = (0, url_1.fileURLToPath)(path);\n                    }\n                    catch (e) {\n                        /* swallow error */\n                    }\n                }\n                path = (0, util_1.normalizeSlashes)(path);\n                return ((_a = outputCache.get(path)) === null || _a === void 0 ? void 0 : _a.content) || '';\n            },\n            redirectConflictingLibrary: true,\n            onConflictingLibraryRedirect(request, parent, isMain, options, redirectedRequest) {\n                (0, exports.debug)(`Redirected an attempt to require source-map-support to instead receive @cspotcode/source-map-support.  \"${parent.filename}\" attempted to require or resolve \"${request}\" and was redirected to \"${redirectedRequest}\".`);\n            },\n        });\n    }\n    const shouldHavePrettyErrors = options.pretty === undefined ? process.stdout.isTTY : options.pretty;\n    const formatDiagnostics = shouldHavePrettyErrors\n        ? ts.formatDiagnosticsWithColorAndContext || ts.formatDiagnostics\n        : ts.formatDiagnostics;\n    function createTSError(diagnostics) {\n        const diagnosticText = formatDiagnostics(diagnostics, diagnosticHost);\n        const diagnosticCodes = diagnostics.map((x) => x.code);\n        return new TSError(diagnosticText, diagnosticCodes, diagnostics);\n    }\n    function reportTSError(configDiagnosticList) {\n        const error = createTSError(configDiagnosticList);\n        if (options.logError) {\n            // Print error in red color and continue execution.\n            console.error('\\x1b[31m%s\\x1b[0m', error);\n        }\n        else {\n            // Throw error and exit the script.\n            throw error;\n        }\n    }\n    // Render the configuration errors.\n    if (configDiagnosticList.length)\n        reportTSError(configDiagnosticList);\n    const jsxEmitPreserve = config.options.jsx === ts.JsxEmit.Preserve;\n    /**\n     * Get the extension for a transpiled file.\n     * [MUST_UPDATE_FOR_NEW_FILE_EXTENSIONS]\n     */\n    function getEmitExtension(path) {\n        const lastDotIndex = path.lastIndexOf('.');\n        if (lastDotIndex >= 0) {\n            const ext = path.slice(lastDotIndex);\n            switch (ext) {\n                case '.js':\n                case '.ts':\n                    return '.js';\n                case '.jsx':\n                case '.tsx':\n                    return jsxEmitPreserve ? '.jsx' : '.js';\n                case '.mjs':\n                case '.mts':\n                    return '.mjs';\n                case '.cjs':\n                case '.cts':\n                    return '.cjs';\n            }\n        }\n        return '.js';\n    }\n    /**\n     * Get output from TS compiler w/typechecking.  `undefined` in `transpileOnly`\n     * mode.\n     */\n    let getOutput;\n    let getTypeInfo;\n    const getCanonicalFileName = ts.createGetCanonicalFileName(ts.sys.useCaseSensitiveFileNames);\n    const moduleTypeClassifier = (0, module_type_classifier_1.createModuleTypeClassifier)({\n        basePath: (_d = options.optionBasePaths) === null || _d === void 0 ? void 0 : _d.moduleTypes,\n        patterns: options.moduleTypes,\n    });\n    const extensions = (0, file_extensions_1.getExtensions)(config, options, ts.version);\n    // Use full language services when the fast option is disabled.\n    if (!transpileOnly) {\n        const fileContents = new Map();\n        const rootFileNames = new Set(config.fileNames);\n        const cachedReadFile = (0, util_1.cachedLookup)(debugFn('readFile', readFile));\n        // Use language services by default\n        if (!options.compilerHost) {\n            let projectVersion = 1;\n            const fileVersions = new Map(Array.from(rootFileNames).map((fileName) => [fileName, 0]));\n            const getCustomTransformers = () => {\n                if (typeof transformers === 'function') {\n                    const program = service.getProgram();\n                    return program ? transformers(program) : undefined;\n                }\n                return transformers;\n            };\n            // Create the compiler host for type checking.\n            const serviceHost = {\n                getProjectVersion: () => String(projectVersion),\n                getScriptFileNames: () => Array.from(rootFileNames),\n                getScriptVersion: (fileName) => {\n                    const version = fileVersions.get(fileName);\n                    return version ? version.toString() : '';\n                },\n                getScriptSnapshot(fileName) {\n                    // TODO ordering of this with getScriptVersion?  Should they sync up?\n                    let contents = fileContents.get(fileName);\n                    // Read contents into TypeScript memory cache.\n                    if (contents === undefined) {\n                        contents = cachedReadFile(fileName);\n                        if (contents === undefined)\n                            return;\n                        fileVersions.set(fileName, 1);\n                        fileContents.set(fileName, contents);\n                        projectVersion++;\n                    }\n                    return ts.ScriptSnapshot.fromString(contents);\n                },\n                readFile: cachedReadFile,\n                readDirectory: ts.sys.readDirectory,\n                getDirectories: (0, util_1.cachedLookup)(debugFn('getDirectories', ts.sys.getDirectories)),\n                fileExists: (0, util_1.cachedLookup)(debugFn('fileExists', fileExists)),\n                directoryExists: (0, util_1.cachedLookup)(debugFn('directoryExists', ts.sys.directoryExists)),\n                realpath: ts.sys.realpath\n                    ? (0, util_1.cachedLookup)(debugFn('realpath', ts.sys.realpath))\n                    : undefined,\n                getNewLine: () => ts.sys.newLine,\n                useCaseSensitiveFileNames: () => ts.sys.useCaseSensitiveFileNames,\n                getCurrentDirectory: () => cwd,\n                getCompilationSettings: () => config.options,\n                getDefaultLibFileName: () => ts.getDefaultLibFilePath(config.options),\n                getCustomTransformers: getCustomTransformers,\n                trace: options.tsTrace,\n            };\n            const { resolveModuleNames, getResolvedModuleWithFailedLookupLocationsFromCache, resolveTypeReferenceDirectives, isFileKnownToBeInternal, markBucketOfFilenameInternal, } = (0, resolver_functions_1.createResolverFunctions)({\n                host: serviceHost,\n                getCanonicalFileName,\n                ts,\n                cwd,\n                config,\n                projectLocalResolveHelper,\n                options,\n                extensions,\n            });\n            serviceHost.resolveModuleNames = resolveModuleNames;\n            serviceHost.getResolvedModuleWithFailedLookupLocationsFromCache =\n                getResolvedModuleWithFailedLookupLocationsFromCache;\n            serviceHost.resolveTypeReferenceDirectives =\n                resolveTypeReferenceDirectives;\n            const registry = ts.createDocumentRegistry(ts.sys.useCaseSensitiveFileNames, cwd);\n            const service = ts.createLanguageService(serviceHost, registry);\n            const updateMemoryCache = (contents, fileName) => {\n                // Add to `rootFiles` as necessary, either to make TS include a file it has not seen,\n                // or to trigger a re-classification of files from external to internal.\n                if (!rootFileNames.has(fileName) &&\n                    !isFileKnownToBeInternal(fileName)) {\n                    markBucketOfFilenameInternal(fileName);\n                    rootFileNames.add(fileName);\n                    // Increment project version for every change to rootFileNames.\n                    projectVersion++;\n                }\n                const previousVersion = fileVersions.get(fileName) || 0;\n                const previousContents = fileContents.get(fileName);\n                // Avoid incrementing cache when nothing has changed.\n                if (contents !== previousContents) {\n                    fileVersions.set(fileName, previousVersion + 1);\n                    fileContents.set(fileName, contents);\n                    // Increment project version for every file change.\n                    projectVersion++;\n                }\n            };\n            let previousProgram = undefined;\n            getOutput = (code, fileName) => {\n                updateMemoryCache(code, fileName);\n                const programBefore = service.getProgram();\n                if (programBefore !== previousProgram) {\n                    (0, exports.debug)(`compiler rebuilt Program instance when getting output for ${fileName}`);\n                }\n                const output = service.getEmitOutput(fileName);\n                // Get the relevant diagnostics - this is 3x faster than `getPreEmitDiagnostics`.\n                const diagnostics = service\n                    .getSemanticDiagnostics(fileName)\n                    .concat(service.getSyntacticDiagnostics(fileName));\n                const programAfter = service.getProgram();\n                (0, exports.debug)('invariant: Is service.getProject() identical before and after getting emit output and diagnostics? (should always be true) ', programBefore === programAfter);\n                previousProgram = programAfter;\n                const diagnosticList = filterDiagnostics(diagnostics, diagnosticFilters);\n                if (diagnosticList.length)\n                    reportTSError(diagnosticList);\n                if (output.emitSkipped) {\n                    return [undefined, undefined, true];\n                }\n                // Throw an error when requiring `.d.ts` files.\n                if (output.outputFiles.length === 0) {\n                    throw new TypeError(`Unable to require file: ${(0, path_1.relative)(cwd, fileName)}\\n` +\n                        'This is usually the result of a faulty configuration or import. ' +\n                        'Make sure there is a `.js`, `.json` or other executable extension with ' +\n                        'loader attached before `ts-node` available.');\n                }\n                return [output.outputFiles[1].text, output.outputFiles[0].text, false];\n            };\n            getTypeInfo = (code, fileName, position) => {\n                const normalizedFileName = (0, util_1.normalizeSlashes)(fileName);\n                updateMemoryCache(code, normalizedFileName);\n                const info = service.getQuickInfoAtPosition(normalizedFileName, position);\n                const name = ts.displayPartsToString(info ? info.displayParts : []);\n                const comment = ts.displayPartsToString(info ? info.documentation : []);\n                return { name, comment };\n            };\n        }\n        else {\n            const sys = {\n                ...ts.sys,\n                ...diagnosticHost,\n                readFile: (fileName) => {\n                    const cacheContents = fileContents.get(fileName);\n                    if (cacheContents !== undefined)\n                        return cacheContents;\n                    const contents = cachedReadFile(fileName);\n                    if (contents)\n                        fileContents.set(fileName, contents);\n                    return contents;\n                },\n                readDirectory: ts.sys.readDirectory,\n                getDirectories: (0, util_1.cachedLookup)(debugFn('getDirectories', ts.sys.getDirectories)),\n                fileExists: (0, util_1.cachedLookup)(debugFn('fileExists', fileExists)),\n                directoryExists: (0, util_1.cachedLookup)(debugFn('directoryExists', ts.sys.directoryExists)),\n                resolvePath: (0, util_1.cachedLookup)(debugFn('resolvePath', ts.sys.resolvePath)),\n                realpath: ts.sys.realpath\n                    ? (0, util_1.cachedLookup)(debugFn('realpath', ts.sys.realpath))\n                    : undefined,\n            };\n            const host = ts.createIncrementalCompilerHost\n                ? ts.createIncrementalCompilerHost(config.options, sys)\n                : {\n                    ...sys,\n                    getSourceFile: (fileName, languageVersion) => {\n                        const contents = sys.readFile(fileName);\n                        if (contents === undefined)\n                            return;\n                        return ts.createSourceFile(fileName, contents, languageVersion);\n                    },\n                    getDefaultLibLocation: () => (0, util_1.normalizeSlashes)((0, path_1.dirname)(compiler)),\n                    getDefaultLibFileName: () => (0, util_1.normalizeSlashes)((0, path_1.join)((0, path_1.dirname)(compiler), ts.getDefaultLibFileName(config.options))),\n                    useCaseSensitiveFileNames: () => sys.useCaseSensitiveFileNames,\n                };\n            host.trace = options.tsTrace;\n            const { resolveModuleNames, resolveTypeReferenceDirectives, isFileKnownToBeInternal, markBucketOfFilenameInternal, } = (0, resolver_functions_1.createResolverFunctions)({\n                host,\n                cwd,\n                config,\n                ts,\n                getCanonicalFileName,\n                projectLocalResolveHelper,\n                options,\n                extensions,\n            });\n            host.resolveModuleNames = resolveModuleNames;\n            host.resolveTypeReferenceDirectives = resolveTypeReferenceDirectives;\n            // Fallback for older TypeScript releases without incremental API.\n            let builderProgram = ts.createIncrementalProgram\n                ? ts.createIncrementalProgram({\n                    rootNames: Array.from(rootFileNames),\n                    options: config.options,\n                    host,\n                    configFileParsingDiagnostics: config.errors,\n                    projectReferences: config.projectReferences,\n                })\n                : ts.createEmitAndSemanticDiagnosticsBuilderProgram(Array.from(rootFileNames), config.options, host, undefined, config.errors, config.projectReferences);\n            // Read and cache custom transformers.\n            const customTransformers = typeof transformers === 'function'\n                ? transformers(builderProgram.getProgram())\n                : transformers;\n            // Set the file contents into cache manually.\n            const updateMemoryCache = (contents, fileName) => {\n                const previousContents = fileContents.get(fileName);\n                const contentsChanged = previousContents !== contents;\n                if (contentsChanged) {\n                    fileContents.set(fileName, contents);\n                }\n                // Add to `rootFiles` when discovered by compiler for the first time.\n                let addedToRootFileNames = false;\n                if (!rootFileNames.has(fileName) &&\n                    !isFileKnownToBeInternal(fileName)) {\n                    markBucketOfFilenameInternal(fileName);\n                    rootFileNames.add(fileName);\n                    addedToRootFileNames = true;\n                }\n                // Update program when file changes.\n                if (addedToRootFileNames || contentsChanged) {\n                    builderProgram = ts.createEmitAndSemanticDiagnosticsBuilderProgram(Array.from(rootFileNames), config.options, host, builderProgram, config.errors, config.projectReferences);\n                }\n            };\n            getOutput = (code, fileName) => {\n                let outText = '';\n                let outMap = '';\n                updateMemoryCache(code, fileName);\n                const sourceFile = builderProgram.getSourceFile(fileName);\n                if (!sourceFile)\n                    throw new TypeError(`Unable to read file: ${fileName}`);\n                const program = builderProgram.getProgram();\n                const diagnostics = ts.getPreEmitDiagnostics(program, sourceFile);\n                const diagnosticList = filterDiagnostics(diagnostics, diagnosticFilters);\n                if (diagnosticList.length)\n                    reportTSError(diagnosticList);\n                const result = builderProgram.emit(sourceFile, (path, file, writeByteOrderMark) => {\n                    if (path.endsWith('.map')) {\n                        outMap = file;\n                    }\n                    else {\n                        outText = file;\n                    }\n                    if (options.emit)\n                        sys.writeFile(path, file, writeByteOrderMark);\n                }, undefined, undefined, customTransformers);\n                if (result.emitSkipped) {\n                    return [undefined, undefined, true];\n                }\n                // Throw an error when requiring files that cannot be compiled.\n                if (outText === '') {\n                    if (program.isSourceFileFromExternalLibrary(sourceFile)) {\n                        throw new TypeError(`Unable to compile file from external library: ${(0, path_1.relative)(cwd, fileName)}`);\n                    }\n                    throw new TypeError(`Unable to require file: ${(0, path_1.relative)(cwd, fileName)}\\n` +\n                        'This is usually the result of a faulty configuration or import. ' +\n                        'Make sure there is a `.js`, `.json` or other executable extension with ' +\n                        'loader attached before `ts-node` available.');\n                }\n                return [outText, outMap, false];\n            };\n            getTypeInfo = (code, fileName, position) => {\n                const normalizedFileName = (0, util_1.normalizeSlashes)(fileName);\n                updateMemoryCache(code, normalizedFileName);\n                const sourceFile = builderProgram.getSourceFile(normalizedFileName);\n                if (!sourceFile)\n                    throw new TypeError(`Unable to read file: ${fileName}`);\n                const node = getTokenAtPosition(ts, sourceFile, position);\n                const checker = builderProgram.getProgram().getTypeChecker();\n                const symbol = checker.getSymbolAtLocation(node);\n                if (!symbol)\n                    return { name: '', comment: '' };\n                const type = checker.getTypeOfSymbolAtLocation(symbol, node);\n                const signatures = [\n                    ...type.getConstructSignatures(),\n                    ...type.getCallSignatures(),\n                ];\n                return {\n                    name: signatures.length\n                        ? signatures.map((x) => checker.signatureToString(x)).join('\\n')\n                        : checker.typeToString(type),\n                    comment: ts.displayPartsToString(symbol ? symbol.getDocumentationComment(checker) : []),\n                };\n            };\n            // Write `.tsbuildinfo` when `--build` is enabled.\n            if (options.emit && config.options.incremental) {\n                process.on('exit', () => {\n                    // Emits `.tsbuildinfo` to filesystem.\n                    builderProgram.getProgram().emitBuildInfo();\n                });\n            }\n        }\n    }\n    else {\n        getTypeInfo = () => {\n            throw new TypeError('Type information is unavailable in \"--transpile-only\"');\n        };\n    }\n    function createTranspileOnlyGetOutputFunction(overrideModuleType, nodeModuleEmitKind) {\n        const compilerOptions = { ...config.options };\n        if (overrideModuleType !== undefined)\n            compilerOptions.module = overrideModuleType;\n        let customTranspiler = createTranspiler === null || createTranspiler === void 0 ? void 0 : createTranspiler(compilerOptions, nodeModuleEmitKind);\n        let tsTranspileModule = (0, util_1.versionGteLt)(ts.version, '4.7.0')\n            ? (0, ts_transpile_module_1.createTsTranspileModule)(ts, {\n                compilerOptions,\n                reportDiagnostics: true,\n                transformers: transformers,\n            })\n            : undefined;\n        return (code, fileName) => {\n            let result;\n            if (customTranspiler) {\n                result = customTranspiler.transpile(code, {\n                    fileName,\n                });\n            }\n            else if (tsTranspileModule) {\n                result = tsTranspileModule(code, {\n                    fileName,\n                }, nodeModuleEmitKind === 'nodeesm' ? 'module' : 'commonjs');\n            }\n            else {\n                result = ts.transpileModule(code, {\n                    fileName,\n                    compilerOptions,\n                    reportDiagnostics: true,\n                    transformers: transformers,\n                });\n            }\n            const diagnosticList = filterDiagnostics(result.diagnostics || [], diagnosticFilters);\n            if (diagnosticList.length)\n                reportTSError(diagnosticList);\n            return [result.outputText, result.sourceMapText, false];\n        };\n    }\n    // When true, these mean that a `moduleType` override will cause a different emit\n    // than the TypeScript compiler, so we *must* overwrite the emit.\n    const shouldOverwriteEmitWhenForcingCommonJS = config.options.module !== ts.ModuleKind.CommonJS;\n    // [MUST_UPDATE_FOR_NEW_MODULEKIND]\n    const shouldOverwriteEmitWhenForcingEsm = !(config.options.module === ts.ModuleKind.ES2015 ||\n        (ts.ModuleKind.ES2020 && config.options.module === ts.ModuleKind.ES2020) ||\n        (ts.ModuleKind.ES2022 && config.options.module === ts.ModuleKind.ES2022) ||\n        config.options.module === ts.ModuleKind.ESNext);\n    /**\n     * node16 or nodenext\n     * [MUST_UPDATE_FOR_NEW_MODULEKIND]\n     */\n    const isNodeModuleType = (ts.ModuleKind.Node16 && config.options.module === ts.ModuleKind.Node16) ||\n        (ts.ModuleKind.NodeNext &&\n            config.options.module === ts.ModuleKind.NodeNext);\n    const getOutputForceCommonJS = createTranspileOnlyGetOutputFunction(ts.ModuleKind.CommonJS);\n    const getOutputForceNodeCommonJS = createTranspileOnlyGetOutputFunction(ts.ModuleKind.NodeNext, 'nodecjs');\n    const getOutputForceNodeESM = createTranspileOnlyGetOutputFunction(ts.ModuleKind.NodeNext, 'nodeesm');\n    // [MUST_UPDATE_FOR_NEW_MODULEKIND]\n    const getOutputForceESM = createTranspileOnlyGetOutputFunction(ts.ModuleKind.ES2022 || ts.ModuleKind.ES2020 || ts.ModuleKind.ES2015);\n    const getOutputTranspileOnly = createTranspileOnlyGetOutputFunction();\n    // Create a simple TypeScript compiler proxy.\n    function compile(code, fileName, lineOffset = 0) {\n        const normalizedFileName = (0, util_1.normalizeSlashes)(fileName);\n        const classification = moduleTypeClassifier.classifyModuleByModuleTypeOverrides(normalizedFileName);\n        let value = '';\n        let sourceMap = '';\n        let emitSkipped = true;\n        if (getOutput) {\n            // Must always call normal getOutput to throw typechecking errors\n            [value, sourceMap, emitSkipped] = getOutput(code, normalizedFileName);\n        }\n        // If module classification contradicts the above, call the relevant transpiler\n        if (classification.moduleType === 'cjs' &&\n            (shouldOverwriteEmitWhenForcingCommonJS || emitSkipped)) {\n            [value, sourceMap] = getOutputForceCommonJS(code, normalizedFileName);\n        }\n        else if (classification.moduleType === 'esm' &&\n            (shouldOverwriteEmitWhenForcingEsm || emitSkipped)) {\n            [value, sourceMap] = getOutputForceESM(code, normalizedFileName);\n        }\n        else if (emitSkipped) {\n            // Happens when ts compiler skips emit or in transpileOnly mode\n            const classification = (0, node_module_type_classifier_1.classifyModule)(fileName, isNodeModuleType);\n            [value, sourceMap] =\n                classification === 'nodecjs'\n                    ? getOutputForceNodeCommonJS(code, normalizedFileName)\n                    : classification === 'nodeesm'\n                        ? getOutputForceNodeESM(code, normalizedFileName)\n                        : classification === 'cjs'\n                            ? getOutputForceCommonJS(code, normalizedFileName)\n                            : classification === 'esm'\n                                ? getOutputForceESM(code, normalizedFileName)\n                                : getOutputTranspileOnly(code, normalizedFileName);\n        }\n        const output = updateOutput(value, normalizedFileName, sourceMap, getEmitExtension);\n        outputCache.set(normalizedFileName, { content: output });\n        return output;\n    }\n    let active = true;\n    const enabled = (enabled) => enabled === undefined ? active : (active = !!enabled);\n    const ignored = (fileName) => {\n        if (!active)\n            return true;\n        const ext = (0, path_1.extname)(fileName);\n        if (extensions.compiled.includes(ext)) {\n            return !isScoped(fileName) || shouldIgnore(fileName);\n        }\n        return true;\n    };\n    function addDiagnosticFilter(filter) {\n        diagnosticFilters.push({\n            ...filter,\n            filenamesAbsolute: filter.filenamesAbsolute.map((f) => (0, util_1.normalizeSlashes)(f)),\n        });\n    }\n    const getNodeEsmResolver = (0, util_1.once)(() => require('../dist-raw/node-internal-modules-esm-resolve').createResolve({\n        extensions,\n        preferTsExts: options.preferTsExts,\n        tsNodeExperimentalSpecifierResolution: options.experimentalSpecifierResolution,\n    }));\n    const getNodeEsmGetFormat = (0, util_1.once)(() => require('../dist-raw/node-internal-modules-esm-get_format').createGetFormat(options.experimentalSpecifierResolution, getNodeEsmResolver()));\n    const getNodeCjsLoader = (0, util_1.once)(() => require('../dist-raw/node-internal-modules-cjs-loader').createCjsLoader({\n        extensions,\n        preferTsExts: options.preferTsExts,\n        nodeEsmResolver: getNodeEsmResolver(),\n    }));\n    return {\n        [TS_NODE_SERVICE_BRAND]: true,\n        ts,\n        compilerPath: compiler,\n        config,\n        compile,\n        getTypeInfo,\n        ignored,\n        enabled,\n        options,\n        configFilePath,\n        moduleTypeClassifier,\n        shouldReplAwait,\n        addDiagnosticFilter,\n        installSourceMapSupport,\n        enableExperimentalEsmLoaderInterop,\n        transpileOnly,\n        projectLocalResolveHelper,\n        getNodeEsmResolver,\n        getNodeEsmGetFormat,\n        getNodeCjsLoader,\n        extensions,\n    };\n}\nexports.createFromPreloadedConfig = createFromPreloadedConfig;\n/**\n * Check if the filename should be ignored.\n */\nfunction createIgnore(ignoreBaseDir, ignore) {\n    return (fileName) => {\n        const relname = (0, path_1.relative)(ignoreBaseDir, fileName);\n        const path = (0, util_1.normalizeSlashes)(relname);\n        return ignore.some((x) => x.test(path));\n    };\n}\n/**\n * Register the extensions to support when importing files.\n */\nfunction registerExtensions(preferTsExts, extensions, service, originalJsHandler) {\n    const exts = new Set(extensions);\n    // Can't add these extensions cuz would allow omitting file extension; node requires ext for .cjs and .mjs\n    // Unless they're already registered by something else (nyc does this):\n    // then we *must* hook them or else our transformer will not be called.\n    for (const cannotAdd of ['.mts', '.cts', '.mjs', '.cjs']) {\n        if (exts.has(cannotAdd) && !(0, util_1.hasOwnProperty)(require.extensions, cannotAdd)) {\n            // Unrecognized file exts can be transformed via the `.js` handler.\n            exts.add('.js');\n            exts.delete(cannotAdd);\n        }\n    }\n    // Register new extensions.\n    for (const ext of exts) {\n        registerExtension(ext, service, originalJsHandler);\n    }\n    if (preferTsExts) {\n        const preferredExtensions = new Set([\n            ...exts,\n            ...Object.keys(require.extensions),\n        ]);\n        // Re-sort iteration order of Object.keys()\n        for (const ext of preferredExtensions) {\n            const old = Object.getOwnPropertyDescriptor(require.extensions, ext);\n            delete require.extensions[ext];\n            Object.defineProperty(require.extensions, ext, old);\n        }\n    }\n}\n/**\n * Register the extension for node.\n */\nfunction registerExtension(ext, service, originalHandler) {\n    const old = require.extensions[ext] || originalHandler;\n    require.extensions[ext] = function (m, filename) {\n        if (service.ignored(filename))\n            return old(m, filename);\n        assertScriptCanLoadAsCJS(service, m, filename);\n        const _compile = m._compile;\n        m._compile = function (code, fileName) {\n            (0, exports.debug)('module._compile', fileName);\n            const result = service.compile(code, fileName);\n            return _compile.call(this, result, fileName);\n        };\n        return old(m, filename);\n    };\n}\n/**\n * Update the output remapping the source map.\n */\nfunction updateOutput(outputText, fileName, sourceMap, getEmitExtension) {\n    const base64Map = Buffer.from(updateSourceMap(sourceMap, fileName), 'utf8').toString('base64');\n    const sourceMapContent = `//# sourceMappingURL=data:application/json;charset=utf-8;base64,${base64Map}`;\n    // Expected form: `//# sourceMappingURL=foo bar.js.map` or `//# sourceMappingURL=foo%20bar.js.map` for input file \"foo bar.tsx\"\n    // Percent-encoding behavior added in TS 4.1.1: https://github.com/microsoft/TypeScript/issues/40951\n    const prefix = '//# sourceMappingURL=';\n    const prefixLength = prefix.length;\n    const baseName = /*foo.tsx*/ (0, path_1.basename)(fileName);\n    const extName = /*.tsx*/ (0, path_1.extname)(fileName);\n    const extension = /*.js*/ getEmitExtension(fileName);\n    const sourcemapFilename = baseName.slice(0, -extName.length) + extension + '.map';\n    const sourceMapLengthWithoutPercentEncoding = prefixLength + sourcemapFilename.length;\n    /*\n     * Only rewrite if existing directive exists at the location we expect, to support:\n     *   a) compilers that do not append a sourcemap directive\n     *   b) situations where we did the math wrong\n     *     Not ideal, but appending our sourcemap *after* a pre-existing sourcemap still overrides, so the end-user is happy.\n     */\n    if (outputText.substr(-sourceMapLengthWithoutPercentEncoding, prefixLength) ===\n        prefix) {\n        return (outputText.slice(0, -sourceMapLengthWithoutPercentEncoding) +\n            sourceMapContent);\n    }\n    // If anyone asks why we're not using URL, the URL equivalent is: `u = new URL('http://d'); u.pathname = \"/\" + sourcemapFilename; return u.pathname.slice(1);\n    const sourceMapLengthWithPercentEncoding = prefixLength + encodeURI(sourcemapFilename).length;\n    if (outputText.substr(-sourceMapLengthWithPercentEncoding, prefixLength) ===\n        prefix) {\n        return (outputText.slice(0, -sourceMapLengthWithPercentEncoding) +\n            sourceMapContent);\n    }\n    return `${outputText}\\n${sourceMapContent}`;\n}\n/**\n * Update the source map contents for improved output.\n */\nfunction updateSourceMap(sourceMapText, fileName) {\n    const sourceMap = JSON.parse(sourceMapText);\n    sourceMap.file = fileName;\n    sourceMap.sources = [fileName];\n    delete sourceMap.sourceRoot;\n    return JSON.stringify(sourceMap);\n}\n/**\n * Filter diagnostics.\n */\nfunction filterDiagnostics(diagnostics, filters) {\n    return diagnostics.filter((d) => filters.every((f) => {\n        var _a;\n        return (!f.appliesToAllFiles &&\n            f.filenamesAbsolute.indexOf((_a = d.file) === null || _a === void 0 ? void 0 : _a.fileName) === -1) ||\n            f.diagnosticsIgnored.indexOf(d.code) === -1;\n    }));\n}\n/**\n * Get token at file position.\n *\n * Reference: https://github.com/microsoft/TypeScript/blob/fcd9334f57d85b73dd66ad2d21c02e84822f4841/src/services/utilities.ts#L705-L731\n */\nfunction getTokenAtPosition(ts, sourceFile, position) {\n    let current = sourceFile;\n    outer: while (true) {\n        for (const child of current.getChildren(sourceFile)) {\n            const start = child.getFullStart();\n            if (start > position)\n                break;\n            const end = child.getEnd();\n            if (position <= end) {\n                current = child;\n                continue outer;\n            }\n        }\n        return current;\n    }\n}\n/**\n * Create an implementation of node's ESM loader hooks.\n *\n * This may be useful if you\n * want to wrap or compose the loader hooks to add additional functionality or\n * combine with another loader.\n *\n * Node changed the hooks API, so there are two possible APIs.  This function\n * detects your node version and returns the appropriate API.\n *\n * @category ESM Loader\n */\nconst createEsmHooks = (tsNodeService) => require('./esm').createEsmHooks(tsNodeService);\nexports.createEsmHooks = createEsmHooks;\n//# sourceMappingURL=index.js.map",
    "package.json": "{\n  \"name\": \"ts-node\",\n  \"version\": \"10.9.2\",\n  \"description\": \"TypeScript execution environment and REPL for node.js, with source map support\",\n  \"main\": \"dist/index.js\",\n  \"exports\": {\n    \".\": \"./dist/index.js\",\n    \"./package\": \"./package.json\",\n    \"./package.json\": \"./package.json\",\n    \"./dist/bin\": \"./dist/bin.js\",\n    \"./dist/bin.js\": \"./dist/bin.js\",\n    \"./dist/bin-transpile\": \"./dist/bin-transpile.js\",\n    \"./dist/bin-transpile.js\": \"./dist/bin-transpile.js\",\n    \"./dist/bin-script\": \"./dist/bin-script.js\",\n    \"./dist/bin-script.js\": \"./dist/bin-script.js\",\n    \"./dist/bin-cwd\": \"./dist/bin-cwd.js\",\n    \"./dist/bin-cwd.js\": \"./dist/bin-cwd.js\",\n    \"./dist/bin-esm\": \"./dist/bin-esm.js\",\n    \"./dist/bin-esm.js\": \"./dist/bin-esm.js\",\n    \"./register\": \"./register/index.js\",\n    \"./register/files\": \"./register/files.js\",\n    \"./register/transpile-only\": \"./register/transpile-only.js\",\n    \"./register/type-check\": \"./register/type-check.js\",\n    \"./esm\": \"./esm.mjs\",\n    \"./esm.mjs\": \"./esm.mjs\",\n    \"./esm/transpile-only\": \"./esm/transpile-only.mjs\",\n    \"./esm/transpile-only.mjs\": \"./esm/transpile-only.mjs\",\n    \"./child-loader.mjs\": \"./child-loader.mjs\",\n    \"./transpilers/swc\": \"./transpilers/swc.js\",\n    \"./transpilers/swc-experimental\": \"./transpilers/swc-experimental.js\",\n    \"./node10/tsconfig.json\": \"./node10/tsconfig.json\",\n    \"./node12/tsconfig.json\": \"./node12/tsconfig.json\",\n    \"./node14/tsconfig.json\": \"./node14/tsconfig.json\",\n    \"./node16/tsconfig.json\": \"./node16/tsconfig.json\"\n  },\n  \"types\": \"dist/index.d.ts\",\n  \"bin\": {\n    \"ts-node\": \"dist/bin.js\",\n    \"ts-node-cwd\": \"dist/bin-cwd.js\",\n    \"ts-node-esm\": \"dist/bin-esm.js\",\n    \"ts-node-script\": \"dist/bin-script.js\",\n    \"ts-node-transpile-only\": \"dist/bin-transpile.js\",\n    \"ts-script\": \"dist/bin-script-deprecated.js\"\n  },\n  \"files\": [\n    \"/transpilers/\",\n    \"/dist/\",\n    \"!/dist/test\",\n    \"/dist-raw/NODE-LICENSE.md\",\n    \"/dist-raw/**.js\",\n    \"/register/\",\n    \"/esm/\",\n    \"/esm.mjs\",\n    \"/child-loader.mjs\",\n    \"/LICENSE\",\n    \"/tsconfig.schema.json\",\n    \"/tsconfig.schemastore-schema.json\",\n    \"/node10/\",\n    \"/node12/\",\n    \"/node14/\",\n    \"/node16/\"\n  ],\n  \"scripts\": {\n    \"lint\": \"dprint check\",\n    \"lint-fix\": \"dprint fmt\",\n    \"clean\": \"rimraf temp dist tsconfig.schema.json tsconfig.schemastore-schema.json tsconfig.tsbuildinfo tests/ts-node-packed.tgz tests/node_modules tests/tmp\",\n    \"rebuild\": \"npm run clean && npm run build\",\n    \"build\": \"npm run build-nopack && npm run build-pack\",\n    \"build-nopack\": \"npm run build-tsc && npm run build-configSchema\",\n    \"build-tsc\": \"tsc -b ./tsconfig.build-dist.json\",\n    \"build-configSchema\": \"typescript-json-schema --topRef --refs --validationKeywords allOf --out tsconfig.schema.json tsconfig.build-schema.json TsConfigSchema && node --require ./register ./scripts/create-merged-schema\",\n    \"build-pack\": \"node ./scripts/build-pack.js\",\n    \"test-spec\": \"ava\",\n    \"test-cov\": \"nyc ava\",\n    \"test\": \"npm run build && npm run lint && npm run test-cov --\",\n    \"test-local\": \"npm run lint-fix && npm run build-tsc && npm run build-pack && npm run test-spec --\",\n    \"pre-debug\": \"npm run build-tsc && npm run build-pack\",\n    \"coverage-report\": \"nyc report --reporter=lcov\",\n    \"prepare\": \"npm run clean && npm run build-nopack\",\n    \"api-extractor\": \"api-extractor run --local --verbose\",\n    \"esm-usage-example\": \"npm run build-tsc && cd esm-usage-example && node --experimental-specifier-resolution node --loader ../esm.mjs ./index\",\n    \"esm-usage-example2\": \"npm run build-tsc && cd tests && TS_NODE_PROJECT=./module-types/override-to-cjs/tsconfig.json node --loader ../esm.mjs ./module-types/override-to-cjs/test.cjs\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/TypeStrong/ts-node.git\"\n  },\n  \"keywords\": [\n    \"typescript\",\n    \"node\",\n    \"runtime\",\n    \"environment\",\n    \"ts\",\n    \"compiler\"\n  ],\n  \"author\": {\n    \"name\": \"Blake Embrey\",\n    \"email\": \"hello@blakeembrey.com\",\n    \"url\": \"http://blakeembrey.me\"\n  },\n  \"contributors\": [\n    {\n      \"name\": \"Andrew Bradley\",\n      \"email\": \"cspotcode@gmail.com\",\n      \"url\": \"https://github.com/cspotcode\"\n    }\n  ],\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/TypeStrong/ts-node/issues\"\n  },\n  \"homepage\": \"https://typestrong.org/ts-node\",\n  \"devDependencies\": {\n    \"@microsoft/api-extractor\": \"^7.19.4\",\n    \"@swc/core\": \"^1.3.100\",\n    \"@swc/wasm\": \"^1.3.100\",\n    \"@types/diff\": \"^4.0.2\",\n    \"@types/lodash\": \"^4.14.151\",\n    \"@types/node\": \"13.13.5\",\n    \"@types/proper-lockfile\": \"^4.1.2\",\n    \"@types/proxyquire\": \"^1.3.28\",\n    \"@types/react\": \"^16.14.19\",\n    \"@types/rimraf\": \"^3.0.0\",\n    \"@types/semver\": \"^7.1.0\",\n    \"@yarnpkg/fslib\": \"^2.4.0\",\n    \"ava\": \"^3.15.0\",\n    \"axios\": \"^0.21.1\",\n    \"dprint\": \"^0.25.0\",\n    \"expect\": \"^27.0.2\",\n    \"get-stream\": \"^6.0.0\",\n    \"lodash\": \"^4.17.15\",\n    \"ntypescript\": \"^1.201507091536.1\",\n    \"nyc\": \"^15.0.1\",\n    \"outdent\": \"^0.8.0\",\n    \"proper-lockfile\": \"^4.1.2\",\n    \"proxyquire\": \"^2.0.0\",\n    \"react\": \"^16.14.0\",\n    \"rimraf\": \"^3.0.0\",\n    \"semver\": \"^7.1.3\",\n    \"throat\": \"^6.0.1\",\n    \"typedoc\": \"^0.22.10\",\n    \"typescript\": \"4.7.4\",\n    \"typescript-json-schema\": \"^0.53.0\",\n    \"util.promisify\": \"^1.0.1\"\n  },\n  \"peerDependencies\": {\n    \"@swc/core\": \">=1.2.50\",\n    \"@swc/wasm\": \">=1.2.50\",\n    \"@types/node\": \"*\",\n    \"typescript\": \">=2.7\"\n  },\n  \"peerDependenciesMeta\": {\n    \"@swc/core\": {\n      \"optional\": true\n    },\n    \"@swc/wasm\": {\n      \"optional\": true\n    }\n  },\n  \"dependencies\": {\n    \"@cspotcode/source-map-support\": \"^0.8.0\",\n    \"@tsconfig/node10\": \"^1.0.7\",\n    \"@tsconfig/node12\": \"^1.0.7\",\n    \"@tsconfig/node14\": \"^1.0.0\",\n    \"@tsconfig/node16\": \"^1.0.2\",\n    \"acorn\": \"^8.4.1\",\n    \"acorn-walk\": \"^8.1.1\",\n    \"arg\": \"^4.1.0\",\n    \"create-require\": \"^1.1.0\",\n    \"diff\": \"^4.0.1\",\n    \"make-error\": \"^1.1.1\",\n    \"v8-compile-cache-lib\": \"^3.0.1\",\n    \"yn\": \"3.1.1\"\n  },\n  \"prettier\": {\n    \"singleQuote\": true\n  },\n  \"volta\": {\n    \"node\": \"18.1.0\",\n    \"npm\": \"6.14.15\"\n  }\n}\n",
    "dist/util.js": "\"use strict\";\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.versionGteLt = exports.once = exports.getBasePathForProjectLocalDependencyResolution = exports.createProjectLocalResolveHelper = exports.attemptRequireWithV8CompileCache = exports.cachedLookup = exports.hasOwnProperty = exports.normalizeSlashes = exports.parse = exports.split = exports.assign = exports.yn = exports.createRequire = void 0;\nconst module_1 = require(\"module\");\nconst ynModule = require(\"yn\");\nconst path_1 = require(\"path\");\n/** @internal */\nexports.createRequire = (_a = module_1.createRequire !== null && module_1.createRequire !== void 0 ? module_1.createRequire : module_1.createRequireFromPath) !== null && _a !== void 0 ? _a : require('create-require');\n/**\n * Wrapper around yn module that returns `undefined` instead of `null`.\n * This is implemented by yn v4, but we're staying on v3 to avoid v4's node 10 requirement.\n * @internal\n */\nfunction yn(value) {\n    var _a;\n    return (_a = ynModule(value)) !== null && _a !== void 0 ? _a : undefined;\n}\nexports.yn = yn;\n/**\n * Like `Object.assign`, but ignores `undefined` properties.\n *\n * @internal\n */\nfunction assign(initialValue, ...sources) {\n    for (const source of sources) {\n        for (const key of Object.keys(source)) {\n            const value = source[key];\n            if (value !== undefined)\n                initialValue[key] = value;\n        }\n    }\n    return initialValue;\n}\nexports.assign = assign;\n/**\n * Split a string array of values\n * and remove empty strings from the resulting array.\n * @internal\n */\nfunction split(value) {\n    return typeof value === 'string'\n        ? value.split(/ *, */g).filter((v) => v !== '')\n        : undefined;\n}\nexports.split = split;\n/**\n * Parse a string as JSON.\n * @internal\n */\nfunction parse(value) {\n    return typeof value === 'string' ? JSON.parse(value) : undefined;\n}\nexports.parse = parse;\nconst directorySeparator = '/';\nconst backslashRegExp = /\\\\/g;\n/**\n * Replace backslashes with forward slashes.\n * @internal\n */\nfunction normalizeSlashes(value) {\n    return value.replace(backslashRegExp, directorySeparator);\n}\nexports.normalizeSlashes = normalizeSlashes;\n/**\n * Safe `hasOwnProperty`\n * @internal\n */\nfunction hasOwnProperty(object, property) {\n    return Object.prototype.hasOwnProperty.call(object, property);\n}\nexports.hasOwnProperty = hasOwnProperty;\n/**\n * Cached fs operation wrapper.\n */\nfunction cachedLookup(fn) {\n    const cache = new Map();\n    return (arg) => {\n        if (!cache.has(arg)) {\n            const v = fn(arg);\n            cache.set(arg, v);\n            return v;\n        }\n        return cache.get(arg);\n    };\n}\nexports.cachedLookup = cachedLookup;\n/**\n * @internal\n * Require something with v8-compile-cache, which should make subsequent requires faster.\n * Do lots of error-handling so that, worst case, we require without the cache, and users are not blocked.\n */\nfunction attemptRequireWithV8CompileCache(requireFn, specifier) {\n    try {\n        const v8CC = require('v8-compile-cache-lib').install();\n        try {\n            return requireFn(specifier);\n        }\n        finally {\n            v8CC === null || v8CC === void 0 ? void 0 : v8CC.uninstall();\n        }\n    }\n    catch (e) {\n        return requireFn(specifier);\n    }\n}\nexports.attemptRequireWithV8CompileCache = attemptRequireWithV8CompileCache;\n/**\n * Helper to discover dependencies relative to a user's project, optionally\n * falling back to relative to ts-node.  This supports global installations of\n * ts-node, for example where someone does `#!/usr/bin/env -S ts-node --swc` and\n * we need to fallback to a global install of @swc/core\n * @internal\n */\nfunction createProjectLocalResolveHelper(localDirectory) {\n    return function projectLocalResolveHelper(specifier, fallbackToTsNodeRelative) {\n        return require.resolve(specifier, {\n            paths: fallbackToTsNodeRelative\n                ? [localDirectory, __dirname]\n                : [localDirectory],\n        });\n    };\n}\nexports.createProjectLocalResolveHelper = createProjectLocalResolveHelper;\n/**\n * Used as a reminder of all the factors we must consider when finding project-local dependencies and when a config file\n * on disk may or may not exist.\n * @internal\n */\nfunction getBasePathForProjectLocalDependencyResolution(configFilePath, projectSearchDirOption, projectOption, cwdOption) {\n    var _a;\n    if (configFilePath != null)\n        return (0, path_1.dirname)(configFilePath);\n    return (_a = projectSearchDirOption !== null && projectSearchDirOption !== void 0 ? projectSearchDirOption : projectOption) !== null && _a !== void 0 ? _a : cwdOption;\n    // TODO technically breaks if projectOption is path to a file, not a directory,\n    // and we attempt to resolve relative specifiers.  By the time we resolve relative specifiers,\n    // should have configFilePath, so not reach this codepath.\n}\nexports.getBasePathForProjectLocalDependencyResolution = getBasePathForProjectLocalDependencyResolution;\n/** @internal */\nfunction once(fn) {\n    let value;\n    let ran = false;\n    function onceFn(...args) {\n        if (ran)\n            return value;\n        value = fn(...args);\n        ran = true;\n        return value;\n    }\n    return onceFn;\n}\nexports.once = once;\n/** @internal */\nfunction versionGteLt(version, gteRequirement, ltRequirement) {\n    const [major, minor, patch, extra] = parse(version);\n    const [gteMajor, gteMinor, gtePatch] = parse(gteRequirement);\n    const isGte = major > gteMajor ||\n        (major === gteMajor &&\n            (minor > gteMinor || (minor === gteMinor && patch >= gtePatch)));\n    let isLt = true;\n    if (ltRequirement) {\n        const [ltMajor, ltMinor, ltPatch] = parse(ltRequirement);\n        isLt =\n            major < ltMajor ||\n                (major === ltMajor &&\n                    (minor < ltMinor || (minor === ltMinor && patch < ltPatch)));\n    }\n    return isGte && isLt;\n    function parse(requirement) {\n        return requirement.split(/[\\.-]/).map((s) => parseInt(s, 10));\n    }\n}\nexports.versionGteLt = versionGteLt;\n//# sourceMappingURL=util.js.map",
    "dist/configuration.js": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getTsConfigDefaults = exports.ComputeAsCommonRootOfFiles = exports.loadCompiler = exports.resolveAndLoadCompiler = exports.readConfig = exports.findAndReadConfig = void 0;\nconst path_1 = require(\"path\");\nconst index_1 = require(\"./index\");\nconst ts_internals_1 = require(\"./ts-internals\");\nconst tsconfigs_1 = require(\"./tsconfigs\");\nconst util_1 = require(\"./util\");\n/**\n * TypeScript compiler option values required by `ts-node` which cannot be overridden.\n */\nconst TS_NODE_COMPILER_OPTIONS = {\n    sourceMap: true,\n    inlineSourceMap: false,\n    inlineSources: true,\n    declaration: false,\n    noEmit: false,\n    outDir: '.ts-node',\n};\n/*\n * Do post-processing on config options to support `ts-node`.\n */\nfunction fixConfig(ts, config) {\n    // Delete options that *should not* be passed through.\n    delete config.options.out;\n    delete config.options.outFile;\n    delete config.options.composite;\n    delete config.options.declarationDir;\n    delete config.options.declarationMap;\n    delete config.options.emitDeclarationOnly;\n    // Target ES5 output by default (instead of ES3).\n    if (config.options.target === undefined) {\n        config.options.target = ts.ScriptTarget.ES5;\n    }\n    // Target CommonJS modules by default (instead of magically switching to ES6 when the target is ES6).\n    if (config.options.module === undefined) {\n        config.options.module = ts.ModuleKind.CommonJS;\n    }\n    return config;\n}\n/** @internal */\nfunction findAndReadConfig(rawOptions) {\n    var _a, _b, _c, _d, _e;\n    const cwd = (0, path_1.resolve)((_c = (_b = (_a = rawOptions.cwd) !== null && _a !== void 0 ? _a : rawOptions.dir) !== null && _b !== void 0 ? _b : index_1.DEFAULTS.cwd) !== null && _c !== void 0 ? _c : process.cwd());\n    const compilerName = (_d = rawOptions.compiler) !== null && _d !== void 0 ? _d : index_1.DEFAULTS.compiler;\n    // Compute minimum options to read the config file.\n    let projectLocalResolveDir = (0, util_1.getBasePathForProjectLocalDependencyResolution)(undefined, rawOptions.projectSearchDir, rawOptions.project, cwd);\n    let { compiler, ts } = resolveAndLoadCompiler(compilerName, projectLocalResolveDir);\n    // Read config file and merge new options between env and CLI options.\n    const { configFilePath, config, tsNodeOptionsFromTsconfig, optionBasePaths } = readConfig(cwd, ts, rawOptions);\n    const options = (0, util_1.assign)({}, index_1.DEFAULTS, tsNodeOptionsFromTsconfig || {}, { optionBasePaths }, rawOptions);\n    options.require = [\n        ...(tsNodeOptionsFromTsconfig.require || []),\n        ...(rawOptions.require || []),\n    ];\n    // Re-resolve the compiler in case it has changed.\n    // Compiler is loaded relative to tsconfig.json, so tsconfig discovery may cause us to load a\n    // different compiler than we did above, even if the name has not changed.\n    if (configFilePath) {\n        projectLocalResolveDir = (0, util_1.getBasePathForProjectLocalDependencyResolution)(configFilePath, rawOptions.projectSearchDir, rawOptions.project, cwd);\n        ({ compiler } = resolveCompiler(options.compiler, (_e = optionBasePaths.compiler) !== null && _e !== void 0 ? _e : projectLocalResolveDir));\n    }\n    return {\n        options,\n        config,\n        projectLocalResolveDir,\n        optionBasePaths,\n        configFilePath,\n        cwd,\n        compiler,\n    };\n}\nexports.findAndReadConfig = findAndReadConfig;\n/**\n * Load TypeScript configuration. Returns the parsed TypeScript config and\n * any `ts-node` options specified in the config file.\n *\n * Even when a tsconfig.json is not loaded, this function still handles merging\n * compilerOptions from various sources: API, environment variables, etc.\n *\n * @internal\n */\nfunction readConfig(cwd, ts, rawApiOptions) {\n    var _a, _b, _c;\n    // Ordered [a, b, c] where config a extends b extends c\n    const configChain = [];\n    let config = { compilerOptions: {} };\n    let basePath = cwd;\n    let configFilePath = undefined;\n    const projectSearchDir = (0, path_1.resolve)(cwd, (_a = rawApiOptions.projectSearchDir) !== null && _a !== void 0 ? _a : cwd);\n    const { fileExists = ts.sys.fileExists, readFile = ts.sys.readFile, skipProject = index_1.DEFAULTS.skipProject, project = index_1.DEFAULTS.project, tsTrace = index_1.DEFAULTS.tsTrace, } = rawApiOptions;\n    // Read project configuration when available.\n    if (!skipProject) {\n        if (project) {\n            const resolved = (0, path_1.resolve)(cwd, project);\n            const nested = (0, path_1.join)(resolved, 'tsconfig.json');\n            configFilePath = fileExists(nested) ? nested : resolved;\n        }\n        else {\n            configFilePath = ts.findConfigFile(projectSearchDir, fileExists);\n        }\n        if (configFilePath) {\n            let pathToNextConfigInChain = configFilePath;\n            const tsInternals = (0, ts_internals_1.createTsInternals)(ts);\n            const errors = [];\n            // Follow chain of \"extends\"\n            while (true) {\n                const result = ts.readConfigFile(pathToNextConfigInChain, readFile);\n                // Return diagnostics.\n                if (result.error) {\n                    return {\n                        configFilePath,\n                        config: { errors: [result.error], fileNames: [], options: {} },\n                        tsNodeOptionsFromTsconfig: {},\n                        optionBasePaths: {},\n                    };\n                }\n                const c = result.config;\n                const bp = (0, path_1.dirname)(pathToNextConfigInChain);\n                configChain.push({\n                    config: c,\n                    basePath: bp,\n                    configPath: pathToNextConfigInChain,\n                });\n                if (c.extends == null)\n                    break;\n                const resolvedExtendedConfigPath = tsInternals.getExtendsConfigPath(c.extends, {\n                    fileExists,\n                    readDirectory: ts.sys.readDirectory,\n                    readFile,\n                    useCaseSensitiveFileNames: ts.sys.useCaseSensitiveFileNames,\n                    trace: tsTrace,\n                }, bp, errors, ts.createCompilerDiagnostic);\n                if (errors.length) {\n                    return {\n                        configFilePath,\n                        config: { errors, fileNames: [], options: {} },\n                        tsNodeOptionsFromTsconfig: {},\n                        optionBasePaths: {},\n                    };\n                }\n                if (resolvedExtendedConfigPath == null)\n                    break;\n                pathToNextConfigInChain = resolvedExtendedConfigPath;\n            }\n            ({ config, basePath } = configChain[0]);\n        }\n    }\n    // Merge and fix ts-node options that come from tsconfig.json(s)\n    const tsNodeOptionsFromTsconfig = {};\n    const optionBasePaths = {};\n    for (let i = configChain.length - 1; i >= 0; i--) {\n        const { config, basePath, configPath } = configChain[i];\n        const options = filterRecognizedTsConfigTsNodeOptions(config['ts-node']).recognized;\n        // Some options are relative to the config file, so must be converted to absolute paths here\n        if (options.require) {\n            // Modules are found relative to the tsconfig file, not the `dir` option\n            const tsconfigRelativeResolver = (0, util_1.createProjectLocalResolveHelper)((0, path_1.dirname)(configPath));\n            options.require = options.require.map((path) => tsconfigRelativeResolver(path, false));\n        }\n        if (options.scopeDir) {\n            options.scopeDir = (0, path_1.resolve)(basePath, options.scopeDir);\n        }\n        // Downstream code uses the basePath; we do not do that here.\n        if (options.moduleTypes) {\n            optionBasePaths.moduleTypes = basePath;\n        }\n        if (options.transpiler != null) {\n            optionBasePaths.transpiler = basePath;\n        }\n        if (options.compiler != null) {\n            optionBasePaths.compiler = basePath;\n        }\n        if (options.swc != null) {\n            optionBasePaths.swc = basePath;\n        }\n        (0, util_1.assign)(tsNodeOptionsFromTsconfig, options);\n    }\n    // Remove resolution of \"files\".\n    const files = (_c = (_b = rawApiOptions.files) !== null && _b !== void 0 ? _b : tsNodeOptionsFromTsconfig.files) !== null && _c !== void 0 ? _c : index_1.DEFAULTS.files;\n    // Only if a config file is *not* loaded, load an implicit configuration from @tsconfig/bases\n    const skipDefaultCompilerOptions = configFilePath != null;\n    const defaultCompilerOptionsForNodeVersion = skipDefaultCompilerOptions\n        ? undefined\n        : {\n            ...(0, tsconfigs_1.getDefaultTsconfigJsonForNodeVersion)(ts).compilerOptions,\n            types: ['node'],\n        };\n    // Merge compilerOptions from all sources\n    config.compilerOptions = Object.assign({}, \n    // automatically-applied options from @tsconfig/bases\n    defaultCompilerOptionsForNodeVersion, \n    // tsconfig.json \"compilerOptions\"\n    config.compilerOptions, \n    // from env var\n    index_1.DEFAULTS.compilerOptions, \n    // tsconfig.json \"ts-node\": \"compilerOptions\"\n    tsNodeOptionsFromTsconfig.compilerOptions, \n    // passed programmatically\n    rawApiOptions.compilerOptions, \n    // overrides required by ts-node, cannot be changed\n    TS_NODE_COMPILER_OPTIONS);\n    const fixedConfig = fixConfig(ts, ts.parseJsonConfigFileContent(config, {\n        fileExists,\n        readFile,\n        // Only used for globbing \"files\", \"include\", \"exclude\"\n        // When `files` option disabled, we want to avoid the fs calls\n        readDirectory: files ? ts.sys.readDirectory : () => [],\n        useCaseSensitiveFileNames: ts.sys.useCaseSensitiveFileNames,\n    }, basePath, undefined, configFilePath));\n    return {\n        configFilePath,\n        config: fixedConfig,\n        tsNodeOptionsFromTsconfig,\n        optionBasePaths,\n    };\n}\nexports.readConfig = readConfig;\n/**\n * Load the typescript compiler. It is required to load the tsconfig but might\n * be changed by the tsconfig, so we have to do this twice.\n * @internal\n */\nfunction resolveAndLoadCompiler(name, relativeToPath) {\n    const { compiler } = resolveCompiler(name, relativeToPath);\n    const ts = loadCompiler(compiler);\n    return { compiler, ts };\n}\nexports.resolveAndLoadCompiler = resolveAndLoadCompiler;\nfunction resolveCompiler(name, relativeToPath) {\n    const projectLocalResolveHelper = (0, util_1.createProjectLocalResolveHelper)(relativeToPath);\n    const compiler = projectLocalResolveHelper(name || 'typescript', true);\n    return { compiler };\n}\n/** @internal */\nfunction loadCompiler(compiler) {\n    return (0, util_1.attemptRequireWithV8CompileCache)(require, compiler);\n}\nexports.loadCompiler = loadCompiler;\n/**\n * Given the raw \"ts-node\" sub-object from a tsconfig, return an object with only the properties\n * recognized by \"ts-node\"\n */\nfunction filterRecognizedTsConfigTsNodeOptions(jsonObject) {\n    if (jsonObject == null)\n        return { recognized: {}, unrecognized: {} };\n    const { compiler, compilerHost, compilerOptions, emit, files, ignore, ignoreDiagnostics, logError, preferTsExts, pretty, require, skipIgnore, transpileOnly, typeCheck, transpiler, scope, scopeDir, moduleTypes, experimentalReplAwait, swc, experimentalResolver, esm, experimentalSpecifierResolution, experimentalTsImportSpecifiers, ...unrecognized } = jsonObject;\n    const filteredTsConfigOptions = {\n        compiler,\n        compilerHost,\n        compilerOptions,\n        emit,\n        experimentalReplAwait,\n        files,\n        ignore,\n        ignoreDiagnostics,\n        logError,\n        preferTsExts,\n        pretty,\n        require,\n        skipIgnore,\n        transpileOnly,\n        typeCheck,\n        transpiler,\n        scope,\n        scopeDir,\n        moduleTypes,\n        swc,\n        experimentalResolver,\n        esm,\n        experimentalSpecifierResolution,\n        experimentalTsImportSpecifiers,\n    };\n    // Use the typechecker to make sure this implementation has the correct set of properties\n    const catchExtraneousProps = null;\n    const catchMissingProps = null;\n    return { recognized: filteredTsConfigOptions, unrecognized };\n}\n/** @internal */\nexports.ComputeAsCommonRootOfFiles = Symbol();\n/**\n * Some TS compiler options have defaults which are not provided by TS's config parsing functions.\n * This function centralizes the logic for computing those defaults.\n * @internal\n */\nfunction getTsConfigDefaults(config, basePath, _files, _include, _exclude) {\n    const { composite = false } = config.options;\n    let rootDir = config.options.rootDir;\n    if (rootDir == null) {\n        if (composite)\n            rootDir = basePath;\n        // Return this symbol to avoid computing from `files`, which would require fs calls\n        else\n            rootDir = exports.ComputeAsCommonRootOfFiles;\n    }\n    const { outDir = rootDir } = config.options;\n    // Docs are wrong: https://www.typescriptlang.org/tsconfig#include\n    // Docs say **, but it's actually **/*; compiler throws error for **\n    const include = _files ? [] : ['**/*'];\n    const files = _files !== null && _files !== void 0 ? _files : [];\n    // Docs are misleading: https://www.typescriptlang.org/tsconfig#exclude\n    // Docs say it excludes node_modules, bower_components, jspm_packages, but actually those are excluded via behavior of \"include\"\n    const exclude = _exclude !== null && _exclude !== void 0 ? _exclude : [outDir]; // TODO technically, outDir is absolute path, but exclude should be relative glob pattern?\n    // TODO compute baseUrl\n    return { rootDir, outDir, include, files, exclude, composite };\n}\nexports.getTsConfigDefaults = getTsConfigDefaults;\n//# sourceMappingURL=configuration.js.map",
    "dist/module-type-classifier.js": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createModuleTypeClassifier = void 0;\nconst ts_internals_1 = require(\"./ts-internals\");\nconst util_1 = require(\"./util\");\n/**\n * @internal\n * May receive non-normalized options -- basePath and patterns -- and will normalize them\n * internally.\n * However, calls to `classifyModule` must pass pre-normalized paths!\n */\nfunction createModuleTypeClassifier(options) {\n    const { patterns, basePath: _basePath } = options;\n    const basePath = _basePath !== undefined\n        ? (0, util_1.normalizeSlashes)(_basePath).replace(/\\/$/, '')\n        : undefined;\n    const patternTypePairs = Object.entries(patterns !== null && patterns !== void 0 ? patterns : []).map(([_pattern, type]) => {\n        const pattern = (0, util_1.normalizeSlashes)(_pattern);\n        return { pattern: parsePattern(basePath, pattern), type };\n    });\n    const classifications = {\n        package: {\n            moduleType: 'auto',\n        },\n        cjs: {\n            moduleType: 'cjs',\n        },\n        esm: {\n            moduleType: 'esm',\n        },\n    };\n    const auto = classifications.package;\n    // Passed path must be normalized!\n    function classifyModuleNonCached(path) {\n        const matched = matchPatterns(patternTypePairs, (_) => _.pattern, path);\n        if (matched)\n            return classifications[matched.type];\n        return auto;\n    }\n    const classifyModule = (0, util_1.cachedLookup)(classifyModuleNonCached);\n    function classifyModuleAuto(path) {\n        return auto;\n    }\n    return {\n        classifyModuleByModuleTypeOverrides: patternTypePairs.length\n            ? classifyModule\n            : classifyModuleAuto,\n    };\n}\nexports.createModuleTypeClassifier = createModuleTypeClassifier;\nfunction parsePattern(basePath, patternString) {\n    const pattern = (0, ts_internals_1.getPatternFromSpec)(patternString, basePath);\n    return pattern !== undefined ? new RegExp(pattern) : /(?:)/;\n}\nfunction matchPatterns(objects, getPattern, candidate) {\n    for (let i = objects.length - 1; i >= 0; i--) {\n        const object = objects[i];\n        const pattern = getPattern(object);\n        if (pattern === null || pattern === void 0 ? void 0 : pattern.test(candidate)) {\n            return object;\n        }\n    }\n}\n//# sourceMappingURL=module-type-classifier.js.map",
    "dist/resolver-functions.js": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createResolverFunctions = void 0;\nconst path_1 = require(\"path\");\n/**\n * @internal\n * In a factory because these are shared across both CompilerHost and LanguageService codepaths\n */\nfunction createResolverFunctions(kwargs) {\n    const { host, ts, config, cwd, getCanonicalFileName, projectLocalResolveHelper, options, extensions, } = kwargs;\n    const moduleResolutionCache = ts.createModuleResolutionCache(cwd, getCanonicalFileName, config.options);\n    const knownInternalFilenames = new Set();\n    /** \"Buckets\" (module directories) whose contents should be marked \"internal\" */\n    const internalBuckets = new Set();\n    // Get bucket for a source filename.  Bucket is the containing `./node_modules/*/` directory\n    // For '/project/node_modules/foo/node_modules/bar/lib/index.js' bucket is '/project/node_modules/foo/node_modules/bar/'\n    // For '/project/node_modules/foo/node_modules/@scope/bar/lib/index.js' bucket is '/project/node_modules/foo/node_modules/@scope/bar/'\n    const moduleBucketRe = /.*\\/node_modules\\/(?:@[^\\/]+\\/)?[^\\/]+\\//;\n    function getModuleBucket(filename) {\n        const find = moduleBucketRe.exec(filename);\n        if (find)\n            return find[0];\n        return '';\n    }\n    // Mark that this file and all siblings in its bucket should be \"internal\"\n    function markBucketOfFilenameInternal(filename) {\n        internalBuckets.add(getModuleBucket(filename));\n    }\n    function isFileInInternalBucket(filename) {\n        return internalBuckets.has(getModuleBucket(filename));\n    }\n    function isFileKnownToBeInternal(filename) {\n        return knownInternalFilenames.has(filename);\n    }\n    /**\n     * If we need to emit JS for a file, force TS to consider it non-external\n     */\n    const fixupResolvedModule = (resolvedModule) => {\n        const { resolvedFileName } = resolvedModule;\n        if (resolvedFileName === undefined)\n            return;\n        // [MUST_UPDATE_FOR_NEW_FILE_EXTENSIONS]\n        // .ts,.mts,.cts is always switched to internal\n        // .js is switched on-demand\n        if (resolvedModule.isExternalLibraryImport &&\n            ((resolvedFileName.endsWith('.ts') &&\n                !resolvedFileName.endsWith('.d.ts')) ||\n                (resolvedFileName.endsWith('.cts') &&\n                    !resolvedFileName.endsWith('.d.cts')) ||\n                (resolvedFileName.endsWith('.mts') &&\n                    !resolvedFileName.endsWith('.d.mts')) ||\n                isFileKnownToBeInternal(resolvedFileName) ||\n                isFileInInternalBucket(resolvedFileName))) {\n            resolvedModule.isExternalLibraryImport = false;\n        }\n        if (!resolvedModule.isExternalLibraryImport) {\n            knownInternalFilenames.add(resolvedFileName);\n        }\n    };\n    /*\n     * NOTE:\n     * Older ts versions do not pass `redirectedReference` nor `options`.\n     * We must pass `redirectedReference` to newer ts versions, but cannot rely on `options`, hence the weird argument name\n     */\n    const resolveModuleNames = (moduleNames, containingFile, reusedNames, redirectedReference, optionsOnlyWithNewerTsVersions, containingSourceFile) => {\n        return moduleNames.map((moduleName, i) => {\n            var _a, _b;\n            const mode = containingSourceFile\n                ? (_b = (_a = ts).getModeForResolutionAtIndex) === null || _b === void 0 ? void 0 : _b.call(_a, containingSourceFile, i)\n                : undefined;\n            let { resolvedModule } = ts.resolveModuleName(moduleName, containingFile, config.options, host, moduleResolutionCache, redirectedReference, mode);\n            if (!resolvedModule && options.experimentalTsImportSpecifiers) {\n                const lastDotIndex = moduleName.lastIndexOf('.');\n                const ext = lastDotIndex >= 0 ? moduleName.slice(lastDotIndex) : '';\n                if (ext) {\n                    const replacements = extensions.tsResolverEquivalents.get(ext);\n                    for (const replacementExt of replacements !== null && replacements !== void 0 ? replacements : []) {\n                        ({ resolvedModule } = ts.resolveModuleName(moduleName.slice(0, -ext.length) + replacementExt, containingFile, config.options, host, moduleResolutionCache, redirectedReference, mode));\n                        if (resolvedModule)\n                            break;\n                    }\n                }\n            }\n            if (resolvedModule) {\n                fixupResolvedModule(resolvedModule);\n            }\n            return resolvedModule;\n        });\n    };\n    // language service never calls this, but TS docs recommend that we implement it\n    const getResolvedModuleWithFailedLookupLocationsFromCache = (moduleName, containingFile, resolutionMode) => {\n        const ret = ts.resolveModuleNameFromCache(moduleName, containingFile, moduleResolutionCache, resolutionMode);\n        if (ret && ret.resolvedModule) {\n            fixupResolvedModule(ret.resolvedModule);\n        }\n        return ret;\n    };\n    const resolveTypeReferenceDirectives = (typeDirectiveNames, containingFile, redirectedReference, options, containingFileMode // new impliedNodeFormat is accepted by compilerHost\n    ) => {\n        // Note: seems to be called with empty typeDirectiveNames array for all files.\n        // TODO consider using `ts.loadWithTypeDirectiveCache`\n        return typeDirectiveNames.map((typeDirectiveName) => {\n            // Copy-pasted from TS source:\n            const nameIsString = typeof typeDirectiveName === 'string';\n            const mode = nameIsString\n                ? undefined\n                : ts.getModeForFileReference(typeDirectiveName, containingFileMode);\n            const strName = nameIsString\n                ? typeDirectiveName\n                : typeDirectiveName.fileName.toLowerCase();\n            let { resolvedTypeReferenceDirective } = ts.resolveTypeReferenceDirective(strName, containingFile, config.options, host, redirectedReference, undefined, mode);\n            if (typeDirectiveName === 'node' && !resolvedTypeReferenceDirective) {\n                // Resolve @types/node relative to project first, then __dirname (copy logic from elsewhere / refactor into reusable function)\n                let typesNodePackageJsonPath;\n                try {\n                    typesNodePackageJsonPath = projectLocalResolveHelper('@types/node/package.json', true);\n                }\n                catch { } // gracefully do nothing when @types/node is not installed for any reason\n                if (typesNodePackageJsonPath) {\n                    const typeRoots = [(0, path_1.resolve)(typesNodePackageJsonPath, '../..')];\n                    ({ resolvedTypeReferenceDirective } =\n                        ts.resolveTypeReferenceDirective(typeDirectiveName, containingFile, {\n                            ...config.options,\n                            typeRoots,\n                        }, host, redirectedReference));\n                }\n            }\n            if (resolvedTypeReferenceDirective) {\n                fixupResolvedModule(resolvedTypeReferenceDirective);\n            }\n            return resolvedTypeReferenceDirective;\n        });\n    };\n    return {\n        resolveModuleNames,\n        getResolvedModuleWithFailedLookupLocationsFromCache,\n        resolveTypeReferenceDirectives,\n        isFileKnownToBeInternal,\n        markBucketOfFilenameInternal,\n    };\n}\nexports.createResolverFunctions = createResolverFunctions;\n//# sourceMappingURL=resolver-functions.js.map",
    "dist/cjs-resolve-hooks.js": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.installCommonjsResolveHooksIfNecessary = void 0;\n/**\n * @internal\n */\nfunction installCommonjsResolveHooksIfNecessary(tsNodeService) {\n    const Module = require('module');\n    const originalResolveFilename = Module._resolveFilename;\n    const originalFindPath = Module._findPath;\n    const shouldInstallHook = tsNodeService.options.experimentalResolver;\n    if (shouldInstallHook) {\n        const { Module_findPath, Module_resolveFilename } = tsNodeService.getNodeCjsLoader();\n        Module._resolveFilename = _resolveFilename;\n        Module._findPath = _findPath;\n        function _resolveFilename(request, parent, isMain, options, ...rest) {\n            if (!tsNodeService.enabled())\n                return originalResolveFilename.call(this, request, parent, isMain, options, ...rest);\n            return Module_resolveFilename.call(this, request, parent, isMain, options, ...rest);\n        }\n        function _findPath() {\n            if (!tsNodeService.enabled())\n                return originalFindPath.apply(this, arguments);\n            return Module_findPath.apply(this, arguments);\n        }\n    }\n}\nexports.installCommonjsResolveHooksIfNecessary = installCommonjsResolveHooksIfNecessary;\n//# sourceMappingURL=cjs-resolve-hooks.js.map",
    "dist/node-module-type-classifier.js": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.classifyModule = void 0;\nconst node_internal_modules_cjs_loader_1 = require(\"../dist-raw/node-internal-modules-cjs-loader\");\n/**\n * Determine how to emit a module based on tsconfig \"module\" and package.json \"type\"\n *\n * Supports module=nodenext/node16 with transpileOnly, where we cannot ask the\n * TS typechecker to tell us if a file is CJS or ESM.\n *\n * Return values indicate:\n * - cjs\n * - esm\n * - nodecjs == node-flavored cjs where dynamic imports are *not* transformed into `require()`\n * - undefined == emit according to tsconfig `module` config, whatever that is\n * @internal\n */\nfunction classifyModule(nativeFilename, isNodeModuleType) {\n    // [MUST_UPDATE_FOR_NEW_FILE_EXTENSIONS]\n    const lastDotIndex = nativeFilename.lastIndexOf('.');\n    const ext = lastDotIndex >= 0 ? nativeFilename.slice(lastDotIndex) : '';\n    switch (ext) {\n        case '.cjs':\n        case '.cts':\n            return isNodeModuleType ? 'nodecjs' : 'cjs';\n        case '.mjs':\n        case '.mts':\n            return isNodeModuleType ? 'nodeesm' : 'esm';\n    }\n    if (isNodeModuleType) {\n        const packageScope = (0, node_internal_modules_cjs_loader_1.readPackageScope)(nativeFilename);\n        if (packageScope && packageScope.data.type === 'module')\n            return 'nodeesm';\n        return 'nodecjs';\n    }\n    return undefined;\n}\nexports.classifyModule = classifyModule;\n//# sourceMappingURL=node-module-type-classifier.js.map",
    "dist/file-extensions.js": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getExtensions = void 0;\nconst util_1 = require(\"./util\");\nconst nodeEquivalents = new Map([\n    ['.ts', '.js'],\n    ['.tsx', '.js'],\n    ['.jsx', '.js'],\n    ['.mts', '.mjs'],\n    ['.cts', '.cjs'],\n]);\nconst tsResolverEquivalents = new Map([\n    ['.ts', ['.js']],\n    ['.tsx', ['.js', '.jsx']],\n    ['.mts', ['.mjs']],\n    ['.cts', ['.cjs']],\n]);\n// All extensions understood by vanilla node\nconst vanillaNodeExtensions = [\n    '.js',\n    '.json',\n    '.node',\n    '.mjs',\n    '.cjs',\n];\n// Extensions added by vanilla node's require() if you omit them:\n// js, json, node\n// Extensions added by vanilla node if you omit them with --experimental-specifier-resolution=node\n// js, json, node, mjs\n// Extensions added by ESM codepath's legacy package.json \"main\" resolver\n// js, json, node (not mjs!)\nconst nodeDoesNotUnderstand = [\n    '.ts',\n    '.tsx',\n    '.jsx',\n    '.cts',\n    '.mts',\n];\n/**\n * [MUST_UPDATE_FOR_NEW_FILE_EXTENSIONS]\n * @internal\n */\nfunction getExtensions(config, options, tsVersion) {\n    // TS 4.5 is first version to understand .cts, .mts, .cjs, and .mjs extensions\n    const tsSupportsMtsCtsExts = (0, util_1.versionGteLt)(tsVersion, '4.5.0');\n    const requiresHigherTypescriptVersion = [];\n    if (!tsSupportsMtsCtsExts)\n        requiresHigherTypescriptVersion.push('.cts', '.cjs', '.mts', '.mjs');\n    const allPossibleExtensionsSortedByPreference = Array.from(new Set([\n        ...(options.preferTsExts ? nodeDoesNotUnderstand : []),\n        ...vanillaNodeExtensions,\n        ...nodeDoesNotUnderstand,\n    ]));\n    const compiledJsUnsorted = ['.ts'];\n    const compiledJsxUnsorted = [];\n    if (config.options.jsx)\n        compiledJsxUnsorted.push('.tsx');\n    if (tsSupportsMtsCtsExts)\n        compiledJsUnsorted.push('.mts', '.cts');\n    if (config.options.allowJs) {\n        compiledJsUnsorted.push('.js');\n        if (config.options.jsx)\n            compiledJsxUnsorted.push('.jsx');\n        if (tsSupportsMtsCtsExts)\n            compiledJsUnsorted.push('.mjs', '.cjs');\n    }\n    const compiledUnsorted = [...compiledJsUnsorted, ...compiledJsxUnsorted];\n    const compiled = allPossibleExtensionsSortedByPreference.filter((ext) => compiledUnsorted.includes(ext));\n    const compiledNodeDoesNotUnderstand = nodeDoesNotUnderstand.filter((ext) => compiled.includes(ext));\n    /**\n     * TS's resolver can resolve foo.js to foo.ts, by replacing .js extension with several source extensions.\n     * IMPORTANT: Must preserve ordering according to preferTsExts!\n     *            Must include the .js/.mjs/.cjs extension in the array!\n     *            This affects resolution behavior!\n     * [MUST_UPDATE_FOR_NEW_FILE_EXTENSIONS]\n     */\n    const r = allPossibleExtensionsSortedByPreference.filter((ext) => [...compiledUnsorted, '.js', '.mjs', '.cjs', '.mts', '.cts'].includes(ext));\n    const replacementsForJs = r.filter((ext) => ['.js', '.jsx', '.ts', '.tsx'].includes(ext));\n    const replacementsForJsx = r.filter((ext) => ['.jsx', '.tsx'].includes(ext));\n    const replacementsForMjs = r.filter((ext) => ['.mjs', '.mts'].includes(ext));\n    const replacementsForCjs = r.filter((ext) => ['.cjs', '.cts'].includes(ext));\n    const replacementsForJsOrMjs = r.filter((ext) => ['.js', '.jsx', '.ts', '.tsx', '.mjs', '.mts'].includes(ext));\n    // Node allows omitting .js or .mjs extension in certain situations (CJS, ESM w/experimental flag)\n    // So anything that compiles to .js or .mjs can also be omitted.\n    const experimentalSpecifierResolutionAddsIfOmitted = Array.from(new Set([...replacementsForJsOrMjs, '.json', '.node']));\n    // Same as above, except node curiuosly doesn't do .mjs here\n    const legacyMainResolveAddsIfOmitted = Array.from(new Set([...replacementsForJs, '.json', '.node']));\n    return {\n        /** All file extensions we transform, ordered by resolution preference according to preferTsExts */\n        compiled,\n        /** Resolved extensions that vanilla node will not understand; we should handle them */\n        nodeDoesNotUnderstand,\n        /** Like the above, but only the ones we're compiling */\n        compiledNodeDoesNotUnderstand,\n        /**\n         * Mapping from extensions understood by tsc to the equivalent for node,\n         * as far as getFormat is concerned.\n         */\n        nodeEquivalents,\n        /**\n         * Mapping from extensions rejected by TSC in import specifiers, to the\n         * possible alternatives that TS's resolver will accept.\n         *\n         * When we allow users to opt-in to .ts extensions in import specifiers, TS's\n         * resolver requires us to replace the .ts extensions with .js alternatives.\n         * Otherwise, resolution fails.\n         *\n         * Note TS's resolver is only used by, and only required for, typechecking.\n         * This is separate from node's resolver, which we hook separately and which\n         * does not require this mapping.\n         */\n        tsResolverEquivalents,\n        /**\n         * Extensions that we can support if the user upgrades their typescript version.\n         * Used when raising hints.\n         */\n        requiresHigherTypescriptVersion,\n        /**\n         * --experimental-specifier-resolution=node will add these extensions.\n         */\n        experimentalSpecifierResolutionAddsIfOmitted,\n        /**\n         * ESM loader will add these extensions to package.json \"main\" field\n         */\n        legacyMainResolveAddsIfOmitted,\n        replacementsForMjs,\n        replacementsForCjs,\n        replacementsForJsx,\n        replacementsForJs,\n    };\n}\nexports.getExtensions = getExtensions;\n//# sourceMappingURL=file-extensions.js.map",
    "dist/ts-transpile-module.js": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createTsTranspileModule = void 0;\n/** @internal */\nfunction createTsTranspileModule(ts, transpileOptions) {\n    const { createProgram, createSourceFile, getDefaultCompilerOptions, getImpliedNodeFormatForFile, fixupCompilerOptions, transpileOptionValueCompilerOptions, getNewLineCharacter, fileExtensionIs, normalizePath, Debug, toPath, getSetExternalModuleIndicator, getEntries, addRange, hasProperty, getEmitScriptTarget, getDirectoryPath, } = ts;\n    const compilerOptionsDiagnostics = [];\n    const options = transpileOptions.compilerOptions\n        ? fixupCompilerOptions(transpileOptions.compilerOptions, compilerOptionsDiagnostics)\n        : {};\n    // mix in default options\n    const defaultOptions = getDefaultCompilerOptions();\n    for (const key in defaultOptions) {\n        if (hasProperty(defaultOptions, key) && options[key] === undefined) {\n            options[key] = defaultOptions[key];\n        }\n    }\n    for (const option of transpileOptionValueCompilerOptions) {\n        options[option.name] = option.transpileOptionValue;\n    }\n    // transpileModule does not write anything to disk so there is no need to verify that there are no conflicts between input and output paths.\n    options.suppressOutputPathCheck = true;\n    // Filename can be non-ts file.\n    options.allowNonTsExtensions = true;\n    const newLine = getNewLineCharacter(options);\n    // Create a compilerHost object to allow the compiler to read and write files\n    const compilerHost = {\n        getSourceFile: (fileName) => fileName === normalizePath(inputFileName) ? sourceFile : undefined,\n        writeFile: (name, text) => {\n            if (fileExtensionIs(name, '.map')) {\n                Debug.assertEqual(sourceMapText, undefined, 'Unexpected multiple source map outputs, file:', name);\n                sourceMapText = text;\n            }\n            else {\n                Debug.assertEqual(outputText, undefined, 'Unexpected multiple outputs, file:', name);\n                outputText = text;\n            }\n        },\n        getDefaultLibFileName: () => 'lib.d.ts',\n        useCaseSensitiveFileNames: () => true,\n        getCanonicalFileName: (fileName) => fileName,\n        getCurrentDirectory: () => '',\n        getNewLine: () => newLine,\n        fileExists: (fileName) => fileName === inputFileName || fileName === packageJsonFileName,\n        readFile: (fileName) => fileName === packageJsonFileName ? `{\"type\": \"${_packageJsonType}\"}` : '',\n        directoryExists: () => true,\n        getDirectories: () => [],\n    };\n    let inputFileName;\n    let packageJsonFileName;\n    let _packageJsonType;\n    let sourceFile;\n    let outputText;\n    let sourceMapText;\n    return transpileModule;\n    function transpileModule(input, transpileOptions2, packageJsonType = 'commonjs') {\n        // if jsx is specified then treat file as .tsx\n        inputFileName =\n            transpileOptions2.fileName ||\n                (transpileOptions.compilerOptions && transpileOptions.compilerOptions.jsx\n                    ? 'module.tsx'\n                    : 'module.ts');\n        packageJsonFileName = getDirectoryPath(inputFileName) + '/package.json';\n        _packageJsonType = packageJsonType;\n        sourceFile = createSourceFile(inputFileName, input, {\n            languageVersion: getEmitScriptTarget(options),\n            impliedNodeFormat: getImpliedNodeFormatForFile(toPath(inputFileName, '', compilerHost.getCanonicalFileName), \n            /*cache*/ undefined, compilerHost, options),\n            setExternalModuleIndicator: getSetExternalModuleIndicator(options),\n        });\n        if (transpileOptions2.moduleName) {\n            sourceFile.moduleName = transpileOptions2.moduleName;\n        }\n        if (transpileOptions2.renamedDependencies) {\n            sourceFile.renamedDependencies = new Map(getEntries(transpileOptions2.renamedDependencies));\n        }\n        // Output\n        outputText = undefined;\n        sourceMapText = undefined;\n        const program = createProgram([inputFileName], options, compilerHost);\n        const diagnostics = compilerOptionsDiagnostics.slice();\n        if (transpileOptions.reportDiagnostics) {\n            addRange(\n            /*to*/ diagnostics, \n            /*from*/ program.getSyntacticDiagnostics(sourceFile));\n            addRange(/*to*/ diagnostics, /*from*/ program.getOptionsDiagnostics());\n        }\n        // Emit\n        program.emit(\n        /*targetSourceFile*/ undefined, \n        /*writeFile*/ undefined, \n        /*cancellationToken*/ undefined, \n        /*emitOnlyDtsFiles*/ undefined, transpileOptions.transformers);\n        if (outputText === undefined)\n            return Debug.fail('Output generation failed');\n        return { outputText, diagnostics, sourceMapText };\n    }\n}\nexports.createTsTranspileModule = createTsTranspileModule;\n//# sourceMappingURL=ts-transpile-module.js.map",
    "dist/repl.js": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.setupContext = exports.createEvalAwarePartialHost = exports.EvalState = exports.createRepl = exports.REPL_NAME = exports.REPL_FILENAME = exports.STDIN_NAME = exports.STDIN_FILENAME = exports.EVAL_NAME = exports.EVAL_FILENAME = void 0;\nconst os_1 = require(\"os\");\nconst path_1 = require(\"path\");\nconst repl_1 = require(\"repl\");\nconst vm_1 = require(\"vm\");\nconst index_1 = require(\"./index\");\nconst fs_1 = require(\"fs\");\nconst console_1 = require(\"console\");\nconst assert = require(\"assert\");\nconst module_1 = require(\"module\");\n// Lazy-loaded.\nlet _processTopLevelAwait;\nfunction getProcessTopLevelAwait() {\n    if (_processTopLevelAwait === undefined) {\n        ({\n            processTopLevelAwait: _processTopLevelAwait,\n        } = require('../dist-raw/node-internal-repl-await'));\n    }\n    return _processTopLevelAwait;\n}\nlet diff;\nfunction getDiffLines() {\n    if (diff === undefined) {\n        diff = require('diff');\n    }\n    return diff.diffLines;\n}\n/** @internal */\nexports.EVAL_FILENAME = `[eval].ts`;\n/** @internal */\nexports.EVAL_NAME = `[eval]`;\n/** @internal */\nexports.STDIN_FILENAME = `[stdin].ts`;\n/** @internal */\nexports.STDIN_NAME = `[stdin]`;\n/** @internal */\nexports.REPL_FILENAME = '<repl>.ts';\n/** @internal */\nexports.REPL_NAME = '<repl>';\n/**\n * Create a ts-node REPL instance.\n *\n * Pay close attention to the example below.  Today, the API requires a few lines\n * of boilerplate to correctly bind the `ReplService` to the ts-node `Service` and\n * vice-versa.\n *\n * Usage example:\n *\n *     const repl = tsNode.createRepl();\n *     const service = tsNode.create({...repl.evalAwarePartialHost});\n *     repl.setService(service);\n *     repl.start();\n *\n * @category REPL\n */\nfunction createRepl(options = {}) {\n    var _a, _b, _c, _d, _e;\n    const { ignoreDiagnosticsThatAreAnnoyingInInteractiveRepl = true } = options;\n    let service = options.service;\n    let nodeReplServer;\n    // If `useGlobal` is not true, then REPL creates a context when started.\n    // This stores a reference to it or to `global`, whichever is used, after REPL has started.\n    let context;\n    const state = (_a = options.state) !== null && _a !== void 0 ? _a : new EvalState((0, path_1.join)(process.cwd(), exports.REPL_FILENAME));\n    const evalAwarePartialHost = createEvalAwarePartialHost(state, options.composeWithEvalAwarePartialHost);\n    const stdin = (_b = options.stdin) !== null && _b !== void 0 ? _b : process.stdin;\n    const stdout = (_c = options.stdout) !== null && _c !== void 0 ? _c : process.stdout;\n    const stderr = (_d = options.stderr) !== null && _d !== void 0 ? _d : process.stderr;\n    const _console = stdout === process.stdout && stderr === process.stderr\n        ? console\n        : new console_1.Console(stdout, stderr);\n    const replService = {\n        state: (_e = options.state) !== null && _e !== void 0 ? _e : new EvalState((0, path_1.join)(process.cwd(), exports.EVAL_FILENAME)),\n        setService,\n        evalCode,\n        evalCodeInternal,\n        nodeEval,\n        evalAwarePartialHost,\n        start,\n        startInternal,\n        stdin,\n        stdout,\n        stderr,\n        console: _console,\n    };\n    return replService;\n    function setService(_service) {\n        service = _service;\n        if (ignoreDiagnosticsThatAreAnnoyingInInteractiveRepl) {\n            service.addDiagnosticFilter({\n                appliesToAllFiles: false,\n                filenamesAbsolute: [state.path],\n                diagnosticsIgnored: [\n                    2393,\n                    6133,\n                    7027,\n                    ...(service.shouldReplAwait ? topLevelAwaitDiagnosticCodes : []),\n                ],\n            });\n        }\n    }\n    function evalCode(code) {\n        const result = appendCompileAndEvalInput({\n            service: service,\n            state,\n            input: code,\n            context,\n            overrideIsCompletion: false,\n        });\n        assert(result.containsTopLevelAwait === false);\n        return result.value;\n    }\n    function evalCodeInternal(options) {\n        const { code, enableTopLevelAwait, context } = options;\n        return appendCompileAndEvalInput({\n            service: service,\n            state,\n            input: code,\n            enableTopLevelAwait,\n            context,\n        });\n    }\n    function nodeEval(code, context, _filename, callback) {\n        // TODO: Figure out how to handle completion here.\n        if (code === '.scope') {\n            callback(null);\n            return;\n        }\n        try {\n            const evalResult = evalCodeInternal({\n                code,\n                enableTopLevelAwait: true,\n                context,\n            });\n            if (evalResult.containsTopLevelAwait) {\n                (async () => {\n                    try {\n                        callback(null, await evalResult.valuePromise);\n                    }\n                    catch (promiseError) {\n                        handleError(promiseError);\n                    }\n                })();\n            }\n            else {\n                callback(null, evalResult.value);\n            }\n        }\n        catch (error) {\n            handleError(error);\n        }\n        // Log TSErrors, check if they're recoverable, log helpful hints for certain\n        // well-known errors, and invoke `callback()`\n        // TODO should evalCode API get the same error-handling benefits?\n        function handleError(error) {\n            var _a, _b;\n            // Don't show TLA hint if the user explicitly disabled repl top level await\n            const canLogTopLevelAwaitHint = service.options.experimentalReplAwait !== false &&\n                !service.shouldReplAwait;\n            if (error instanceof index_1.TSError) {\n                // Support recoverable compilations using >= node 6.\n                if (repl_1.Recoverable && isRecoverable(error)) {\n                    callback(new repl_1.Recoverable(error));\n                    return;\n                }\n                else {\n                    _console.error(error);\n                    if (canLogTopLevelAwaitHint &&\n                        error.diagnosticCodes.some((dC) => topLevelAwaitDiagnosticCodes.includes(dC))) {\n                        _console.error(getTopLevelAwaitHint());\n                    }\n                    callback(null);\n                }\n            }\n            else {\n                let _error = error;\n                if (canLogTopLevelAwaitHint &&\n                    _error instanceof SyntaxError &&\n                    ((_a = _error.message) === null || _a === void 0 ? void 0 : _a.includes('await is only valid'))) {\n                    try {\n                        // Only way I know to make our hint appear after the error\n                        _error.message += `\\n\\n${getTopLevelAwaitHint()}`;\n                        _error.stack = (_b = _error.stack) === null || _b === void 0 ? void 0 : _b.replace(/(SyntaxError:.*)/, (_, $1) => `${$1}\\n\\n${getTopLevelAwaitHint()}`);\n                    }\n                    catch { }\n                }\n                callback(_error);\n            }\n        }\n        function getTopLevelAwaitHint() {\n            return `Hint: REPL top-level await requires TypeScript version 3.8 or higher and target ES2018 or higher. You are using TypeScript ${service.ts.version} and target ${service.ts.ScriptTarget[service.config.options.target]}.`;\n        }\n    }\n    // Note: `code` argument is deprecated\n    function start(code) {\n        startInternal({ code });\n    }\n    // Note: `code` argument is deprecated\n    function startInternal(options) {\n        const { code, forceToBeModule = true, ...optionsOverride } = options !== null && options !== void 0 ? options : {};\n        // TODO assert that `service` is set; remove all `service!` non-null assertions\n        // Eval incoming code before the REPL starts.\n        // Note: deprecated\n        if (code) {\n            try {\n                evalCode(`${code}\\n`);\n            }\n            catch (err) {\n                _console.error(err);\n                // Note: should not be killing the process here, but this codepath is deprecated anyway\n                process.exit(1);\n            }\n        }\n        // In case the typescript compiler hasn't compiled anything yet,\n        // make it run though compilation at least one time before\n        // the REPL starts for a snappier user experience on startup.\n        service === null || service === void 0 ? void 0 : service.compile('', state.path);\n        const repl = (0, repl_1.start)({\n            prompt: '> ',\n            input: replService.stdin,\n            output: replService.stdout,\n            // Mimicking node's REPL implementation: https://github.com/nodejs/node/blob/168b22ba073ee1cbf8d0bcb4ded7ff3099335d04/lib/internal/repl.js#L28-L30\n            terminal: stdout.isTTY &&\n                !parseInt(index_1.env.NODE_NO_READLINE, 10),\n            eval: nodeEval,\n            useGlobal: true,\n            ...optionsOverride,\n        });\n        nodeReplServer = repl;\n        context = repl.context;\n        // Bookmark the point where we should reset the REPL state.\n        const resetEval = appendToEvalState(state, '');\n        function reset() {\n            resetEval();\n            // Hard fix for TypeScript forcing `Object.defineProperty(exports, ...)`.\n            runInContext('exports = module.exports', state.path, context);\n            if (forceToBeModule) {\n                state.input += 'export {};void 0;\\n';\n            }\n            // Declare node builtins.\n            // Skip the same builtins as `addBuiltinLibsToObject`:\n            //   those starting with _\n            //   those containing /\n            //   those that already exist as globals\n            // Intentionally suppress type errors in case @types/node does not declare any of them, and because\n            // `declare import` is technically invalid syntax.\n            // Avoid this when in transpileOnly, because third-party transpilers may not handle `declare import`.\n            if (!(service === null || service === void 0 ? void 0 : service.transpileOnly)) {\n                state.input += `// @ts-ignore\\n${module_1.builtinModules\n                    .filter((name) => !name.startsWith('_') &&\n                    !name.includes('/') &&\n                    !['console', 'module', 'process'].includes(name))\n                    .map((name) => `declare import ${name} = require('${name}')`)\n                    .join(';')}\\n`;\n            }\n        }\n        reset();\n        repl.on('reset', reset);\n        repl.defineCommand('type', {\n            help: 'Check the type of a TypeScript identifier',\n            action: function (identifier) {\n                if (!identifier) {\n                    repl.displayPrompt();\n                    return;\n                }\n                const undo = appendToEvalState(state, identifier);\n                const { name, comment } = service.getTypeInfo(state.input, state.path, state.input.length);\n                undo();\n                if (name)\n                    repl.outputStream.write(`${name}\\n`);\n                if (comment)\n                    repl.outputStream.write(`${comment}\\n`);\n                repl.displayPrompt();\n            },\n        });\n        // Set up REPL history when available natively via node.js >= 11.\n        if (repl.setupHistory) {\n            const historyPath = index_1.env.TS_NODE_HISTORY || (0, path_1.join)((0, os_1.homedir)(), '.ts_node_repl_history');\n            repl.setupHistory(historyPath, (err) => {\n                if (!err)\n                    return;\n                _console.error(err);\n                process.exit(1);\n            });\n        }\n        return repl;\n    }\n}\nexports.createRepl = createRepl;\n/**\n * Eval state management. Stores virtual `[eval].ts` file\n */\nclass EvalState {\n    constructor(path) {\n        this.path = path;\n        /** @internal */\n        this.input = '';\n        /** @internal */\n        this.output = '';\n        /** @internal */\n        this.version = 0;\n        /** @internal */\n        this.lines = 0;\n    }\n}\nexports.EvalState = EvalState;\nfunction createEvalAwarePartialHost(state, composeWith) {\n    function readFile(path) {\n        if (path === state.path)\n            return state.input;\n        if (composeWith === null || composeWith === void 0 ? void 0 : composeWith.readFile)\n            return composeWith.readFile(path);\n        try {\n            return (0, fs_1.readFileSync)(path, 'utf8');\n        }\n        catch (err) {\n            /* Ignore. */\n        }\n    }\n    function fileExists(path) {\n        if (path === state.path)\n            return true;\n        if (composeWith === null || composeWith === void 0 ? void 0 : composeWith.fileExists)\n            return composeWith.fileExists(path);\n        try {\n            const stats = (0, fs_1.statSync)(path);\n            return stats.isFile() || stats.isFIFO();\n        }\n        catch (err) {\n            return false;\n        }\n    }\n    return { readFile, fileExists };\n}\nexports.createEvalAwarePartialHost = createEvalAwarePartialHost;\nconst sourcemapCommentRe = /\\/\\/# ?sourceMappingURL=\\S+[\\s\\r\\n]*$/;\n/**\n * Evaluate the code snippet.\n *\n * Append it to virtual .ts file, compile, handle compiler errors, compute a diff of the JS, and eval any code that\n * appears as \"added\" in the diff.\n */\nfunction appendCompileAndEvalInput(options) {\n    const { service, state, wrappedErr, enableTopLevelAwait = false, context, overrideIsCompletion, } = options;\n    let { input } = options;\n    // It's confusing for `{ a: 1 }` to be interpreted as a block statement\n    // rather than an object literal. So, we first try to wrap it in\n    // parentheses, so that it will be interpreted as an expression.\n    // Based on https://github.com/nodejs/node/blob/c2e6822153bad023ab7ebd30a6117dcc049e475c/lib/repl.js#L413-L422\n    let wrappedCmd = false;\n    if (!wrappedErr && /^\\s*{/.test(input) && !/;\\s*$/.test(input)) {\n        input = `(${input.trim()})\\n`;\n        wrappedCmd = true;\n    }\n    const lines = state.lines;\n    const isCompletion = overrideIsCompletion !== null && overrideIsCompletion !== void 0 ? overrideIsCompletion : !/\\n$/.test(input);\n    const undo = appendToEvalState(state, input);\n    let output;\n    // Based on https://github.com/nodejs/node/blob/92573721c7cff104ccb82b6ed3e8aa69c4b27510/lib/repl.js#L457-L461\n    function adjustUseStrict(code) {\n        // \"void 0\" keeps the repl from returning \"use strict\" as the result\n        // value for statements and declarations that don't return a value.\n        return code.replace(/^\"use strict\";/, '\"use strict\"; void 0;');\n    }\n    try {\n        output = service.compile(state.input, state.path, -lines);\n    }\n    catch (err) {\n        undo();\n        if (wrappedCmd) {\n            if (err instanceof index_1.TSError && err.diagnosticCodes[0] === 2339) {\n                // Ensure consistent and more sane behavior between { a: 1 }['b'] and ({ a: 1 }['b'])\n                throw err;\n            }\n            // Unwrap and try again\n            return appendCompileAndEvalInput({\n                ...options,\n                wrappedErr: err,\n            });\n        }\n        if (wrappedErr)\n            throw wrappedErr;\n        throw err;\n    }\n    output = adjustUseStrict(output);\n    // Note: REPL does not respect sourcemaps!\n    // To properly do that, we'd need to prefix the code we eval -- which comes\n    // from `diffLines` -- with newlines so that it's at the proper line numbers.\n    // Then we'd need to ensure each bit of eval-ed code, if there are multiples,\n    // has the sourcemap appended to it.\n    // We might also need to integrate with our sourcemap hooks' cache; I'm not sure.\n    const outputWithoutSourcemapComment = output.replace(sourcemapCommentRe, '');\n    const oldOutputWithoutSourcemapComment = state.output.replace(sourcemapCommentRe, '');\n    // Use `diff` to check for new JavaScript to execute.\n    const changes = getDiffLines()(oldOutputWithoutSourcemapComment, outputWithoutSourcemapComment);\n    if (isCompletion) {\n        undo();\n    }\n    else {\n        state.output = output;\n        // Insert a semicolon to make sure that the code doesn't interact with the next line,\n        // for example to prevent `2\\n+ 2` from producing 4.\n        // This is safe since the output will not change since we can only get here with successful inputs,\n        // and adding a semicolon to the end of a successful input won't ever change the output.\n        state.input = state.input.replace(/([^\\n\\s])([\\n\\s]*)$/, (all, lastChar, whitespace) => {\n            if (lastChar !== ';')\n                return `${lastChar};${whitespace}`;\n            return all;\n        });\n    }\n    let commands = [];\n    let containsTopLevelAwait = false;\n    // Build a list of \"commands\": bits of JS code in the diff that must be executed.\n    for (const change of changes) {\n        if (change.added) {\n            if (enableTopLevelAwait &&\n                service.shouldReplAwait &&\n                change.value.indexOf('await') > -1) {\n                const processTopLevelAwait = getProcessTopLevelAwait();\n                // Newline prevents comments to mess with wrapper\n                const wrappedResult = processTopLevelAwait(change.value + '\\n');\n                if (wrappedResult !== null) {\n                    containsTopLevelAwait = true;\n                    commands.push({\n                        mustAwait: true,\n                        execCommand: () => runInContext(wrappedResult, state.path, context),\n                    });\n                    continue;\n                }\n            }\n            commands.push({\n                execCommand: () => runInContext(change.value, state.path, context),\n            });\n        }\n    }\n    // Execute all commands asynchronously if necessary, returning the result or a\n    // promise of the result.\n    if (containsTopLevelAwait) {\n        return {\n            containsTopLevelAwait,\n            valuePromise: (async () => {\n                let value;\n                for (const command of commands) {\n                    const r = command.execCommand();\n                    value = command.mustAwait ? await r : r;\n                }\n                return value;\n            })(),\n        };\n    }\n    else {\n        return {\n            containsTopLevelAwait: false,\n            value: commands.reduce((_, c) => c.execCommand(), undefined),\n        };\n    }\n}\n/**\n * Low-level execution of JS code in context\n */\nfunction runInContext(code, filename, context) {\n    const script = new vm_1.Script(code, { filename });\n    if (context === undefined || context === global) {\n        return script.runInThisContext();\n    }\n    else {\n        return script.runInContext(context);\n    }\n}\n/**\n * Append to the eval instance and return an undo function.\n */\nfunction appendToEvalState(state, input) {\n    const undoInput = state.input;\n    const undoVersion = state.version;\n    const undoOutput = state.output;\n    const undoLines = state.lines;\n    state.input += input;\n    state.lines += lineCount(input);\n    state.version++;\n    return function () {\n        state.input = undoInput;\n        state.output = undoOutput;\n        state.version = undoVersion;\n        state.lines = undoLines;\n    };\n}\n/**\n * Count the number of lines.\n */\nfunction lineCount(value) {\n    let count = 0;\n    for (const char of value) {\n        if (char === '\\n') {\n            count++;\n        }\n    }\n    return count;\n}\n/**\n * TS diagnostic codes which are recoverable, meaning that the user likely entered an incomplete line of code\n * and should be prompted for the next.  For example, starting a multi-line for() loop and not finishing it.\n * null value means code is always recoverable.  `Set` means code is only recoverable when occurring alongside at least one\n * of the other codes.\n */\nconst RECOVERY_CODES = new Map([\n    [1003, null],\n    [1005, null],\n    [1109, null],\n    [1126, null],\n    [\n        1136,\n        new Set([1005]), // happens when typing out an object literal or block scope across multiple lines: '{ foo: 123,'\n    ],\n    [1160, null],\n    [1161, null],\n    [2355, null],\n    [2391, null],\n    [\n        7010,\n        new Set([1005]), // happens when fn signature spread across multiple lines: 'function a(\\nb: any\\n) {'\n    ],\n]);\n/**\n * Diagnostic codes raised when using top-level await.\n * These are suppressed when top-level await is enabled.\n * When it is *not* enabled, these trigger a helpful hint about enabling top-level await.\n */\nconst topLevelAwaitDiagnosticCodes = [\n    1375,\n    1378,\n    1431,\n    1432, // Top-level 'for await' loops are only allowed when the 'module' option is set to 'esnext' or 'system', and the 'target' option is set to 'es2017' or higher.\n];\n/**\n * Check if a function can recover gracefully.\n */\nfunction isRecoverable(error) {\n    return error.diagnosticCodes.every((code) => {\n        const deps = RECOVERY_CODES.get(code);\n        return (deps === null ||\n            (deps && error.diagnosticCodes.some((code) => deps.has(code))));\n    });\n}\n/**\n * @internal\n * Set properties on `context` before eval-ing [stdin] or [eval] input.\n */\nfunction setupContext(context, module, filenameAndDirname) {\n    if (filenameAndDirname) {\n        context.__dirname = '.';\n        context.__filename = `[${filenameAndDirname}]`;\n    }\n    context.module = module;\n    context.exports = module.exports;\n    context.require = module.require.bind(module);\n}\nexports.setupContext = setupContext;\n//# sourceMappingURL=repl.js.map",
    "dist-raw/node-internal-modules-cjs-loader.js": "// Copied from several files in node's source code.\n// https://github.com/nodejs/node/blob/2d5d77306f6dff9110c1f77fefab25f973415770/lib/internal/modules/cjs/loader.js\n// Each function and variable below must have a comment linking to the source in node's github repo.\n\n'use strict';\n\nconst {\n  ArrayIsArray,\n  ArrayPrototypeIncludes,\n  ArrayPrototypeJoin,\n  ArrayPrototypePush,\n  JSONParse,\n  ObjectKeys,\n  RegExpPrototypeTest,\n  SafeMap,\n  SafeWeakMap,\n  StringPrototypeCharCodeAt,\n  StringPrototypeEndsWith,\n  StringPrototypeLastIndexOf,\n  StringPrototypeIndexOf,\n  StringPrototypeMatch,\n  StringPrototypeSlice,\n  StringPrototypeStartsWith,\n} = require('./node-primordials');\nconst { NativeModule } = require('./node-nativemodule');\nconst { pathToFileURL, fileURLToPath } = require('url');\nconst fs = require('fs');\nconst path = require('path');\nconst { sep } = path;\nconst { internalModuleStat } = require('./node-internalBinding-fs');\nconst packageJsonReader = require('./node-internal-modules-package_json_reader');\nconst {\n  cjsConditions,\n} = require('./node-internal-modules-cjs-helpers');\nconst { getOptionValue } = require('./node-options');\nconst preserveSymlinks = getOptionValue('--preserve-symlinks');\nconst preserveSymlinksMain = getOptionValue('--preserve-symlinks-main');\nconst {normalizeSlashes} = require('../dist/util');\nconst {createErrRequireEsm} = require('./node-internal-errors');\nconst {\n  codes: {\n    ERR_INVALID_MODULE_SPECIFIER,\n  },\n} = require('./node-internal-errors');\n\nconst {\n  CHAR_FORWARD_SLASH,\n} = require('./node-internal-constants');\n\nconst Module = require('module');\n\nconst isWindows = process.platform === 'win32';\n\nlet statCache = null;\n\nfunction stat(filename) {\n  filename = path.toNamespacedPath(filename);\n  if (statCache !== null) {\n    const result = statCache.get(filename);\n    if (result !== undefined) return result;\n  }\n  const result = internalModuleStat(filename);\n  if (statCache !== null && result >= 0) {\n    // Only set cache when `internalModuleStat(filename)` succeeds.\n    statCache.set(filename, result);\n  }\n  return result;\n}\n\n// Note:\n// we cannot get access to node's internal cache, which is populated from\n// within node's Module constructor.  So the cache here will always be empty.\n// It's possible we could approximate our own cache by building it up with\n// hacky workarounds, but it's not worth the complexity and flakiness.\nconst moduleParentCache = new SafeWeakMap();\n\n// Given a module name, and a list of paths to test, returns the first\n// matching file in the following precedence.\n//\n// require(\"a.<ext>\")\n//   -> a.<ext>\n//\n// require(\"a\")\n//   -> a\n//   -> a.<ext>\n//   -> a/index.<ext>\n\nconst packageJsonCache = new SafeMap();\n\nfunction readPackage(requestPath) {\n  const jsonPath = path.resolve(requestPath, 'package.json');\n\n  const existing = packageJsonCache.get(jsonPath);\n  if (existing !== undefined) return existing;\n\n  const result = packageJsonReader.read(jsonPath);\n  const json = result.containsKeys === false ? '{}' : result.string;\n  if (json === undefined) {\n    packageJsonCache.set(jsonPath, false);\n    return false;\n  }\n\n  try {\n    const parsed = JSONParse(json);\n    const filtered = {\n      name: parsed.name,\n      main: parsed.main,\n      exports: parsed.exports,\n      imports: parsed.imports,\n      type: parsed.type\n    };\n    packageJsonCache.set(jsonPath, filtered);\n    return filtered;\n  } catch (e) {\n    e.path = jsonPath;\n    e.message = 'Error parsing ' + jsonPath + ': ' + e.message;\n    throw e;\n  }\n}\n\nfunction readPackageScope(checkPath) {\n  const rootSeparatorIndex = StringPrototypeIndexOf(checkPath, sep);\n  let separatorIndex;\n  do {\n    separatorIndex = StringPrototypeLastIndexOf(checkPath, sep);\n    checkPath = StringPrototypeSlice(checkPath, 0, separatorIndex);\n    if (StringPrototypeEndsWith(checkPath, sep + 'node_modules'))\n      return false;\n    const pjson = readPackage(checkPath + sep);\n    if (pjson) return {\n      data: pjson,\n      path: checkPath,\n    };\n  } while (separatorIndex > rootSeparatorIndex);\n  return false;\n}\n\n/**\n * @param {{\n *   nodeEsmResolver: ReturnType<typeof import('./node-internal-modules-esm-resolve').createResolve>,\n *   extensions: import('../src/file-extensions').Extensions,\n *   preferTsExts\n * }} opts\n */\nfunction createCjsLoader(opts) {\nconst {nodeEsmResolver, preferTsExts} = opts;\nconst {replacementsForCjs, replacementsForJs, replacementsForMjs, replacementsForJsx} = opts.extensions;\nconst {\n  encodedSepRegEx,\n  packageExportsResolve,\n  packageImportsResolve\n} = nodeEsmResolver;\n\nfunction tryPackage(requestPath, exts, isMain, originalPath) {\n  // const pkg = readPackage(requestPath)?.main;\n  const tmp = readPackage(requestPath)\n  const pkg = tmp != null ? tmp.main : undefined;\n\n  if (!pkg) {\n    return tryExtensions(path.resolve(requestPath, 'index'), exts, isMain);\n  }\n\n  const filename = path.resolve(requestPath, pkg);\n  let actual = tryReplacementExtensions(filename, isMain) ||\n    tryFile(filename, isMain) ||\n    tryExtensions(filename, exts, isMain) ||\n    tryExtensions(path.resolve(filename, 'index'), exts, isMain);\n  if (actual === false) {\n    actual = tryExtensions(path.resolve(requestPath, 'index'), exts, isMain);\n    if (!actual) {\n      // eslint-disable-next-line no-restricted-syntax\n      const err = new Error(\n        `Cannot find module '${filename}'. ` +\n        'Please verify that the package.json has a valid \"main\" entry'\n      );\n      err.code = 'MODULE_NOT_FOUND';\n      err.path = path.resolve(requestPath, 'package.json');\n      err.requestPath = originalPath;\n      // TODO(BridgeAR): Add the requireStack as well.\n      throw err;\n    } else {\n      const jsonPath = path.resolve(requestPath, 'package.json');\n      process.emitWarning(\n        `Invalid 'main' field in '${jsonPath}' of '${pkg}'. ` +\n          'Please either fix that or report it to the module author',\n        'DeprecationWarning',\n        'DEP0128'\n      );\n    }\n  }\n  return actual;\n}\n\n// In order to minimize unnecessary lstat() calls,\n// this cache is a list of known-real paths.\n// Set to an empty Map to reset.\nconst realpathCache = new SafeMap();\n\n// Check if the file exists and is not a directory\n// if using --preserve-symlinks and isMain is false,\n// keep symlinks intact, otherwise resolve to the\n// absolute realpath.\nfunction tryFile(requestPath, isMain) {\n  const rc = stat(requestPath);\n  if (rc !== 0) return;\n  if (preserveSymlinks && !isMain) {\n    return path.resolve(requestPath);\n  }\n  return toRealPath(requestPath);\n}\n\nfunction toRealPath(requestPath) {\n  return fs.realpathSync(requestPath, {\n    // [internalFS.realpathCacheKey]: realpathCache\n  });\n}\n\nfunction statReplacementExtensions(p) {\n  const lastDotIndex = p.lastIndexOf('.');\n  if(lastDotIndex >= 0) {\n    const ext = p.slice(lastDotIndex);\n    if (ext === '.js' || ext === '.jsx' || ext === '.mjs' || ext === '.cjs') {\n      const pathnameWithoutExtension = p.slice(0, lastDotIndex);\n      const replacementExts =\n        ext === '.js' ? replacementsForJs\n        : ext === '.jsx' ? replacementsForJsx\n        : ext === '.mjs' ? replacementsForMjs\n        : replacementsForCjs;\n      for (let i = 0; i < replacementExts.length; i++) {\n        const filename = pathnameWithoutExtension + replacementExts[i];\n        const rc = stat(filename);\n        if (rc === 0) {\n          return [rc, filename];\n        }\n      }\n    }\n  }\n  return [stat(p), p];\n}\nfunction tryReplacementExtensions(p, isMain) {\n  const lastDotIndex = p.lastIndexOf('.');\n  if(lastDotIndex >= 0) {\n    const ext = p.slice(lastDotIndex);\n    if (ext === '.js' || ext === '.jsx' || ext === '.mjs' || ext === '.cjs') {\n      const pathnameWithoutExtension = p.slice(0, lastDotIndex);\n      const replacementExts =\n        ext === '.js' ? replacementsForJs\n        : ext === '.jsx' ? replacementsForJsx\n        : ext === '.mjs' ? replacementsForMjs\n        : replacementsForCjs;\n      for (let i = 0; i < replacementExts.length; i++) {\n        const filename = tryFile(pathnameWithoutExtension + replacementExts[i], isMain);\n        if (filename) {\n          return filename;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n// Given a path, check if the file exists with any of the set extensions\nfunction tryExtensions(p, exts, isMain) {\n  for (let i = 0; i < exts.length; i++) {\n    const filename = tryFile(p + exts[i], isMain);\n\n    if (filename) {\n      return filename;\n    }\n  }\n  return false;\n}\n\nfunction trySelfParentPath(parent) {\n  if (!parent) return false;\n\n  if (parent.filename) {\n    return parent.filename;\n  } else if (parent.id === '<repl>' || parent.id === 'internal/preload') {\n    try {\n      return process.cwd() + path.sep;\n    } catch {\n      return false;\n    }\n  }\n}\n\nfunction trySelf(parentPath, request) {\n  if (!parentPath) return false;\n\n  const { data: pkg, path: pkgPath } = readPackageScope(parentPath) || {};\n  if (!pkg || pkg.exports === undefined) return false;\n  if (typeof pkg.name !== 'string') return false;\n\n  let expansion;\n  if (request === pkg.name) {\n    expansion = '.';\n  } else if (StringPrototypeStartsWith(request, `${pkg.name}/`)) {\n    expansion = '.' + StringPrototypeSlice(request, pkg.name.length);\n  } else {\n    return false;\n  }\n\n  try {\n    return finalizeEsmResolution(packageExportsResolve(\n      pathToFileURL(pkgPath + '/package.json'), expansion, pkg,\n      pathToFileURL(parentPath), cjsConditions).resolved, parentPath, pkgPath);\n  } catch (e) {\n    if (e.code === 'ERR_MODULE_NOT_FOUND')\n      throw createEsmNotFoundErr(request, pkgPath + '/package.json');\n    throw e;\n  }\n}\n\n// This only applies to requests of a specific form:\n// 1. name/.*\n// 2. @scope/name/.*\nconst EXPORTS_PATTERN = /^((?:@[^/\\\\%]+\\/)?[^./\\\\%][^/\\\\%]*)(\\/.*)?$/;\nfunction resolveExports(nmPath, request) {\n  // The implementation's behavior is meant to mirror resolution in ESM.\n  const { 1: name, 2: expansion = '' } =\n    StringPrototypeMatch(request, EXPORTS_PATTERN) || [];\n  if (!name)\n    return;\n  const pkgPath = path.resolve(nmPath, name);\n  const pkg = readPackage(pkgPath);\n  // if (pkg?.exports != null) {\n  if (pkg != null && pkg.exports != null) {\n    try {\n      return finalizeEsmResolution(packageExportsResolve(\n        pathToFileURL(pkgPath + '/package.json'), '.' + expansion, pkg, null,\n        cjsConditions).resolved, null, pkgPath);\n    } catch (e) {\n      if (e.code === 'ERR_MODULE_NOT_FOUND')\n        throw createEsmNotFoundErr(request, pkgPath + '/package.json');\n      throw e;\n    }\n  }\n}\n\n// Backwards compat for old node versions\nconst hasModulePathCache = !!require('module')._pathCache;\nconst Module_pathCache = Object.create(null);\nconst Module_pathCache_get = hasModulePathCache ? (cacheKey) => Module._pathCache[cacheKey] : (cacheKey) => Module_pathCache[cacheKey];\nconst Module_pathCache_set = hasModulePathCache ? (cacheKey, value) => (Module._pathCache[cacheKey] = value) : (cacheKey) => (Module_pathCache[cacheKey] = value);\n\nconst trailingSlashRegex = /(?:^|\\/)\\.?\\.$/;\nconst Module_findPath = function _findPath(request, paths, isMain) {\n  const absoluteRequest = path.isAbsolute(request);\n  if (absoluteRequest) {\n    paths = [''];\n  } else if (!paths || paths.length === 0) {\n    return false;\n  }\n\n  const cacheKey = request + '\\x00' + ArrayPrototypeJoin(paths, '\\x00');\n  const entry = Module_pathCache_get(cacheKey);\n  if (entry)\n    return entry;\n\n  let exts;\n  let trailingSlash = request.length > 0 &&\n    StringPrototypeCharCodeAt(request, request.length - 1) ===\n    CHAR_FORWARD_SLASH;\n  if (!trailingSlash) {\n    trailingSlash = RegExpPrototypeTest(trailingSlashRegex, request);\n  }\n\n  // For each path\n  for (let i = 0; i < paths.length; i++) {\n    // Don't search further if path doesn't exist\n    const curPath = paths[i];\n    if (curPath && stat(curPath) < 1) continue;\n\n    if (!absoluteRequest) {\n      const exportsResolved = resolveExports(curPath, request);\n      if (exportsResolved)\n        return exportsResolved;\n    }\n\n    const _basePath = path.resolve(curPath, request);\n    let filename;\n\n    const [rc, basePath] = statReplacementExtensions(_basePath);\n    if (!trailingSlash) {\n      if (rc === 0) {  // File.\n        if (!isMain) {\n          if (preserveSymlinks) {\n            filename = path.resolve(basePath);\n          } else {\n            filename = toRealPath(basePath);\n          }\n        } else if (preserveSymlinksMain) {\n          // For the main module, we use the preserveSymlinksMain flag instead\n          // mainly for backward compatibility, as the preserveSymlinks flag\n          // historically has not applied to the main module.  Most likely this\n          // was intended to keep .bin/ binaries working, as following those\n          // symlinks is usually required for the imports in the corresponding\n          // files to resolve; that said, in some use cases following symlinks\n          // causes bigger problems which is why the preserveSymlinksMain option\n          // is needed.\n          filename = path.resolve(basePath);\n        } else {\n          filename = toRealPath(basePath);\n        }\n      }\n\n      if (!filename) {\n        // Try it with each of the extensions\n        if (exts === undefined)\n          exts = ObjectKeys(Module._extensions);\n        filename = tryExtensions(basePath, exts, isMain);\n      }\n    }\n\n    if (!filename && rc === 1) {  // Directory.\n      // try it with each of the extensions at \"index\"\n      if (exts === undefined)\n        exts = ObjectKeys(Module._extensions);\n      filename = tryPackage(basePath, exts, isMain, request);\n    }\n\n    if (filename) {\n      Module_pathCache_set(cacheKey, filename);\n      return filename;\n    }\n  }\n\n  return false;\n};\n\nconst Module_resolveFilename = function _resolveFilename(request, parent, isMain, options) {\n  if (StringPrototypeStartsWith(request, 'node:') ||\n      NativeModule.canBeRequiredByUsers(request)) {\n    return request;\n  }\n\n  let paths;\n\n  if (typeof options === 'object' && options !== null) {\n    if (ArrayIsArray(options.paths)) {\n      const isRelative = StringPrototypeStartsWith(request, './') ||\n          StringPrototypeStartsWith(request, '../') ||\n          ((isWindows && StringPrototypeStartsWith(request, '.\\\\')) ||\n          StringPrototypeStartsWith(request, '..\\\\'));\n\n      if (isRelative) {\n        paths = options.paths;\n      } else {\n        const fakeParent = new Module('', null);\n\n        paths = [];\n\n        for (let i = 0; i < options.paths.length; i++) {\n          const path = options.paths[i];\n          fakeParent.paths = Module._nodeModulePaths(path);\n          const lookupPaths = Module._resolveLookupPaths(request, fakeParent);\n\n          for (let j = 0; j < lookupPaths.length; j++) {\n            if (!ArrayPrototypeIncludes(paths, lookupPaths[j]))\n              ArrayPrototypePush(paths, lookupPaths[j]);\n          }\n        }\n      }\n    } else if (options.paths === undefined) {\n      paths = Module._resolveLookupPaths(request, parent);\n    } else {\n      throw new ERR_INVALID_ARG_VALUE('options.paths', options.paths);\n    }\n  } else {\n    paths = Module._resolveLookupPaths(request, parent);\n  }\n\n  // if (parent?.filename) {\n  // node 12 hack\n  if (parent != null && parent.filename) {\n    if (request[0] === '#') {\n      const pkg = readPackageScope(parent.filename) || {};\n\n      // if (pkg.data?.imports != null) {\n      // node 12 hack\n      if (pkg.data != null && pkg.data.imports != null) {\n        try {\n          return finalizeEsmResolution(\n            packageImportsResolve(request, pathToFileURL(parent.filename),\n                                  cjsConditions), parent.filename,\n            pkg.path);\n        } catch (e) {\n          if (e.code === 'ERR_MODULE_NOT_FOUND')\n            throw createEsmNotFoundErr(request);\n          throw e;\n        }\n      }\n    }\n  }\n\n  // Try module self resolution first\n  const parentPath = trySelfParentPath(parent);\n  const selfResolved = trySelf(parentPath, request);\n  if (selfResolved) {\n    const cacheKey = request + '\\x00' +\n         (paths.length === 1 ? paths[0] : ArrayPrototypeJoin(paths, '\\x00'));\n    Module._pathCache[cacheKey] = selfResolved;\n    return selfResolved;\n  }\n\n  // Look up the filename first, since that's the cache key.\n  const filename = Module._findPath(request, paths, isMain, false);\n  if (filename) return filename;\n  const requireStack = [];\n  for (let cursor = parent;\n    cursor;\n    cursor = moduleParentCache.get(cursor)) {\n    ArrayPrototypePush(requireStack, cursor.filename || cursor.id);\n  }\n  let message = `Cannot find module '${request}'`;\n  if (requireStack.length > 0) {\n    message = message + '\\nRequire stack:\\n- ' +\n              ArrayPrototypeJoin(requireStack, '\\n- ');\n  }\n  // eslint-disable-next-line no-restricted-syntax\n  const err = new Error(message);\n  err.code = 'MODULE_NOT_FOUND';\n  err.requireStack = requireStack;\n  throw err;\n};\n\nfunction finalizeEsmResolution(resolved, parentPath, pkgPath) {\n  if (RegExpPrototypeTest(encodedSepRegEx, resolved))\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      resolved, 'must not include encoded \"/\" or \"\\\\\" characters', parentPath);\n  const filename = fileURLToPath(resolved);\n  const actual = tryReplacementExtensions(filename) || tryFile(filename);\n  if (actual)\n    return actual;\n  const err = createEsmNotFoundErr(filename,\n                                   path.resolve(pkgPath, 'package.json'));\n  throw err;\n}\n\nfunction createEsmNotFoundErr(request, path) {\n  // eslint-disable-next-line no-restricted-syntax\n  const err = new Error(`Cannot find module '${request}'`);\n  err.code = 'MODULE_NOT_FOUND';\n  if (path)\n    err.path = path;\n  // TODO(BridgeAR): Add the requireStack as well.\n  return err;\n}\n\n\nreturn {\n  Module_findPath,\n  Module_resolveFilename\n}\n\n}\n\n/**\n * copied from Module._extensions['.js']\n * https://github.com/nodejs/node/blob/v15.3.0/lib/internal/modules/cjs/loader.js#L1113-L1120\n * @param {import('../src/index').Service} service\n * @param {NodeJS.Module} module\n * @param {string} filename\n */\nfunction assertScriptCanLoadAsCJSImpl(service, module, filename) {\n  const pkg = readPackageScope(filename);\n\n  // ts-node modification: allow our configuration to override\n  const tsNodeClassification = service.moduleTypeClassifier.classifyModuleByModuleTypeOverrides(normalizeSlashes(filename));\n  if(tsNodeClassification.moduleType === 'cjs') return;\n\n  // ignore package.json when file extension is ESM-only or CJS-only\n  // [MUST_UPDATE_FOR_NEW_FILE_EXTENSIONS]\n  const lastDotIndex = filename.lastIndexOf('.');\n  const ext = lastDotIndex >= 0 ? filename.slice(lastDotIndex) : '';\n\n  if((ext === '.cts' || ext === '.cjs') && tsNodeClassification.moduleType === 'auto') return;\n\n  // Function require shouldn't be used in ES modules.\n  if (ext === '.mts' || ext === '.mjs' || tsNodeClassification.moduleType === 'esm' || (pkg && pkg.data && pkg.data.type === 'module')) {\n    const parentPath = module.parent && module.parent.filename;\n    const packageJsonPath = pkg ? path.resolve(pkg.path, 'package.json') : null;\n    throw createErrRequireEsm(filename, parentPath, packageJsonPath);\n  }\n}\n\n\nmodule.exports = {\n  createCjsLoader,\n  assertScriptCanLoadAsCJSImpl,\n  readPackageScope\n};\n",
    "dist-raw/node-internal-modules-esm-resolve.js": "// Copied from https://raw.githubusercontent.com/nodejs/node/v15.3.0/lib/internal/modules/esm/resolve.js\n\n'use strict';\n\nconst {versionGteLt} = require('../dist/util');\n\n// Test for node >14.13.1 || (>=12.20.0 && <13)\nconst builtinModuleProtocol =\n  versionGteLt(process.versions.node, '14.13.1') ||\n  versionGteLt(process.versions.node, '12.20.0', '13.0.0')\n    ? 'node:'\n    : 'nodejs:';\n\nconst {\n  ArrayIsArray,\n  ArrayPrototypeJoin,\n  ArrayPrototypeShift,\n  JSONParse,\n  JSONStringify,\n  ObjectFreeze,\n  ObjectGetOwnPropertyNames,\n  ObjectPrototypeHasOwnProperty,\n  RegExpPrototypeTest,\n  SafeMap,\n  SafeSet,\n  StringPrototypeEndsWith,\n  StringPrototypeIndexOf,\n  StringPrototypeLastIndexOf,\n  StringPrototypeReplace,\n  StringPrototypeSlice,\n  StringPrototypeSplit,\n  StringPrototypeStartsWith,\n  StringPrototypeSubstr,\n} = require('./node-primordials');\n\n// const internalFS = require('internal/fs/utils');\nconst Module = require('module');\nconst { NativeModule } = require('./node-nativemodule');\nconst {\n  realpathSync,\n  statSync,\n  Stats,\n} = require('fs');\n// const { getOptionValue } = require('internal/options');\nconst { getOptionValue } = require('./node-options');\n// // Do not eagerly grab .manifest, it may be in TDZ\n// const policy = getOptionValue('--experimental-policy') ?\n//   require('internal/process/policy') :\n//   null;\n// disabled for now.  I am not sure if/how we should support this\nconst policy = null;\nconst { sep, relative } = require('path');\nconst preserveSymlinks = getOptionValue('--preserve-symlinks');\nconst preserveSymlinksMain = getOptionValue('--preserve-symlinks-main');\nconst typeFlag = getOptionValue('--input-type');\n// const { URL, pathToFileURL, fileURLToPath } = require('internal/url');\nconst { URL, pathToFileURL, fileURLToPath } = require('url');\nconst {\n  ERR_INPUT_TYPE_NOT_ALLOWED,\n  ERR_INVALID_ARG_VALUE,\n  ERR_INVALID_MODULE_SPECIFIER,\n  ERR_INVALID_PACKAGE_CONFIG,\n  ERR_INVALID_PACKAGE_TARGET,\n  ERR_MANIFEST_DEPENDENCY_MISSING,\n  ERR_MODULE_NOT_FOUND,\n  ERR_PACKAGE_IMPORT_NOT_DEFINED,\n  ERR_PACKAGE_PATH_NOT_EXPORTED,\n  ERR_UNSUPPORTED_DIR_IMPORT,\n  ERR_UNSUPPORTED_ESM_URL_SCHEME,\n// } = require('internal/errors').codes;\n} = require('./node-internal-errors').codes;\n\n// const { Module: CJSModule } = require('internal/modules/cjs/loader');\nconst CJSModule = Module;\n\n// const packageJsonReader = require('internal/modules/package_json_reader');\nconst packageJsonReader = require('./node-internal-modules-package_json_reader');\nconst userConditions = getOptionValue('--conditions');\nconst DEFAULT_CONDITIONS = ObjectFreeze(['node', 'import', ...userConditions]);\nconst DEFAULT_CONDITIONS_SET = new SafeSet(DEFAULT_CONDITIONS);\n\nconst pendingDeprecation = getOptionValue('--pending-deprecation');\n\n/**\n * @param {{\n *  extensions: import('../src/file-extensions').Extensions,\n *  preferTsExts: boolean | undefined;\n *  tsNodeExperimentalSpecifierResolution: import('../src/index').ExperimentalSpecifierResolution | undefined;\n * }} opts\n */\nfunction createResolve(opts) {\n// TODO receive cached fs implementations here\nconst {preferTsExts, tsNodeExperimentalSpecifierResolution, extensions} = opts;\nconst esrnExtensions = extensions.experimentalSpecifierResolutionAddsIfOmitted;\nconst {legacyMainResolveAddsIfOmitted, replacementsForCjs, replacementsForJs, replacementsForMjs, replacementsForJsx} = extensions;\n// const experimentalSpecifierResolution = tsNodeExperimentalSpecifierResolution ?? getOptionValue('--experimental-specifier-resolution');\nconst experimentalSpecifierResolution = tsNodeExperimentalSpecifierResolution != null ? tsNodeExperimentalSpecifierResolution : getOptionValue('--experimental-specifier-resolution');\n\nconst emittedPackageWarnings = new SafeSet();\nfunction emitFolderMapDeprecation(match, pjsonUrl, isExports, base) {\n  const pjsonPath = fileURLToPath(pjsonUrl);\n  if (!pendingDeprecation) {\n    const nodeModulesIndex = StringPrototypeLastIndexOf(pjsonPath,\n                                                        '/node_modules/');\n    if (nodeModulesIndex !== -1) {\n      const afterNodeModulesPath = StringPrototypeSlice(pjsonPath,\n                                                        nodeModulesIndex + 14,\n                                                        -13);\n      try {\n        const { packageSubpath } = parsePackageName(afterNodeModulesPath);\n        if (packageSubpath === '.')\n          return;\n      } catch {}\n    }\n  }\n  if (emittedPackageWarnings.has(pjsonPath + '|' + match))\n    return;\n  emittedPackageWarnings.add(pjsonPath + '|' + match);\n  process.emitWarning(\n    `Use of deprecated folder mapping \"${match}\" in the ${isExports ?\n      '\"exports\"' : '\"imports\"'} field module resolution of the package at ${\n      pjsonPath}${base ? ` imported from ${fileURLToPath(base)}` : ''}.\\n` +\n      `Update this package.json to use a subpath pattern like \"${match}*\".`,\n    'DeprecationWarning',\n    'DEP0148'\n  );\n}\n\nfunction getConditionsSet(conditions) {\n  if (conditions !== undefined && conditions !== DEFAULT_CONDITIONS) {\n    if (!ArrayIsArray(conditions)) {\n      throw new ERR_INVALID_ARG_VALUE('conditions', conditions,\n                                      'expected an array');\n    }\n    return new SafeSet(conditions);\n  }\n  return DEFAULT_CONDITIONS_SET;\n}\n\nconst realpathCache = new SafeMap();\nconst packageJSONCache = new SafeMap();  /* string -> PackageConfig */\n\nconst statSupportsThrowIfNoEntry = versionGteLt(process.versions.node, '15.3.0') ||\n  versionGteLt(process.versions.node, '14.17.0', '15.0.0');\nconst tryStatSync = statSupportsThrowIfNoEntry ? tryStatSyncWithoutErrors : tryStatSyncWithErrors;\nconst statsIfNotFound = new Stats();\nfunction tryStatSyncWithoutErrors(path) {\n  const stats = statSync(path, { throwIfNoEntry: false });\n  if(stats != null) return stats;\n  return statsIfNotFound;\n}\nfunction tryStatSyncWithErrors(path) {\n  try {\n    return statSync(path);\n  } catch {\n    return statsIfNotFound;\n  }\n}\n\nfunction getPackageConfig(path, specifier, base) {\n  const existing = packageJSONCache.get(path);\n  if (existing !== undefined) {\n    return existing;\n  }\n  const source = packageJsonReader.read(path).string;\n  if (source === undefined) {\n    const packageConfig = {\n      pjsonPath: path,\n      exists: false,\n      main: undefined,\n      name: undefined,\n      type: 'none',\n      exports: undefined,\n      imports: undefined,\n    };\n    packageJSONCache.set(path, packageConfig);\n    return packageConfig;\n  }\n\n  let packageJSON;\n  try {\n    packageJSON = JSONParse(source);\n  } catch (error) {\n    throw new ERR_INVALID_PACKAGE_CONFIG(\n      path,\n      (base ? `\"${specifier}\" from ` : '') + fileURLToPath(base || specifier),\n      error.message\n    );\n  }\n\n  let { imports, main, name, type } = packageJSON;\n  const { exports } = packageJSON;\n  if (typeof imports !== 'object' || imports === null) imports = undefined;\n  if (typeof main !== 'string') main = undefined;\n  if (typeof name !== 'string') name = undefined;\n  // Ignore unknown types for forwards compatibility\n  if (type !== 'module' && type !== 'commonjs') type = 'none';\n\n  const packageConfig = {\n    pjsonPath: path,\n    exists: true,\n    main,\n    name,\n    type,\n    exports,\n    imports,\n  };\n  packageJSONCache.set(path, packageConfig);\n  return packageConfig;\n}\n\nfunction getPackageScopeConfig(resolved) {\n  let packageJSONUrl = new URL('./package.json', resolved);\n  while (true) {\n    const packageJSONPath = packageJSONUrl.pathname;\n    if (StringPrototypeEndsWith(packageJSONPath, 'node_modules/package.json'))\n      break;\n    const packageConfig = getPackageConfig(fileURLToPath(packageJSONUrl),\n                                           resolved);\n    if (packageConfig.exists) return packageConfig;\n\n    const lastPackageJSONUrl = packageJSONUrl;\n    packageJSONUrl = new URL('../package.json', packageJSONUrl);\n\n    // Terminates at root where ../package.json equals ../../package.json\n    // (can't just check \"/package.json\" for Windows support).\n    if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) break;\n  }\n  const packageJSONPath = fileURLToPath(packageJSONUrl);\n  const packageConfig = {\n    pjsonPath: packageJSONPath,\n    exists: false,\n    main: undefined,\n    name: undefined,\n    type: 'none',\n    exports: undefined,\n    imports: undefined,\n  };\n  packageJSONCache.set(packageJSONPath, packageConfig);\n  return packageConfig;\n}\n\n/*\n * Legacy CommonJS main resolution:\n * 1. let M = pkg_url + (json main field)\n * 2. TRY(M, M.js, M.json, M.node)\n * 3. TRY(M/index.js, M/index.json, M/index.node)\n * 4. TRY(pkg_url/index.js, pkg_url/index.json, pkg_url/index.node)\n * 5. NOT_FOUND\n */\nfunction fileExists(url) {\n  return tryStatSync(fileURLToPath(url)).isFile();\n}\n\nfunction legacyMainResolve(packageJSONUrl, packageConfig, base) {\n  let guess;\n  if (packageConfig.main !== undefined) {\n    // Note: fs check redundances will be handled by Descriptor cache here.\n    if(guess = resolveReplacementExtensions(new URL(`./${packageConfig.main}`, packageJSONUrl))) {\n      return guess;\n    }\n    if (fileExists(guess = new URL(`./${packageConfig.main}`,\n                                   packageJSONUrl))) {\n      return guess;\n    }\n    for(const extension of legacyMainResolveAddsIfOmitted) {\n      if (fileExists(guess = new URL(`./${packageConfig.main}${extension}`,\n                                    packageJSONUrl))) {\n        return guess;\n      }\n    }\n    for(const extension of legacyMainResolveAddsIfOmitted) {\n      if (fileExists(guess = new URL(`./${packageConfig.main}/index${extension}`,\n                                    packageJSONUrl))) {\n        return guess;\n      }\n    }\n    // Fallthrough.\n  }\n  for(const extension of legacyMainResolveAddsIfOmitted) {\n    if (fileExists(guess = new URL(`./index${extension}`, packageJSONUrl))) {\n      return guess;\n    }\n  }\n  // Not found.\n  throw new ERR_MODULE_NOT_FOUND(\n    fileURLToPath(new URL('.', packageJSONUrl)), fileURLToPath(base));\n}\n\n/** attempts replacement extensions, then tries exact name, then attempts appending extensions */\nfunction resolveExtensionsWithTryExactName(search) {\n  const resolvedReplacementExtension = resolveReplacementExtensions(search);\n  if(resolvedReplacementExtension) return resolvedReplacementExtension;\n  if (fileExists(search)) return search;\n  return resolveExtensions(search);\n}\n\n// This appends missing extensions\nfunction resolveExtensions(search) {\n  for (let i = 0; i < esrnExtensions.length; i++) {\n    const extension = esrnExtensions[i];\n    const guess = new URL(`${search.pathname}${extension}`, search);\n    if (fileExists(guess)) return guess;\n  }\n  return undefined;\n}\n\n/** This replaces JS with TS extensions */\nfunction resolveReplacementExtensions(search) {\n  const lastDotIndex = search.pathname.lastIndexOf('.');\n  if(lastDotIndex >= 0) {\n    const ext = search.pathname.slice(lastDotIndex);\n    if (ext === '.js' || ext === '.jsx' || ext === '.mjs' || ext === '.cjs') {\n      const pathnameWithoutExtension = search.pathname.slice(0, lastDotIndex);\n      const replacementExts =\n        ext === '.js' ? replacementsForJs\n        : ext === '.jsx' ? replacementsForJsx\n        : ext === '.mjs' ? replacementsForMjs\n        : replacementsForCjs;\n      const guess = new URL(search.toString());\n      for (let i = 0; i < replacementExts.length; i++) {\n        const extension = replacementExts[i];\n        guess.pathname = `${pathnameWithoutExtension}${extension}`;\n        if (fileExists(guess)) return guess;\n      }\n    }\n  }\n  return undefined;\n}\n\nfunction resolveIndex(search) {\n  return resolveExtensions(new URL('index', search));\n}\n\nconst encodedSepRegEx = /%2F|%2C/i;\nfunction finalizeResolution(resolved, base) {\n  if (RegExpPrototypeTest(encodedSepRegEx, resolved.pathname))\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      resolved.pathname, 'must not include encoded \"/\" or \"\\\\\" characters',\n      fileURLToPath(base));\n\n  if (experimentalSpecifierResolution === 'node') {\n    const path = fileURLToPath(resolved);\n    let file = resolveExtensionsWithTryExactName(resolved);\n    if (file !== undefined) return file;\n    if (!StringPrototypeEndsWith(path, '/')) {\n      file = resolveIndex(new URL(`${resolved}/`));\n      if (file !== undefined) return file;\n    } else {\n      return resolveIndex(resolved) || resolved;\n    }\n    throw new ERR_MODULE_NOT_FOUND(\n      resolved.pathname, fileURLToPath(base), 'module');\n  }\n\n  const file = resolveReplacementExtensions(resolved) || resolved;\n  const path = fileURLToPath(file);\n\n  const stats = tryStatSync(StringPrototypeEndsWith(path, '/') ?\n    StringPrototypeSlice(path, -1) : path);\n  if (stats.isDirectory()) {\n    const err = new ERR_UNSUPPORTED_DIR_IMPORT(path, fileURLToPath(base));\n    err.url = String(resolved);\n    throw err;\n  } else if (!stats.isFile()) {\n    throw new ERR_MODULE_NOT_FOUND(\n      path || resolved.pathname, fileURLToPath(base), 'module');\n  }\n\n  return file;\n}\n\nfunction throwImportNotDefined(specifier, packageJSONUrl, base) {\n  throw new ERR_PACKAGE_IMPORT_NOT_DEFINED(\n    specifier, packageJSONUrl && fileURLToPath(new URL('.', packageJSONUrl)),\n    fileURLToPath(base));\n}\n\nfunction throwExportsNotFound(subpath, packageJSONUrl, base) {\n  throw new ERR_PACKAGE_PATH_NOT_EXPORTED(\n    fileURLToPath(new URL('.', packageJSONUrl)), subpath,\n    base && fileURLToPath(base));\n}\n\nfunction throwInvalidSubpath(subpath, packageJSONUrl, internal, base) {\n  const reason = `request is not a valid subpath for the \"${internal ?\n    'imports' : 'exports'}\" resolution of ${fileURLToPath(packageJSONUrl)}`;\n  throw new ERR_INVALID_MODULE_SPECIFIER(subpath, reason,\n                                         base && fileURLToPath(base));\n}\n\nfunction throwInvalidPackageTarget(\n  subpath, target, packageJSONUrl, internal, base) {\n  if (typeof target === 'object' && target !== null) {\n    target = JSONStringify(target, null, '');\n  } else {\n    target = `${target}`;\n  }\n  throw new ERR_INVALID_PACKAGE_TARGET(\n    fileURLToPath(new URL('.', packageJSONUrl)), subpath, target,\n    internal, base && fileURLToPath(base));\n}\n\nconst invalidSegmentRegEx = /(^|\\\\|\\/)(\\.\\.?|node_modules)(\\\\|\\/|$)/;\nconst patternRegEx = /\\*/g;\n\nfunction resolvePackageTargetString(\n  target, subpath, match, packageJSONUrl, base, pattern, internal, conditions) {\n  if (subpath !== '' && !pattern && target[target.length - 1] !== '/')\n    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);\n\n  if (!StringPrototypeStartsWith(target, './')) {\n    if (internal && !StringPrototypeStartsWith(target, '../') &&\n        !StringPrototypeStartsWith(target, '/')) {\n      let isURL = false;\n      try {\n        new URL(target);\n        isURL = true;\n      } catch {}\n      if (!isURL) {\n        const exportTarget = pattern ?\n          StringPrototypeReplace(target, patternRegEx, subpath) :\n          target + subpath;\n        return packageResolve(exportTarget, packageJSONUrl, conditions);\n      }\n    }\n    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);\n  }\n\n  if (RegExpPrototypeTest(invalidSegmentRegEx, StringPrototypeSlice(target, 2)))\n    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);\n\n  const resolved = new URL(target, packageJSONUrl);\n  const resolvedPath = resolved.pathname;\n  const packagePath = new URL('.', packageJSONUrl).pathname;\n\n  if (!StringPrototypeStartsWith(resolvedPath, packagePath))\n    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);\n\n  if (subpath === '') return resolved;\n\n  if (RegExpPrototypeTest(invalidSegmentRegEx, subpath))\n    throwInvalidSubpath(match + subpath, packageJSONUrl, internal, base);\n\n  if (pattern)\n    return new URL(StringPrototypeReplace(resolved.href, patternRegEx,\n                                          subpath));\n  return new URL(subpath, resolved);\n}\n\n/**\n * @param {string} key\n * @returns {boolean}\n */\nfunction isArrayIndex(key) {\n  const keyNum = +key;\n  if (`${keyNum}` !== key) return false;\n  return keyNum >= 0 && keyNum < 0xFFFF_FFFF;\n}\n\nfunction resolvePackageTarget(packageJSONUrl, target, subpath, packageSubpath,\n                              base, pattern, internal, conditions) {\n  if (typeof target === 'string') {\n    return resolvePackageTargetString(\n      target, subpath, packageSubpath, packageJSONUrl, base, pattern, internal,\n      conditions);\n  } else if (ArrayIsArray(target)) {\n    if (target.length === 0)\n      return null;\n\n    let lastException;\n    for (let i = 0; i < target.length; i++) {\n      const targetItem = target[i];\n      let resolved;\n      try {\n        resolved = resolvePackageTarget(\n          packageJSONUrl, targetItem, subpath, packageSubpath, base, pattern,\n          internal, conditions);\n      } catch (e) {\n        lastException = e;\n        if (e.code === 'ERR_INVALID_PACKAGE_TARGET')\n          continue;\n        throw e;\n      }\n      if (resolved === undefined)\n        continue;\n      if (resolved === null) {\n        lastException = null;\n        continue;\n      }\n      return resolved;\n    }\n    if (lastException === undefined || lastException === null)\n      return lastException;\n    throw lastException;\n  } else if (typeof target === 'object' && target !== null) {\n    const keys = ObjectGetOwnPropertyNames(target);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (isArrayIndex(key)) {\n        throw new ERR_INVALID_PACKAGE_CONFIG(\n          fileURLToPath(packageJSONUrl), base,\n          '\"exports\" cannot contain numeric property keys.');\n      }\n    }\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (key === 'default' || conditions.has(key)) {\n        const conditionalTarget = target[key];\n        const resolved = resolvePackageTarget(\n          packageJSONUrl, conditionalTarget, subpath, packageSubpath, base,\n          pattern, internal, conditions);\n        if (resolved === undefined)\n          continue;\n        return resolved;\n      }\n    }\n    return undefined;\n  } else if (target === null) {\n    return null;\n  }\n  throwInvalidPackageTarget(packageSubpath, target, packageJSONUrl, internal,\n                            base);\n}\n\nfunction isConditionalExportsMainSugar(exports, packageJSONUrl, base) {\n  if (typeof exports === 'string' || ArrayIsArray(exports)) return true;\n  if (typeof exports !== 'object' || exports === null) return false;\n\n  const keys = ObjectGetOwnPropertyNames(exports);\n  let isConditionalSugar = false;\n  let i = 0;\n  for (let j = 0; j < keys.length; j++) {\n    const key = keys[j];\n    const curIsConditionalSugar = key === '' || key[0] !== '.';\n    if (i++ === 0) {\n      isConditionalSugar = curIsConditionalSugar;\n    } else if (isConditionalSugar !== curIsConditionalSugar) {\n      throw new ERR_INVALID_PACKAGE_CONFIG(\n        fileURLToPath(packageJSONUrl), base,\n        '\"exports\" cannot contain some keys starting with \\'.\\' and some not.' +\n        ' The exports object must either be an object of package subpath keys' +\n        ' or an object of main entry condition name keys only.');\n    }\n  }\n  return isConditionalSugar;\n}\n\n/**\n * @param {URL} packageJSONUrl\n * @param {string} packageSubpath\n * @param {object} packageConfig\n * @param {string} base\n * @param {Set<string>} conditions\n * @returns {{resolved: URL, exact: boolean}}\n */\nfunction packageExportsResolve(\n  packageJSONUrl, packageSubpath, packageConfig, base, conditions) {\n  let exports = packageConfig.exports;\n  if (isConditionalExportsMainSugar(exports, packageJSONUrl, base))\n    exports = { '.': exports };\n\n  if (ObjectPrototypeHasOwnProperty(exports, packageSubpath)) {\n    const target = exports[packageSubpath];\n    const resolved = resolvePackageTarget(\n      packageJSONUrl, target, '', packageSubpath, base, false, false, conditions\n    );\n    if (resolved === null || resolved === undefined)\n      throwExportsNotFound(packageSubpath, packageJSONUrl, base);\n    return { resolved, exact: true };\n  }\n\n  let bestMatch = '';\n  const keys = ObjectGetOwnPropertyNames(exports);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if (key[key.length - 1] === '*' &&\n        StringPrototypeStartsWith(packageSubpath,\n                                  StringPrototypeSlice(key, 0, -1)) &&\n        packageSubpath.length >= key.length &&\n        key.length > bestMatch.length) {\n      bestMatch = key;\n    } else if (key[key.length - 1] === '/' &&\n      StringPrototypeStartsWith(packageSubpath, key) &&\n      key.length > bestMatch.length) {\n      bestMatch = key;\n    }\n  }\n\n  if (bestMatch) {\n    const target = exports[bestMatch];\n    const pattern = bestMatch[bestMatch.length - 1] === '*';\n    const subpath = StringPrototypeSubstr(packageSubpath, bestMatch.length -\n      (pattern ? 1 : 0));\n    const resolved = resolvePackageTarget(packageJSONUrl, target, subpath,\n                                          bestMatch, base, pattern, false,\n                                          conditions);\n    if (resolved === null || resolved === undefined)\n      throwExportsNotFound(packageSubpath, packageJSONUrl, base);\n    if (!pattern)\n      emitFolderMapDeprecation(bestMatch, packageJSONUrl, true, base);\n    return { resolved, exact: pattern };\n  }\n\n  throwExportsNotFound(packageSubpath, packageJSONUrl, base);\n}\n\nfunction packageImportsResolve(name, base, conditions) {\n  if (name === '#' || StringPrototypeStartsWith(name, '#/')) {\n    const reason = 'is not a valid internal imports specifier name';\n    throw new ERR_INVALID_MODULE_SPECIFIER(name, reason, fileURLToPath(base));\n  }\n  let packageJSONUrl;\n  const packageConfig = getPackageScopeConfig(base);\n  if (packageConfig.exists) {\n    packageJSONUrl = pathToFileURL(packageConfig.pjsonPath);\n    const imports = packageConfig.imports;\n    if (imports) {\n      if (ObjectPrototypeHasOwnProperty(imports, name)) {\n        const resolved = resolvePackageTarget(\n          packageJSONUrl, imports[name], '', name, base, false, true, conditions\n        );\n        if (resolved !== null)\n          return { resolved, exact: true };\n      } else {\n        let bestMatch = '';\n        const keys = ObjectGetOwnPropertyNames(imports);\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i];\n          if (key[key.length - 1] === '*' &&\n              StringPrototypeStartsWith(name,\n                                        StringPrototypeSlice(key, 0, -1)) &&\n              name.length >= key.length &&\n              key.length > bestMatch.length) {\n            bestMatch = key;\n          } else if (key[key.length - 1] === '/' &&\n            StringPrototypeStartsWith(name, key) &&\n            key.length > bestMatch.length) {\n            bestMatch = key;\n          }\n        }\n\n        if (bestMatch) {\n          const target = imports[bestMatch];\n          const pattern = bestMatch[bestMatch.length - 1] === '*';\n          const subpath = StringPrototypeSubstr(name, bestMatch.length -\n            (pattern ? 1 : 0));\n          const resolved = resolvePackageTarget(\n            packageJSONUrl, target, subpath, bestMatch, base, pattern, true,\n            conditions);\n          if (resolved !== null) {\n            if (!pattern)\n              emitFolderMapDeprecation(bestMatch, packageJSONUrl, false, base);\n            return { resolved, exact: pattern };\n          }\n        }\n      }\n    }\n  }\n  throwImportNotDefined(name, packageJSONUrl, base);\n}\n\nfunction getPackageType(url) {\n  const packageConfig = getPackageScopeConfig(url);\n  return packageConfig.type;\n}\n\nfunction parsePackageName(specifier, base) {\n  let separatorIndex = StringPrototypeIndexOf(specifier, '/');\n  let validPackageName = true;\n  let isScoped = false;\n  if (specifier[0] === '@') {\n    isScoped = true;\n    if (separatorIndex === -1 || specifier.length === 0) {\n      validPackageName = false;\n    } else {\n      separatorIndex = StringPrototypeIndexOf(\n        specifier, '/', separatorIndex + 1);\n    }\n  }\n\n  const packageName = separatorIndex === -1 ?\n    specifier : StringPrototypeSlice(specifier, 0, separatorIndex);\n\n  // Package name cannot have leading . and cannot have percent-encoding or\n  // separators.\n  for (let i = 0; i < packageName.length; i++) {\n    if (packageName[i] === '%' || packageName[i] === '\\\\') {\n      validPackageName = false;\n      break;\n    }\n  }\n\n  if (!validPackageName) {\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      specifier, 'is not a valid package name', fileURLToPath(base));\n  }\n\n  const packageSubpath = '.' + (separatorIndex === -1 ? '' :\n    StringPrototypeSlice(specifier, separatorIndex));\n\n  return { packageName, packageSubpath, isScoped };\n}\n\n/**\n * @param {string} specifier\n * @param {URL} base\n * @param {Set<string>} conditions\n * @returns {URL}\n */\nfunction packageResolve(specifier, base, conditions) {\n  const { packageName, packageSubpath, isScoped } =\n    parsePackageName(specifier, base);\n\n  // ResolveSelf\n  const packageConfig = getPackageScopeConfig(base);\n  if (packageConfig.exists) {\n    const packageJSONUrl = pathToFileURL(packageConfig.pjsonPath);\n    if (packageConfig.name === packageName &&\n        packageConfig.exports !== undefined && packageConfig.exports !== null) {\n      return packageExportsResolve(\n        packageJSONUrl, packageSubpath, packageConfig, base, conditions\n      ).resolved;\n    }\n  }\n\n  let packageJSONUrl =\n    new URL('./node_modules/' + packageName + '/package.json', base);\n  let packageJSONPath = fileURLToPath(packageJSONUrl);\n  let lastPath;\n  do {\n    const stat = tryStatSync(StringPrototypeSlice(packageJSONPath, 0,\n                                                  packageJSONPath.length - 13));\n    if (!stat.isDirectory()) {\n      lastPath = packageJSONPath;\n      packageJSONUrl = new URL((isScoped ?\n        '../../../../node_modules/' : '../../../node_modules/') +\n        packageName + '/package.json', packageJSONUrl);\n      packageJSONPath = fileURLToPath(packageJSONUrl);\n      continue;\n    }\n\n    // Package match.\n    const packageConfig = getPackageConfig(packageJSONPath, specifier, base);\n    if (packageConfig.exports !== undefined && packageConfig.exports !== null)\n      return packageExportsResolve(\n        packageJSONUrl, packageSubpath, packageConfig, base, conditions\n      ).resolved;\n    if (packageSubpath === '.')\n      return legacyMainResolve(packageJSONUrl, packageConfig, base);\n    return new URL(packageSubpath, packageJSONUrl);\n    // Cross-platform root check.\n  } while (packageJSONPath.length !== lastPath.length);\n\n  // eslint can't handle the above code.\n  // eslint-disable-next-line no-unreachable\n  throw new ERR_MODULE_NOT_FOUND(packageName, fileURLToPath(base));\n}\n\nfunction isBareSpecifier(specifier) {\n  return specifier[0] && specifier[0] !== '/' && specifier[0] !== '.';\n}\n\nfunction isRelativeSpecifier(specifier) {\n  if (specifier[0] === '.') {\n    if (specifier.length === 1 || specifier[1] === '/') return true;\n    if (specifier[1] === '.') {\n      if (specifier.length === 2 || specifier[2] === '/') return true;\n    }\n  }\n  return false;\n}\n\nfunction shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {\n  if (specifier === '') return false;\n  if (specifier[0] === '/') return true;\n  return isRelativeSpecifier(specifier);\n}\n\n/**\n * @param {string} specifier\n * @param {URL} base\n * @param {Set<string>} conditions\n * @returns {URL}\n */\nfunction moduleResolve(specifier, base, conditions) {\n  // Order swapped from spec for minor perf gain.\n  // Ok since relative URLs cannot parse as URLs.\n  let resolved;\n  if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n    resolved = new URL(specifier, base);\n  } else if (specifier[0] === '#') {\n    ({ resolved } = packageImportsResolve(specifier, base, conditions));\n  } else {\n    try {\n      resolved = new URL(specifier);\n    } catch {\n      resolved = packageResolve(specifier, base, conditions);\n    }\n  }\n  return finalizeResolution(resolved, base);\n}\n\n/**\n * Try to resolve an import as a CommonJS module\n * @param {string} specifier\n * @param {string} parentURL\n * @returns {boolean|string}\n */\nfunction resolveAsCommonJS(specifier, parentURL) {\n  try {\n    const parent = fileURLToPath(parentURL);\n    const tmpModule = new CJSModule(parent, null);\n    tmpModule.paths = CJSModule._nodeModulePaths(parent);\n\n    let found = CJSModule._resolveFilename(specifier, tmpModule, false);\n\n    // If it is a relative specifier return the relative path\n    // to the parent\n    if (isRelativeSpecifier(specifier)) {\n      found = relative(parent, found);\n      // Add '.separator if the path does not start with '..separator'\n      // This should be a safe assumption because when loading\n      // esm modules there should be always a file specified so\n      // there should not be a specifier like '..' or '.'\n      if (!StringPrototypeStartsWith(found, `..${sep}`)) {\n        found = `.${sep}${found}`;\n      }\n    } else if (isBareSpecifier(specifier)) {\n      // If it is a bare specifier return the relative path within the\n      // module\n      const pkg = StringPrototypeSplit(specifier, '/')[0];\n      const index = StringPrototypeIndexOf(found, pkg);\n      if (index !== -1) {\n        found = StringPrototypeSlice(found, index);\n      }\n    }\n    // Normalize the path separator to give a valid suggestion\n    // on Windows\n    if (process.platform === 'win32') {\n      found = StringPrototypeReplace(found, new RegExp(`\\\\${sep}`, 'g'), '/');\n    }\n    return found;\n  } catch {\n    return false;\n  }\n}\n\nfunction defaultResolve(specifier, context = {}, defaultResolveUnused) {\n  let { parentURL, conditions } = context;\n  if (parentURL && policy != null && policy.manifest) {\n    const redirects = policy.manifest.getDependencyMapper(parentURL);\n    if (redirects) {\n      const { resolve, reaction } = redirects;\n      const destination = resolve(specifier, new SafeSet(conditions));\n      let missing = true;\n      if (destination === true) {\n        missing = false;\n      } else if (destination) {\n        const href = destination.href;\n        return { url: href };\n      }\n      if (missing) {\n        reaction(new ERR_MANIFEST_DEPENDENCY_MISSING(\n          parentURL,\n          specifier,\n          ArrayPrototypeJoin([...conditions], ', '))\n        );\n      }\n    }\n  }\n  let parsed;\n  try {\n    parsed = new URL(specifier);\n    if (parsed.protocol === 'data:') {\n      return {\n        url: specifier\n      };\n    }\n  } catch {}\n  if (parsed && parsed.protocol === builtinModuleProtocol)\n    return { url: specifier };\n  if (parsed && parsed.protocol !== 'file:' && parsed.protocol !== 'data:')\n    throw new ERR_UNSUPPORTED_ESM_URL_SCHEME(parsed);\n  if (NativeModule.canBeRequiredByUsers(specifier)) {\n    return {\n      url: builtinModuleProtocol + specifier\n    };\n  }\n  if (parentURL && StringPrototypeStartsWith(parentURL, 'data:')) {\n    // This is gonna blow up, we want the error\n    new URL(specifier, parentURL);\n  }\n\n  const isMain = parentURL === undefined;\n  if (isMain) {\n    parentURL = pathToFileURL(`${process.cwd()}/`).href;\n\n    // This is the initial entry point to the program, and --input-type has\n    // been passed as an option; but --input-type can only be used with\n    // --eval, --print or STDIN string input. It is not allowed with file\n    // input, to avoid user confusion over how expansive the effect of the\n    // flag should be (i.e. entry point only, package scope surrounding the\n    // entry point, etc.).\n    if (typeFlag)\n      throw new ERR_INPUT_TYPE_NOT_ALLOWED();\n  }\n\n  conditions = getConditionsSet(conditions);\n  let url;\n  try {\n    url = moduleResolve(specifier, parentURL, conditions);\n  } catch (error) {\n    // Try to give the user a hint of what would have been the\n    // resolved CommonJS module\n    if (error.code === 'ERR_MODULE_NOT_FOUND' ||\n        error.code === 'ERR_UNSUPPORTED_DIR_IMPORT') {\n      if (StringPrototypeStartsWith(specifier, 'file://')) {\n        specifier = fileURLToPath(specifier);\n      }\n      const found = resolveAsCommonJS(specifier, parentURL);\n      if (found) {\n        // Modify the stack and message string to include the hint\n        const lines = StringPrototypeSplit(error.stack, '\\n');\n        const hint = `Did you mean to import ${found}?`;\n        error.stack =\n          ArrayPrototypeShift(lines) + '\\n' +\n          hint + '\\n' +\n          ArrayPrototypeJoin(lines, '\\n');\n        error.message += `\\n${hint}`;\n      }\n    }\n    throw error;\n  }\n\n  if (isMain ? !preserveSymlinksMain : !preserveSymlinks) {\n    const urlPath = fileURLToPath(url);\n    const real = realpathSync(urlPath, {\n      // [internalFS.realpathCacheKey]: realpathCache\n    });\n    const old = url;\n    url = pathToFileURL(\n      real + (StringPrototypeEndsWith(urlPath, sep) ? '/' : ''));\n    url.search = old.search;\n    url.hash = old.hash;\n  }\n\n  return { url: `${url}` };\n}\n\nreturn {\n  DEFAULT_CONDITIONS,\n  defaultResolve,\n  encodedSepRegEx,\n  getPackageType,\n  packageExportsResolve,\n  packageImportsResolve\n};\n}\nmodule.exports = {\n  createResolve\n};\n",
    "dist-raw/node-internal-modules-esm-get_format.js": "// Copied from https://raw.githubusercontent.com/nodejs/node/v15.3.0/lib/internal/modules/esm/get_format.js\n\n'use strict';\nconst {\n  RegExpPrototypeExec,\n  StringPrototypeStartsWith,\n} = require('./node-primordials');\nconst { extname } = require('path');\nconst { getOptionValue } = require('./node-options');\n\nconst [nodeMajor, nodeMinor] = process.versions.node.split('.').map(s => parseInt(s, 10));\nconst experimentalJsonModules =\n  nodeMajor > 17\n  || (nodeMajor === 17 && nodeMinor >= 5)\n  || (nodeMajor === 16 && nodeMinor >= 15)\n  || getOptionValue('--experimental-json-modules');\nconst experimentalWasmModules = getOptionValue('--experimental-wasm-modules');\nconst { URL, fileURLToPath } = require('url');\nconst { ERR_UNKNOWN_FILE_EXTENSION } = require('./node-internal-errors').codes;\n\nconst extensionFormatMap = {\n  '__proto__': null,\n  '.cjs': 'commonjs',\n  '.js': 'module',\n  '.mjs': 'module'\n};\n\nconst legacyExtensionFormatMap = {\n  '__proto__': null,\n  '.cjs': 'commonjs',\n  '.js': 'commonjs',\n  '.json': 'commonjs',\n  '.mjs': 'module',\n  '.node': 'commonjs'\n};\n\nif (experimentalWasmModules)\n  extensionFormatMap['.wasm'] = legacyExtensionFormatMap['.wasm'] = 'wasm';\n\nif (experimentalJsonModules)\n  extensionFormatMap['.json'] = legacyExtensionFormatMap['.json'] = 'json';\n\n/**\n *\n * @param {'node' | 'explicit'} [tsNodeExperimentalSpecifierResolution]\n * @param {ReturnType<\n *  typeof import('../dist-raw/node-internal-modules-esm-resolve').createResolve\n * >} nodeEsmResolver\n */\nfunction createGetFormat(tsNodeExperimentalSpecifierResolution, nodeEsmResolver) {\n// const experimentalSpeciferResolution = tsNodeExperimentalSpecifierResolution ?? getOptionValue('--experimental-specifier-resolution');\nlet experimentalSpeciferResolution = tsNodeExperimentalSpecifierResolution != null ? tsNodeExperimentalSpecifierResolution : getOptionValue('--experimental-specifier-resolution');\nconst { getPackageType } = nodeEsmResolver;\n\n/**\n * @param {string} url\n * @param {{}} context\n * @param {any} defaultGetFormatUnused\n * @returns {ReturnType<import('../src/esm').NodeLoaderHooksAPI1.GetFormatHook>}\n */\nfunction defaultGetFormat(url, context, defaultGetFormatUnused) {\n  if (StringPrototypeStartsWith(url, 'node:')) {\n    return { format: 'builtin' };\n  }\n  const parsed = new URL(url);\n  if (parsed.protocol === 'data:') {\n    const [ , mime ] = RegExpPrototypeExec(\n      /^([^/]+\\/[^;,]+)(?:[^,]*?)(;base64)?,/,\n      parsed.pathname,\n    ) || [ null, null, null ];\n    const format = ({\n      '__proto__': null,\n      'text/javascript': 'module',\n      'application/json': experimentalJsonModules ? 'json' : null,\n      'application/wasm': experimentalWasmModules ? 'wasm' : null\n    })[mime] || null;\n    return { format };\n  } else if (parsed.protocol === 'file:') {\n    const ext = extname(parsed.pathname);\n    let format;\n    if (ext === '.js') {\n      format = getPackageType(parsed.href) === 'module' ? 'module' : 'commonjs';\n    } else {\n      format = extensionFormatMap[ext];\n    }\n    if (!format) {\n      if (experimentalSpeciferResolution === 'node') {\n        process.emitWarning(\n          'The Node.js specifier resolution in ESM is experimental.',\n          'ExperimentalWarning');\n        format = legacyExtensionFormatMap[ext];\n      } else {\n        throw new ERR_UNKNOWN_FILE_EXTENSION(ext, fileURLToPath(url));\n      }\n    }\n    return { format: format || null };\n  }\n  return { format: null };\n}\n\nreturn {defaultGetFormat};\n}\n\nmodule.exports = {\n  createGetFormat\n};\n",
    "dist/esm.js": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createEsmHooks = exports.registerAndCreateEsmHooks = exports.filterHooksByAPIVersion = void 0;\nconst index_1 = require(\"./index\");\nconst url_1 = require(\"url\");\nconst path_1 = require(\"path\");\nconst assert = require(\"assert\");\nconst util_1 = require(\"./util\");\nconst module_1 = require(\"module\");\n// The hooks API changed in node version X so we need to check for backwards compatibility.\nconst newHooksAPI = (0, util_1.versionGteLt)(process.versions.node, '16.12.0');\n/** @internal */\nfunction filterHooksByAPIVersion(hooks) {\n    const { getFormat, load, resolve, transformSource } = hooks;\n    // Explicit return type to avoid TS's non-ideal inferred type\n    const hooksAPI = newHooksAPI\n        ? { resolve, load, getFormat: undefined, transformSource: undefined }\n        : { resolve, getFormat, transformSource, load: undefined };\n    return hooksAPI;\n}\nexports.filterHooksByAPIVersion = filterHooksByAPIVersion;\n/** @internal */\nfunction registerAndCreateEsmHooks(opts) {\n    // Automatically performs registration just like `-r ts-node/register`\n    const tsNodeInstance = (0, index_1.register)(opts);\n    return createEsmHooks(tsNodeInstance);\n}\nexports.registerAndCreateEsmHooks = registerAndCreateEsmHooks;\nfunction createEsmHooks(tsNodeService) {\n    tsNodeService.enableExperimentalEsmLoaderInterop();\n    // Custom implementation that considers additional file extensions and automatically adds file extensions\n    const nodeResolveImplementation = tsNodeService.getNodeEsmResolver();\n    const nodeGetFormatImplementation = tsNodeService.getNodeEsmGetFormat();\n    const extensions = tsNodeService.extensions;\n    const hooksAPI = filterHooksByAPIVersion({\n        resolve,\n        load,\n        getFormat,\n        transformSource,\n    });\n    function isFileUrlOrNodeStyleSpecifier(parsed) {\n        // We only understand file:// URLs, but in node, the specifier can be a node-style `./foo` or `foo`\n        const { protocol } = parsed;\n        return protocol === null || protocol === 'file:';\n    }\n    /**\n     * Named \"probably\" as a reminder that this is a guess.\n     * node does not explicitly tell us if we're resolving the entrypoint or not.\n     */\n    function isProbablyEntrypoint(specifier, parentURL) {\n        return parentURL === undefined && specifier.startsWith('file://');\n    }\n    // Side-channel between `resolve()` and `load()` hooks\n    const rememberIsProbablyEntrypoint = new Set();\n    const rememberResolvedViaCommonjsFallback = new Set();\n    async function resolve(specifier, context, defaultResolve) {\n        const defer = async () => {\n            const r = await defaultResolve(specifier, context, defaultResolve);\n            return r;\n        };\n        // See: https://github.com/nodejs/node/discussions/41711\n        // nodejs will likely implement a similar fallback.  Till then, we can do our users a favor and fallback today.\n        async function entrypointFallback(cb) {\n            try {\n                const resolution = await cb();\n                if ((resolution === null || resolution === void 0 ? void 0 : resolution.url) &&\n                    isProbablyEntrypoint(specifier, context.parentURL))\n                    rememberIsProbablyEntrypoint.add(resolution.url);\n                return resolution;\n            }\n            catch (esmResolverError) {\n                if (!isProbablyEntrypoint(specifier, context.parentURL))\n                    throw esmResolverError;\n                try {\n                    let cjsSpecifier = specifier;\n                    // Attempt to convert from ESM file:// to CommonJS path\n                    try {\n                        if (specifier.startsWith('file://'))\n                            cjsSpecifier = (0, url_1.fileURLToPath)(specifier);\n                    }\n                    catch { }\n                    const resolution = (0, url_1.pathToFileURL)((0, module_1.createRequire)(process.cwd()).resolve(cjsSpecifier)).toString();\n                    rememberIsProbablyEntrypoint.add(resolution);\n                    rememberResolvedViaCommonjsFallback.add(resolution);\n                    return { url: resolution, format: 'commonjs' };\n                }\n                catch (commonjsResolverError) {\n                    throw esmResolverError;\n                }\n            }\n        }\n        return addShortCircuitFlag(async () => {\n            const parsed = (0, url_1.parse)(specifier);\n            const { pathname, protocol, hostname } = parsed;\n            if (!isFileUrlOrNodeStyleSpecifier(parsed)) {\n                return entrypointFallback(defer);\n            }\n            if (protocol !== null && protocol !== 'file:') {\n                return entrypointFallback(defer);\n            }\n            // Malformed file:// URL?  We should always see `null` or `''`\n            if (hostname) {\n                // TODO file://./foo sets `hostname` to `'.'`.  Perhaps we should special-case this.\n                return entrypointFallback(defer);\n            }\n            // pathname is the path to be resolved\n            return entrypointFallback(() => nodeResolveImplementation.defaultResolve(specifier, context, defaultResolve));\n        });\n    }\n    // `load` from new loader hook API (See description at the top of this file)\n    async function load(url, context, defaultLoad) {\n        return addShortCircuitFlag(async () => {\n            var _a;\n            // If we get a format hint from resolve() on the context then use it\n            // otherwise call the old getFormat() hook using node's old built-in defaultGetFormat() that ships with ts-node\n            const format = (_a = context.format) !== null && _a !== void 0 ? _a : (await getFormat(url, context, nodeGetFormatImplementation.defaultGetFormat)).format;\n            let source = undefined;\n            if (format !== 'builtin' && format !== 'commonjs') {\n                // Call the new defaultLoad() to get the source\n                const { source: rawSource } = await defaultLoad(url, {\n                    ...context,\n                    format,\n                }, defaultLoad);\n                if (rawSource === undefined || rawSource === null) {\n                    throw new Error(`Failed to load raw source: Format was '${format}' and url was '${url}''.`);\n                }\n                // Emulate node's built-in old defaultTransformSource() so we can re-use the old transformSource() hook\n                const defaultTransformSource = async (source, _context, _defaultTransformSource) => ({ source });\n                // Call the old hook\n                const { source: transformedSource } = await transformSource(rawSource, { url, format }, defaultTransformSource);\n                source = transformedSource;\n            }\n            return { format, source };\n        });\n    }\n    async function getFormat(url, context, defaultGetFormat) {\n        const defer = (overrideUrl = url) => defaultGetFormat(overrideUrl, context, defaultGetFormat);\n        // See: https://github.com/nodejs/node/discussions/41711\n        // nodejs will likely implement a similar fallback.  Till then, we can do our users a favor and fallback today.\n        async function entrypointFallback(cb) {\n            try {\n                return await cb();\n            }\n            catch (getFormatError) {\n                if (!rememberIsProbablyEntrypoint.has(url))\n                    throw getFormatError;\n                return { format: 'commonjs' };\n            }\n        }\n        const parsed = (0, url_1.parse)(url);\n        if (!isFileUrlOrNodeStyleSpecifier(parsed)) {\n            return entrypointFallback(defer);\n        }\n        const { pathname } = parsed;\n        assert(pathname !== null, 'ESM getFormat() hook: URL should never have null pathname');\n        const nativePath = (0, url_1.fileURLToPath)(url);\n        let nodeSays;\n        // If file has extension not understood by node, then ask node how it would treat the emitted extension.\n        // E.g. .mts compiles to .mjs, so ask node how to classify an .mjs file.\n        const ext = (0, path_1.extname)(nativePath);\n        const tsNodeIgnored = tsNodeService.ignored(nativePath);\n        const nodeEquivalentExt = extensions.nodeEquivalents.get(ext);\n        if (nodeEquivalentExt && !tsNodeIgnored) {\n            nodeSays = await entrypointFallback(() => defer((0, url_1.format)((0, url_1.pathToFileURL)(nativePath + nodeEquivalentExt))));\n        }\n        else {\n            try {\n                nodeSays = await entrypointFallback(defer);\n            }\n            catch (e) {\n                if (e instanceof Error &&\n                    tsNodeIgnored &&\n                    extensions.nodeDoesNotUnderstand.includes(ext)) {\n                    e.message +=\n                        `\\n\\n` +\n                            `Hint:\\n` +\n                            `ts-node is configured to ignore this file.\\n` +\n                            `If you want ts-node to handle this file, consider enabling the \"skipIgnore\" option or adjusting your \"ignore\" patterns.\\n` +\n                            `https://typestrong.org/ts-node/docs/scope\\n`;\n                }\n                throw e;\n            }\n        }\n        // For files compiled by ts-node that node believes are either CJS or ESM, check if we should override that classification\n        if (!tsNodeService.ignored(nativePath) &&\n            (nodeSays.format === 'commonjs' || nodeSays.format === 'module')) {\n            const { moduleType } = tsNodeService.moduleTypeClassifier.classifyModuleByModuleTypeOverrides((0, util_1.normalizeSlashes)(nativePath));\n            if (moduleType === 'cjs') {\n                return { format: 'commonjs' };\n            }\n            else if (moduleType === 'esm') {\n                return { format: 'module' };\n            }\n        }\n        return nodeSays;\n    }\n    async function transformSource(source, context, defaultTransformSource) {\n        if (source === null || source === undefined) {\n            throw new Error('No source');\n        }\n        const defer = () => defaultTransformSource(source, context, defaultTransformSource);\n        const sourceAsString = typeof source === 'string' ? source : source.toString('utf8');\n        const { url } = context;\n        const parsed = (0, url_1.parse)(url);\n        if (!isFileUrlOrNodeStyleSpecifier(parsed)) {\n            return defer();\n        }\n        const nativePath = (0, url_1.fileURLToPath)(url);\n        if (tsNodeService.ignored(nativePath)) {\n            return defer();\n        }\n        const emittedJs = tsNodeService.compile(sourceAsString, nativePath);\n        return { source: emittedJs };\n    }\n    return hooksAPI;\n}\nexports.createEsmHooks = createEsmHooks;\nasync function addShortCircuitFlag(fn) {\n    const ret = await fn();\n    // Not sure if this is necessary; being lazy.  Can revisit in the future.\n    if (ret == null)\n        return ret;\n    return {\n        ...ret,\n        shortCircuit: true,\n    };\n}\n//# sourceMappingURL=esm.js.map",
    "dist/ts-internals.js": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getEmitScriptTarget = exports.getUseDefineForClassFields = exports.getPatternFromSpec = exports.createTsInternals = void 0;\nconst path_1 = require(\"path\");\nconst util_1 = require(\"./util\");\n/** @internal */\nexports.createTsInternals = (0, util_1.cachedLookup)(createTsInternalsUncached);\n/**\n * Given a reference to the TS compiler, return some TS internal functions that we\n * could not or did not want to grab off the `ts` object.\n * These have been copy-pasted from TS's source and tweaked as necessary.\n *\n * NOTE: This factory returns *only* functions which need a reference to the TS\n * compiler.  Other functions do not need a reference to the TS compiler so are\n * exported directly from this file.\n */\nfunction createTsInternalsUncached(_ts) {\n    const ts = _ts;\n    /**\n     * Copied from:\n     * https://github.com/microsoft/TypeScript/blob/v4.3.2/src/compiler/commandLineParser.ts#L2821-L2846\n     */\n    function getExtendsConfigPath(extendedConfig, host, basePath, errors, createDiagnostic) {\n        extendedConfig = (0, util_1.normalizeSlashes)(extendedConfig);\n        if (isRootedDiskPath(extendedConfig) ||\n            startsWith(extendedConfig, './') ||\n            startsWith(extendedConfig, '../')) {\n            let extendedConfigPath = getNormalizedAbsolutePath(extendedConfig, basePath);\n            if (!host.fileExists(extendedConfigPath) &&\n                !endsWith(extendedConfigPath, ts.Extension.Json)) {\n                extendedConfigPath = `${extendedConfigPath}.json`;\n                if (!host.fileExists(extendedConfigPath)) {\n                    errors.push(createDiagnostic(ts.Diagnostics.File_0_not_found, extendedConfig));\n                    return undefined;\n                }\n            }\n            return extendedConfigPath;\n        }\n        // If the path isn't a rooted or relative path, resolve like a module\n        const tsGte5_3_0 = (0, util_1.versionGteLt)(ts.version, '5.3.0');\n        const resolved = ts.nodeModuleNameResolver(extendedConfig, combinePaths(basePath, 'tsconfig.json'), { moduleResolution: ts.ModuleResolutionKind.NodeJs }, host, \n        /*cache*/ undefined, \n        /*projectRefs*/ undefined, \n        /*conditionsOrIsConfigLookup*/ tsGte5_3_0 ? undefined : true, \n        /*isConfigLookup*/ tsGte5_3_0 ? true : undefined);\n        if (resolved.resolvedModule) {\n            return resolved.resolvedModule.resolvedFileName;\n        }\n        errors.push(createDiagnostic(ts.Diagnostics.File_0_not_found, extendedConfig));\n        return undefined;\n    }\n    return { getExtendsConfigPath };\n}\n// These functions have alternative implementation to avoid copying too much from TS\nfunction isRootedDiskPath(path) {\n    return (0, path_1.isAbsolute)(path);\n}\nfunction combinePaths(path, ...paths) {\n    return (0, util_1.normalizeSlashes)((0, path_1.resolve)(path, ...paths.filter((path) => path)));\n}\nfunction getNormalizedAbsolutePath(fileName, currentDirectory) {\n    return (0, util_1.normalizeSlashes)(currentDirectory != null\n        ? (0, path_1.resolve)(currentDirectory, fileName)\n        : (0, path_1.resolve)(fileName));\n}\nfunction startsWith(str, prefix) {\n    return str.lastIndexOf(prefix, 0) === 0;\n}\nfunction endsWith(str, suffix) {\n    const expectedPos = str.length - suffix.length;\n    return expectedPos >= 0 && str.indexOf(suffix, expectedPos) === expectedPos;\n}\n// Reserved characters, forces escaping of any non-word (or digit), non-whitespace character.\n// It may be inefficient (we could just match (/[-[\\]{}()*+?.,\\\\^$|#\\s]/g), but this is future\n// proof.\nconst reservedCharacterPattern = /[^\\w\\s\\/]/g;\n/**\n * @internal\n * See also: getRegularExpressionForWildcard, which seems to do almost the same thing\n */\nfunction getPatternFromSpec(spec, basePath) {\n    const pattern = spec && getSubPatternFromSpec(spec, basePath, excludeMatcher);\n    return pattern && `^(${pattern})${'($|/)'}`;\n}\nexports.getPatternFromSpec = getPatternFromSpec;\nfunction getSubPatternFromSpec(spec, basePath, { singleAsteriskRegexFragment, doubleAsteriskRegexFragment, replaceWildcardCharacter, }) {\n    let subpattern = '';\n    let hasWrittenComponent = false;\n    const components = getNormalizedPathComponents(spec, basePath);\n    const lastComponent = last(components);\n    // getNormalizedPathComponents includes the separator for the root component.\n    // We need to remove to create our regex correctly.\n    components[0] = removeTrailingDirectorySeparator(components[0]);\n    if (isImplicitGlob(lastComponent)) {\n        components.push('**', '*');\n    }\n    let optionalCount = 0;\n    for (let component of components) {\n        if (component === '**') {\n            subpattern += doubleAsteriskRegexFragment;\n        }\n        else {\n            if (hasWrittenComponent) {\n                subpattern += directorySeparator;\n            }\n            subpattern += component.replace(reservedCharacterPattern, replaceWildcardCharacter);\n        }\n        hasWrittenComponent = true;\n    }\n    while (optionalCount > 0) {\n        subpattern += ')?';\n        optionalCount--;\n    }\n    return subpattern;\n}\nconst directoriesMatcher = {\n    singleAsteriskRegexFragment: '[^/]*',\n    /**\n     * Regex for the ** wildcard. Matches any num of subdirectories. When used for including\n     * files or directories, does not match subdirectories that start with a . character\n     */\n    doubleAsteriskRegexFragment: `(/[^/.][^/]*)*?`,\n    replaceWildcardCharacter: (match) => replaceWildcardCharacter(match, directoriesMatcher.singleAsteriskRegexFragment),\n};\nconst excludeMatcher = {\n    singleAsteriskRegexFragment: '[^/]*',\n    doubleAsteriskRegexFragment: '(/.+?)?',\n    replaceWildcardCharacter: (match) => replaceWildcardCharacter(match, excludeMatcher.singleAsteriskRegexFragment),\n};\nfunction getNormalizedPathComponents(path, currentDirectory) {\n    return reducePathComponents(getPathComponents(path, currentDirectory));\n}\nfunction getPathComponents(path, currentDirectory = '') {\n    path = combinePaths(currentDirectory, path);\n    return pathComponents(path, getRootLength(path));\n}\nfunction reducePathComponents(components) {\n    if (!some(components))\n        return [];\n    const reduced = [components[0]];\n    for (let i = 1; i < components.length; i++) {\n        const component = components[i];\n        if (!component)\n            continue;\n        if (component === '.')\n            continue;\n        if (component === '..') {\n            if (reduced.length > 1) {\n                if (reduced[reduced.length - 1] !== '..') {\n                    reduced.pop();\n                    continue;\n                }\n            }\n            else if (reduced[0])\n                continue;\n        }\n        reduced.push(component);\n    }\n    return reduced;\n}\nfunction getRootLength(path) {\n    const rootLength = getEncodedRootLength(path);\n    return rootLength < 0 ? ~rootLength : rootLength;\n}\nfunction getEncodedRootLength(path) {\n    if (!path)\n        return 0;\n    const ch0 = path.charCodeAt(0);\n    // POSIX or UNC\n    if (ch0 === 47 /* CharacterCodes.slash */ || ch0 === 92 /* CharacterCodes.backslash */) {\n        if (path.charCodeAt(1) !== ch0)\n            return 1; // POSIX: \"/\" (or non-normalized \"\\\")\n        const p1 = path.indexOf(ch0 === 47 /* CharacterCodes.slash */ ? directorySeparator : altDirectorySeparator, 2);\n        if (p1 < 0)\n            return path.length; // UNC: \"//server\" or \"\\\\server\"\n        return p1 + 1; // UNC: \"//server/\" or \"\\\\server\\\"\n    }\n    // DOS\n    if (isVolumeCharacter(ch0) && path.charCodeAt(1) === 58 /* CharacterCodes.colon */) {\n        const ch2 = path.charCodeAt(2);\n        if (ch2 === 47 /* CharacterCodes.slash */ || ch2 === 92 /* CharacterCodes.backslash */)\n            return 3; // DOS: \"c:/\" or \"c:\\\"\n        if (path.length === 2)\n            return 2; // DOS: \"c:\" (but not \"c:d\")\n    }\n    // URL\n    const schemeEnd = path.indexOf(urlSchemeSeparator);\n    if (schemeEnd !== -1) {\n        const authorityStart = schemeEnd + urlSchemeSeparator.length;\n        const authorityEnd = path.indexOf(directorySeparator, authorityStart);\n        if (authorityEnd !== -1) {\n            // URL: \"file:///\", \"file://server/\", \"file://server/path\"\n            // For local \"file\" URLs, include the leading DOS volume (if present).\n            // Per https://www.ietf.org/rfc/rfc1738.txt, a host of \"\" or \"localhost\" is a\n            // special case interpreted as \"the machine from which the URL is being interpreted\".\n            const scheme = path.slice(0, schemeEnd);\n            const authority = path.slice(authorityStart, authorityEnd);\n            if (scheme === 'file' &&\n                (authority === '' || authority === 'localhost') &&\n                isVolumeCharacter(path.charCodeAt(authorityEnd + 1))) {\n                const volumeSeparatorEnd = getFileUrlVolumeSeparatorEnd(path, authorityEnd + 2);\n                if (volumeSeparatorEnd !== -1) {\n                    if (path.charCodeAt(volumeSeparatorEnd) === 47 /* CharacterCodes.slash */) {\n                        // URL: \"file:///c:/\", \"file://localhost/c:/\", \"file:///c%3a/\", \"file://localhost/c%3a/\"\n                        return ~(volumeSeparatorEnd + 1);\n                    }\n                    if (volumeSeparatorEnd === path.length) {\n                        // URL: \"file:///c:\", \"file://localhost/c:\", \"file:///c$3a\", \"file://localhost/c%3a\"\n                        // but not \"file:///c:d\" or \"file:///c%3ad\"\n                        return ~volumeSeparatorEnd;\n                    }\n                }\n            }\n            return ~(authorityEnd + 1); // URL: \"file://server/\", \"http://server/\"\n        }\n        return ~path.length; // URL: \"file://server\", \"http://server\"\n    }\n    // relative\n    return 0;\n}\nfunction ensureTrailingDirectorySeparator(path) {\n    if (!hasTrailingDirectorySeparator(path)) {\n        return path + directorySeparator;\n    }\n    return path;\n}\nfunction hasTrailingDirectorySeparator(path) {\n    return (path.length > 0 && isAnyDirectorySeparator(path.charCodeAt(path.length - 1)));\n}\nfunction isAnyDirectorySeparator(charCode) {\n    return (charCode === 47 /* CharacterCodes.slash */ || charCode === 92 /* CharacterCodes.backslash */);\n}\nfunction removeTrailingDirectorySeparator(path) {\n    if (hasTrailingDirectorySeparator(path)) {\n        return path.substr(0, path.length - 1);\n    }\n    return path;\n}\nconst directorySeparator = '/';\nconst altDirectorySeparator = '\\\\';\nconst urlSchemeSeparator = '://';\nfunction isVolumeCharacter(charCode) {\n    return ((charCode >= 97 /* CharacterCodes.a */ && charCode <= 122 /* CharacterCodes.z */) ||\n        (charCode >= 65 /* CharacterCodes.A */ && charCode <= 90 /* CharacterCodes.Z */));\n}\nfunction getFileUrlVolumeSeparatorEnd(url, start) {\n    const ch0 = url.charCodeAt(start);\n    if (ch0 === 58 /* CharacterCodes.colon */)\n        return start + 1;\n    if (ch0 === 37 /* CharacterCodes.percent */ &&\n        url.charCodeAt(start + 1) === 51 /* CharacterCodes._3 */) {\n        const ch2 = url.charCodeAt(start + 2);\n        if (ch2 === 97 /* CharacterCodes.a */ || ch2 === 65 /* CharacterCodes.A */)\n            return start + 3;\n    }\n    return -1;\n}\nfunction some(array, predicate) {\n    if (array) {\n        if (predicate) {\n            for (const v of array) {\n                if (predicate(v)) {\n                    return true;\n                }\n            }\n        }\n        else {\n            return array.length > 0;\n        }\n    }\n    return false;\n}\nfunction pathComponents(path, rootLength) {\n    const root = path.substring(0, rootLength);\n    const rest = path.substring(rootLength).split(directorySeparator);\n    if (rest.length && !lastOrUndefined(rest))\n        rest.pop();\n    return [root, ...rest];\n}\nfunction lastOrUndefined(array) {\n    return array.length === 0 ? undefined : array[array.length - 1];\n}\nfunction last(array) {\n    // Debug.assert(array.length !== 0);\n    return array[array.length - 1];\n}\nfunction replaceWildcardCharacter(match, singleAsteriskRegexFragment) {\n    return match === '*'\n        ? singleAsteriskRegexFragment\n        : match === '?'\n            ? '[^/]'\n            : '\\\\' + match;\n}\n/**\n * An \"includes\" path \"foo\" is implicitly a glob \"foo/** /*\" (without the space) if its last component has no extension,\n * and does not contain any glob characters itself.\n */\nfunction isImplicitGlob(lastPathComponent) {\n    return !/[.*?]/.test(lastPathComponent);\n}\nconst ts_ScriptTarget_ES5 = 1;\nconst ts_ScriptTarget_ES2022 = 9;\nconst ts_ScriptTarget_ESNext = 99;\nconst ts_ModuleKind_Node16 = 100;\nconst ts_ModuleKind_NodeNext = 199;\n// https://github.com/microsoft/TypeScript/blob/fc418a2e611c88cf9afa0115ff73490b2397d311/src/compiler/utilities.ts#L8761\nfunction getUseDefineForClassFields(compilerOptions) {\n    return compilerOptions.useDefineForClassFields === undefined\n        ? getEmitScriptTarget(compilerOptions) >= ts_ScriptTarget_ES2022\n        : compilerOptions.useDefineForClassFields;\n}\nexports.getUseDefineForClassFields = getUseDefineForClassFields;\n// https://github.com/microsoft/TypeScript/blob/fc418a2e611c88cf9afa0115ff73490b2397d311/src/compiler/utilities.ts#L8556\nfunction getEmitScriptTarget(compilerOptions) {\n    var _a;\n    return ((_a = compilerOptions.target) !== null && _a !== void 0 ? _a : ((compilerOptions.module === ts_ModuleKind_Node16 && ts_ScriptTarget_ES2022) ||\n        (compilerOptions.module === ts_ModuleKind_NodeNext && ts_ScriptTarget_ESNext) ||\n        ts_ScriptTarget_ES5));\n}\nexports.getEmitScriptTarget = getEmitScriptTarget;\n//# sourceMappingURL=ts-internals.js.map",
    "dist/tsconfigs.js": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getDefaultTsconfigJsonForNodeVersion = void 0;\nconst nodeMajor = parseInt(process.versions.node.split('.')[0], 10);\n/**\n * return parsed JSON of the bundled @tsconfig/bases config appropriate for the\n * running version of nodejs\n * @internal\n */\nfunction getDefaultTsconfigJsonForNodeVersion(ts) {\n    const tsInternal = ts;\n    if (nodeMajor >= 16) {\n        const config = require('@tsconfig/node16/tsconfig.json');\n        if (configCompatible(config))\n            return config;\n    }\n    if (nodeMajor >= 14) {\n        const config = require('@tsconfig/node14/tsconfig.json');\n        if (configCompatible(config))\n            return config;\n    }\n    if (nodeMajor >= 12) {\n        const config = require('@tsconfig/node12/tsconfig.json');\n        if (configCompatible(config))\n            return config;\n    }\n    return require('@tsconfig/node10/tsconfig.json');\n    // Verify that tsconfig target and lib options are compatible with TypeScript compiler\n    function configCompatible(config) {\n        return (typeof ts.ScriptTarget[config.compilerOptions.target.toUpperCase()] === 'number' &&\n            tsInternal.libs &&\n            config.compilerOptions.lib.every((lib) => tsInternal.libs.includes(lib)));\n    }\n}\nexports.getDefaultTsconfigJsonForNodeVersion = getDefaultTsconfigJsonForNodeVersion;\n//# sourceMappingURL=tsconfigs.js.map",
    "dist-raw/node-internal-repl-await.js": "// copied from https://github.com/nodejs/node/blob/88799930794045795e8abac874730f9eba7e2300/lib/internal/repl/await.js\n'use strict';\n\nconst {\n  ArrayFrom,\n  ArrayPrototypeForEach,\n  ArrayPrototypeIncludes,\n  ArrayPrototypeJoin,\n  ArrayPrototypePop,\n  ArrayPrototypePush,\n  FunctionPrototype,\n  ObjectKeys,\n  RegExpPrototypeSymbolReplace,\n  StringPrototypeEndsWith,\n  StringPrototypeIncludes,\n  StringPrototypeIndexOf,\n  StringPrototypeRepeat,\n  StringPrototypeSplit,\n  StringPrototypeStartsWith,\n  SyntaxError,\n} = require('./node-primordials');\n\nconst parser = require('acorn').Parser;\nconst walk = require('acorn-walk');\nconst { Recoverable } = require('repl');\n\nfunction isTopLevelDeclaration(state) {\n  return state.ancestors[state.ancestors.length - 2] === state.body;\n}\n\nconst noop = FunctionPrototype;\nconst visitorsWithoutAncestors = {\n  ClassDeclaration(node, state, c) {\n    if (isTopLevelDeclaration(state)) {\n      state.prepend(node, `${node.id.name}=`);\n      ArrayPrototypePush(\n        state.hoistedDeclarationStatements,\n        `let ${node.id.name}; `\n      );\n    }\n\n    walk.base.ClassDeclaration(node, state, c);\n  },\n  ForOfStatement(node, state, c) {\n    if (node.await === true) {\n      state.containsAwait = true;\n    }\n    walk.base.ForOfStatement(node, state, c);\n  },\n  FunctionDeclaration(node, state, c) {\n    state.prepend(node, `${node.id.name}=`);\n    ArrayPrototypePush(\n      state.hoistedDeclarationStatements,\n      `var ${node.id.name}; `\n    );\n  },\n  FunctionExpression: noop,\n  ArrowFunctionExpression: noop,\n  MethodDefinition: noop,\n  AwaitExpression(node, state, c) {\n    state.containsAwait = true;\n    walk.base.AwaitExpression(node, state, c);\n  },\n  ReturnStatement(node, state, c) {\n    state.containsReturn = true;\n    walk.base.ReturnStatement(node, state, c);\n  },\n  VariableDeclaration(node, state, c) {\n    const variableKind = node.kind;\n    const isIterableForDeclaration = ArrayPrototypeIncludes(\n      ['ForOfStatement', 'ForInStatement'],\n      state.ancestors[state.ancestors.length - 2].type\n    );\n\n    if (variableKind === 'var' || isTopLevelDeclaration(state)) {\n      state.replace(\n        node.start,\n        node.start + variableKind.length + (isIterableForDeclaration ? 1 : 0),\n        variableKind === 'var' && isIterableForDeclaration ?\n          '' :\n          'void' + (node.declarations.length === 1 ? '' : ' (')\n      );\n\n      if (!isIterableForDeclaration) {\n        ArrayPrototypeForEach(node.declarations, (decl) => {\n          state.prepend(decl, '(');\n          state.append(decl, decl.init ? ')' : '=undefined)');\n        });\n\n        if (node.declarations.length !== 1) {\n          state.append(node.declarations[node.declarations.length - 1], ')');\n        }\n      }\n\n      const variableIdentifiersToHoist = [\n        ['var', []],\n        ['let', []],\n      ];\n      function registerVariableDeclarationIdentifiers(node) {\n        switch (node.type) {\n          case 'Identifier':\n            ArrayPrototypePush(\n              variableIdentifiersToHoist[variableKind === 'var' ? 0 : 1][1],\n              node.name\n            );\n            break;\n          case 'ObjectPattern':\n            ArrayPrototypeForEach(node.properties, (property) => {\n              registerVariableDeclarationIdentifiers(property.value);\n            });\n            break;\n          case 'ArrayPattern':\n            ArrayPrototypeForEach(node.elements, (element) => {\n              registerVariableDeclarationIdentifiers(element);\n            });\n            break;\n        }\n      }\n\n      ArrayPrototypeForEach(node.declarations, (decl) => {\n        registerVariableDeclarationIdentifiers(decl.id);\n      });\n\n      ArrayPrototypeForEach(\n        variableIdentifiersToHoist,\n        ({ 0: kind, 1: identifiers }) => {\n          if (identifiers.length > 0) {\n            ArrayPrototypePush(\n              state.hoistedDeclarationStatements,\n              `${kind} ${ArrayPrototypeJoin(identifiers, ', ')}; `\n            );\n          }\n        }\n      );\n    }\n\n    walk.base.VariableDeclaration(node, state, c);\n  }\n};\n\nconst visitors = {};\nfor (const nodeType of ObjectKeys(walk.base)) {\n  const callback = visitorsWithoutAncestors[nodeType] || walk.base[nodeType];\n  visitors[nodeType] = (node, state, c) => {\n    const isNew = node !== state.ancestors[state.ancestors.length - 1];\n    if (isNew) {\n      ArrayPrototypePush(state.ancestors, node);\n    }\n    callback(node, state, c);\n    if (isNew) {\n      ArrayPrototypePop(state.ancestors);\n    }\n  };\n}\n\nfunction processTopLevelAwait(src) {\n  const wrapPrefix = '(async () => { ';\n  const wrapped = `${wrapPrefix}${src} })()`;\n  const wrappedArray = ArrayFrom(wrapped);\n  let root;\n  try {\n    root = parser.parse(wrapped, { ecmaVersion: 'latest' });\n  } catch (e) {\n    if (StringPrototypeStartsWith(e.message, 'Unterminated '))\n      throw new Recoverable(e);\n    // If the parse error is before the first \"await\", then use the execution\n    // error. Otherwise we must emit this parse error, making it look like a\n    // proper syntax error.\n    const awaitPos = StringPrototypeIndexOf(src, 'await');\n    const errPos = e.pos - wrapPrefix.length;\n    if (awaitPos > errPos)\n      return null;\n    // Convert keyword parse errors on await into their original errors when\n    // possible.\n    if (errPos === awaitPos + 6 &&\n        StringPrototypeIncludes(e.message, 'Expecting Unicode escape sequence'))\n      return null;\n    if (errPos === awaitPos + 7 &&\n        StringPrototypeIncludes(e.message, 'Unexpected token'))\n      return null;\n    const line = e.loc.line;\n    const column = line === 1 ? e.loc.column - wrapPrefix.length : e.loc.column;\n    let message = '\\n' + StringPrototypeSplit(src, '\\n')[line - 1] + '\\n' +\n        StringPrototypeRepeat(' ', column) +\n        '^\\n\\n' + RegExpPrototypeSymbolReplace(/ \\([^)]+\\)/, e.message, '');\n    // V8 unexpected token errors include the token string.\n    if (StringPrototypeEndsWith(message, 'Unexpected token'))\n      message += \" '\" +\n        // Wrapper end may cause acorn to report error position after the source\n        ((src.length - 1) >= (e.pos - wrapPrefix.length)\n          ? src[e.pos - wrapPrefix.length]\n          : src[src.length - 1]) +\n        \"'\";\n    // eslint-disable-next-line no-restricted-syntax\n    throw new SyntaxError(message);\n  }\n  const body = root.body[0].expression.callee.body;\n  const state = {\n    body,\n    ancestors: [],\n    hoistedDeclarationStatements: [],\n    replace(from, to, str) {\n      for (let i = from; i < to; i++) {\n        wrappedArray[i] = '';\n      }\n      if (from === to) str += wrappedArray[from];\n      wrappedArray[from] = str;\n    },\n    prepend(node, str) {\n      wrappedArray[node.start] = str + wrappedArray[node.start];\n    },\n    append(node, str) {\n      wrappedArray[node.end - 1] += str;\n    },\n    containsAwait: false,\n    containsReturn: false\n  };\n\n  walk.recursive(body, state, visitors);\n\n  // Do not transform if\n  // 1. False alarm: there isn't actually an await expression.\n  // 2. There is a top-level return, which is not allowed.\n  if (!state.containsAwait || state.containsReturn) {\n    return null;\n  }\n\n  const last = body.body[body.body.length - 1];\n  if (last.type === 'ExpressionStatement') {\n    // For an expression statement of the form\n    // ( expr ) ;\n    // ^^^^^^^^^^   // last\n    //   ^^^^       // last.expression\n    //\n    // We do not want the left parenthesis before the `return` keyword;\n    // therefore we prepend the `return (` to `last`.\n    //\n    // On the other hand, we do not want the right parenthesis after the\n    // semicolon. Since there can only be more right parentheses between\n    // last.expression.end and the semicolon, appending one more to\n    // last.expression should be fine.\n    state.prepend(last, 'return (');\n    state.append(last.expression, ')');\n  }\n\n  return (\n    ArrayPrototypeJoin(state.hoistedDeclarationStatements, '') +\n    ArrayPrototypeJoin(wrappedArray, '')\n  );\n}\n\nmodule.exports = {\n  processTopLevelAwait\n};\n",
    "dist-raw/node-primordials.js": "module.exports = {\n  ArrayFrom: Array.from,\n  ArrayIsArray: Array.isArray,\n  ArrayPrototypeShift: (obj) => Array.prototype.shift.call(obj),\n  ArrayPrototypeForEach: (arr, ...rest) => Array.prototype.forEach.apply(arr, rest),\n  ArrayPrototypeIncludes: (arr, ...rest) => Array.prototype.includes.apply(arr, rest),\n  ArrayPrototypeJoin: (arr, ...rest) => Array.prototype.join.apply(arr, rest),\n  ArrayPrototypePop: (arr, ...rest) => Array.prototype.pop.apply(arr, rest),\n  ArrayPrototypePush: (arr, ...rest) => Array.prototype.push.apply(arr, rest),\n  FunctionPrototype: Function.prototype,\n  JSONParse: JSON.parse,\n  JSONStringify: JSON.stringify,\n  ObjectFreeze: Object.freeze,\n  ObjectKeys: Object.keys,\n  ObjectGetOwnPropertyNames: Object.getOwnPropertyNames,\n  ObjectDefineProperty: Object.defineProperty,\n  ObjectPrototypeHasOwnProperty: (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop),\n  RegExpPrototypeExec: (obj, string) => RegExp.prototype.exec.call(obj, string),\n  RegExpPrototypeTest: (obj, string) => RegExp.prototype.test.call(obj, string),\n  RegExpPrototypeSymbolReplace: (obj, ...rest) => RegExp.prototype[Symbol.replace].apply(obj, rest),\n  SafeMap: Map,\n  SafeSet: Set,\n  SafeWeakMap: WeakMap,\n  StringPrototypeEndsWith: (str, ...rest) => String.prototype.endsWith.apply(str, rest),\n  StringPrototypeIncludes: (str, ...rest) => String.prototype.includes.apply(str, rest),\n  StringPrototypeLastIndexOf: (str, ...rest) => String.prototype.lastIndexOf.apply(str, rest),\n  StringPrototypeIndexOf: (str, ...rest) => String.prototype.indexOf.apply(str, rest),\n  StringPrototypeRepeat: (str, ...rest) => String.prototype.repeat.apply(str, rest),\n  StringPrototypeReplace: (str, ...rest) => String.prototype.replace.apply(str, rest),\n  StringPrototypeSlice: (str, ...rest) => String.prototype.slice.apply(str, rest),\n  StringPrototypeSplit: (str, ...rest) => String.prototype.split.apply(str, rest),\n  StringPrototypeStartsWith: (str, ...rest) => String.prototype.startsWith.apply(str, rest),\n  StringPrototypeSubstr: (str, ...rest) => String.prototype.substr.apply(str, rest),\n  StringPrototypeCharCodeAt: (str, ...rest) => String.prototype.charCodeAt.apply(str, rest),\n  StringPrototypeMatch: (str, ...rest) => String.prototype.match.apply(str, rest),\n  SyntaxError: SyntaxError\n};\n",
    "dist-raw/node-nativemodule.js": "\n// Node imports this from 'internal/bootstrap/loaders'\nconst Module = require('module');\nconst NativeModule = {\n  canBeRequiredByUsers(specifier) {\n    return Module.builtinModules.includes(specifier)\n  }\n};\nexports.NativeModule = NativeModule;\n",
    "dist-raw/node-internalBinding-fs.js": "const fs = require('fs');\nconst {versionGteLt} = require('../dist/util');\n\n// In node's core, this is implemented in C\n// https://github.com/nodejs/node/blob/v15.3.0/src/node_file.cc#L891-L985\n/**\n * @param {string} path\n * @returns {[] | [string, boolean]}\n */\nfunction internalModuleReadJSON(path) {\n  let string\n  try {\n    string = fs.readFileSync(path, 'utf8')\n  } catch (e) {\n    if (e.code === 'ENOENT') return []\n    throw e\n  }\n  // Node's implementation checks for the presence of relevant keys: main, name, type, exports, imports\n  // Node does this for performance to skip unnecessary parsing.\n  // This would slow us down and, based on our usage, we can skip it.\n  const containsKeys = true\n  return [string, containsKeys]\n}\n\n// In node's core, this is implemented in C\n// https://github.com/nodejs/node/blob/63e7dc1e5c71b70c80ed9eda230991edb00811e2/src/node_file.cc#L987-L1005\n/**\n * @param {string} path\n * @returns {number} 0 = file, 1 = dir, negative = error\n */\nfunction internalModuleStat(path) {\n  const stat = fs.statSync(path, { throwIfNoEntry: false });\n  if(!stat) return -1;\n  if(stat.isFile()) return 0;\n  if(stat.isDirectory()) return 1;\n}\n\n/**\n * @param {string} path\n * @returns {number} 0 = file, 1 = dir, negative = error\n */\nfunction internalModuleStatInefficient(path) {\n  try {\n    const stat = fs.statSync(path);\n    if(stat.isFile()) return 0;\n    if(stat.isDirectory()) return 1;\n  } catch(e) {\n    return -e.errno || -1;\n  }\n}\n\nconst statSupportsThrowIfNoEntry = versionGteLt(process.versions.node, '15.3.0') ||\n  versionGteLt(process.versions.node, '14.17.0', '15.0.0');\n\nmodule.exports = {\n  internalModuleReadJSON,\n  internalModuleStat: statSupportsThrowIfNoEntry ? internalModuleStat : internalModuleStatInefficient\n};\n",
    "dist-raw/node-internal-modules-package_json_reader.js": "// copied from https://github.com/nodejs/node/blob/v15.3.0/lib/internal/modules/package_json_reader.js\n'use strict';\n\nconst { SafeMap } = require('./node-primordials');\nconst { internalModuleReadJSON } = require('./node-internalBinding-fs');\nconst { pathToFileURL } = require('url');\nconst { toNamespacedPath } = require('path');\n// const { getOptionValue } = require('./node-options');\n\nconst cache = new SafeMap();\n\nlet manifest;\n\n/**\n * @param {string} jsonPath\n * @return {{string: string, containsKeys: boolean}}\n */\nfunction read(jsonPath) {\n  if (cache.has(jsonPath)) {\n    return cache.get(jsonPath);\n  }\n\n  const [string, containsKeys] = internalModuleReadJSON(\n    toNamespacedPath(jsonPath)\n  );\n  const result = { string, containsKeys };\n  if (string !== undefined) {\n    if (manifest === undefined) {\n      // manifest = getOptionValue('--experimental-policy') ?\n      //   require('internal/process/policy').manifest :\n      //   null;\n      // disabled for now.  I am not sure if/how we should support this\n      manifest = null;\n    }\n    if (manifest !== null) {\n      const jsonURL = pathToFileURL(jsonPath);\n      manifest.assertIntegrity(jsonURL, string);\n    }\n  }\n  cache.set(jsonPath, result);\n  return result;\n}\n\nmodule.exports = { read };\n",
    "dist-raw/node-internal-modules-cjs-helpers.js": "// Copied from https://github.com/nodejs/node/blob/v17.0.1/lib/internal/modules/cjs/helpers.js\n\n'use strict';\n\nconst {\n  ArrayPrototypeForEach,\n  ObjectDefineProperty,\n  ObjectPrototypeHasOwnProperty,\n  SafeSet,\n  StringPrototypeIncludes,\n  StringPrototypeStartsWith,\n} = require('./node-primordials');\n\nconst { getOptionValue } = require('./node-options');\nconst userConditions = getOptionValue('--conditions');\n\nconst noAddons = getOptionValue('--no-addons');\nconst addonConditions = noAddons ? [] : ['node-addons'];\n\n// TODO: Use this set when resolving pkg#exports conditions in loader.js.\nconst cjsConditions = new SafeSet([\n  'require',\n  'node',\n  ...addonConditions,\n  ...userConditions,\n]);\n\n/**\n * @param {any} object\n * @param {string} [dummyModuleName]\n * @return {void}\n */\nfunction addBuiltinLibsToObject(object, dummyModuleName) {\n  // Make built-in modules available directly (loaded lazily).\n  const Module = require('module').Module;\n  const { builtinModules } = Module;\n\n  // To require built-in modules in user-land and ignore modules whose\n  // `canBeRequiredByUsers` is false. So we create a dummy module object and not\n  // use `require()` directly.\n  const dummyModule = new Module(dummyModuleName);\n\n  ArrayPrototypeForEach(builtinModules, (name) => {\n    // Neither add underscored modules, nor ones that contain slashes (e.g.,\n    // 'fs/promises') or ones that are already defined.\n    if (StringPrototypeStartsWith(name, '_') ||\n        StringPrototypeIncludes(name, '/') ||\n        ObjectPrototypeHasOwnProperty(object, name)) {\n      return;\n    }\n    // Goals of this mechanism are:\n    // - Lazy loading of built-in modules\n    // - Having all built-in modules available as non-enumerable properties\n    // - Allowing the user to re-assign these variables as if there were no\n    //   pre-existing globals with the same name.\n\n    const setReal = (val) => {\n      // Deleting the property before re-assigning it disables the\n      // getter/setter mechanism.\n      delete object[name];\n      object[name] = val;\n    };\n\n    ObjectDefineProperty(object, name, {\n      get: () => {\n        // Node 12 hack; remove when we drop node12 support\n        const lib = (dummyModule.require || require)(name);\n\n        // Disable the current getter/setter and set up a new\n        // non-enumerable property.\n        delete object[name];\n        ObjectDefineProperty(object, name, {\n          get: () => lib,\n          set: setReal,\n          configurable: true,\n          enumerable: false\n        });\n\n        return lib;\n      },\n      set: setReal,\n      configurable: true,\n      enumerable: false\n    });\n  });\n}\n\nexports.addBuiltinLibsToObject = addBuiltinLibsToObject;\nexports.cjsConditions = cjsConditions;\n",
    "dist-raw/node-options.js": "// Replacement for node's internal 'internal/options' module\n\nexports.getOptionValue = getOptionValue;\nfunction getOptionValue(opt) {\n  parseOptions();\n  return options[opt];\n}\n\nlet options;\nfunction parseOptions() {\n  if (!options) {\n    options = {\n      '--preserve-symlinks': false,\n      '--preserve-symlinks-main': false,\n      '--input-type': undefined,\n      '--experimental-specifier-resolution': 'explicit',\n      '--experimental-policy': undefined,\n      '--conditions': [],\n      '--pending-deprecation': false,\n      ...parseArgv(getNodeOptionsEnvArgv()),\n      ...parseArgv(process.execArgv),\n      ...getOptionValuesFromOtherEnvVars()\n    }\n  }\n}\n\nfunction parseArgv(argv) {\n  return require('arg')({\n    '--preserve-symlinks': Boolean,\n    '--preserve-symlinks-main': Boolean,\n    '--input-type': String,\n    '--experimental-specifier-resolution': String,\n    // Legacy alias for node versions prior to 12.16\n    '--es-module-specifier-resolution': '--experimental-specifier-resolution',\n    '--experimental-policy': String,\n    '--conditions': [String],\n    '--pending-deprecation': Boolean,\n    '--experimental-json-modules': Boolean,\n    '--experimental-wasm-modules': Boolean,\n  }, {\n    argv,\n    permissive: true\n  });\n}\n\nfunction getNodeOptionsEnvArgv() {\n  const errors = [];\n  const envArgv = ParseNodeOptionsEnvVar(process.env.NODE_OPTIONS || '', errors);\n  if (errors.length !== 0) {\n    // TODO: handle errors somehow\n  }\n  return envArgv;\n}\n\n// Direct JS port of C implementation: https://github.com/nodejs/node/blob/67ba825037b4082d5d16f922fb9ce54516b4a869/src/node_options.cc#L1024-L1063\nfunction ParseNodeOptionsEnvVar(node_options, errors) {\n  const env_argv = [];\n\n  let is_in_string = false;\n  let will_start_new_arg = true;\n  for (let index = 0; index < node_options.length; ++index) {\n      let c = node_options[index];\n\n      // Backslashes escape the following character\n      if (c === '\\\\' && is_in_string) {\n          if (index + 1 === node_options.length) {\n              errors.push(\"invalid value for NODE_OPTIONS \" +\n                  \"(invalid escape)\\n\");\n              return env_argv;\n          } else {\n              c = node_options[++index];\n          }\n      } else if (c === ' ' && !is_in_string) {\n          will_start_new_arg = true;\n          continue;\n      } else if (c === '\"') {\n          is_in_string = !is_in_string;\n          continue;\n      }\n\n      if (will_start_new_arg) {\n          env_argv.push(c);\n          will_start_new_arg = false;\n      } else {\n          env_argv[env_argv.length - 1] += c;\n      }\n  }\n\n  if (is_in_string) {\n      errors.push(\"invalid value for NODE_OPTIONS \" +\n          \"(unterminated string)\\n\");\n  }\n  return env_argv;\n}\n\n// Get option values that can be specified via env vars besides NODE_OPTIONS\nfunction getOptionValuesFromOtherEnvVars() {\n  const options = {};\n  if(process.env.NODE_PENDING_DEPRECATION === '1') {\n    options['--pending-deprecation'] = true;\n  }\n  return options;\n}\n",
    "dist-raw/node-internal-errors.js": "'use strict';\n\nconst path = require('path');\n\nexports.codes = {\n  ERR_INPUT_TYPE_NOT_ALLOWED: createErrorCtor(joinArgs('ERR_INPUT_TYPE_NOT_ALLOWED')),\n  ERR_INVALID_ARG_VALUE: createErrorCtor(joinArgs('ERR_INVALID_ARG_VALUE')),\n  ERR_INVALID_MODULE_SPECIFIER: createErrorCtor(joinArgs('ERR_INVALID_MODULE_SPECIFIER')),\n  ERR_INVALID_PACKAGE_CONFIG: createErrorCtor(joinArgs('ERR_INVALID_PACKAGE_CONFIG')),\n  ERR_INVALID_PACKAGE_TARGET: createErrorCtor(joinArgs('ERR_INVALID_PACKAGE_TARGET')),\n  ERR_MANIFEST_DEPENDENCY_MISSING: createErrorCtor(joinArgs('ERR_MANIFEST_DEPENDENCY_MISSING')),\n  ERR_MODULE_NOT_FOUND: createErrorCtor((path, base, type = 'package') => {\n    return `Cannot find ${type} '${path}' imported from ${base}`\n  }),\n  ERR_PACKAGE_IMPORT_NOT_DEFINED: createErrorCtor(joinArgs('ERR_PACKAGE_IMPORT_NOT_DEFINED')),\n  ERR_PACKAGE_PATH_NOT_EXPORTED: createErrorCtor(joinArgs('ERR_PACKAGE_PATH_NOT_EXPORTED')),\n  ERR_UNSUPPORTED_DIR_IMPORT: createErrorCtor(joinArgs('ERR_UNSUPPORTED_DIR_IMPORT')),\n  ERR_UNSUPPORTED_ESM_URL_SCHEME: createErrorCtor(joinArgs('ERR_UNSUPPORTED_ESM_URL_SCHEME')),\n  ERR_UNKNOWN_FILE_EXTENSION: createErrorCtor(joinArgs('ERR_UNKNOWN_FILE_EXTENSION')),\n}\n\nfunction joinArgs(name) {\n  return (...args) => {\n    return [name, ...args].join(' ')\n  }\n}\n\nfunction createErrorCtor(errorMessageCreator) {\n  return class CustomError extends Error {\n    constructor(...args) {\n      super(errorMessageCreator(...args))\n    }\n  }\n}\nexports.createErrRequireEsm = createErrRequireEsm;\n\n// Native ERR_REQUIRE_ESM Error is declared here:\n//   https://github.com/nodejs/node/blob/2d5d77306f6dff9110c1f77fefab25f973415770/lib/internal/errors.js#L1294-L1313\n// Error class factory is implemented here:\n//   function E: https://github.com/nodejs/node/blob/2d5d77306f6dff9110c1f77fefab25f973415770/lib/internal/errors.js#L323-L341\n//   function makeNodeErrorWithCode: https://github.com/nodejs/node/blob/2d5d77306f6dff9110c1f77fefab25f973415770/lib/internal/errors.js#L251-L278\n// The code below should create an error that matches the native error as closely as possible.\n// Third-party libraries which attempt to catch the native ERR_REQUIRE_ESM should recognize our imitation error.\nfunction createErrRequireEsm(filename, parentPath, packageJsonPath) {\n  const code = 'ERR_REQUIRE_ESM'\n  const err = new Error(getErrRequireEsmMessage(filename, parentPath, packageJsonPath))\n  // Set `name` to be used in stack trace, generate stack trace with that name baked in, then re-declare the `name` field.\n  // This trick is copied from node's source.\n  err.name = `Error [${ code }]`\n  err.stack\n  Object.defineProperty(err, 'name', {\n    value: 'Error',\n    enumerable: false,\n    writable: true,\n    configurable: true\n  })\n  err.code = code\n  return err\n}\n\n// Copy-pasted from https://github.com/nodejs/node/blob/b533fb3508009e5f567cc776daba8fbf665386a6/lib/internal/errors.js#L1293-L1311\n// so that our error message is identical to the native message.\nfunction getErrRequireEsmMessage(filename, parentPath = null, packageJsonPath = null) {\n  const ext = path.extname(filename)\n  let msg = `Must use import to load ES Module: ${filename}`;\n  if (parentPath && packageJsonPath) {\n    const path = require('path');\n    const basename = path.basename(filename) === path.basename(parentPath) ?\n      filename : path.basename(filename);\n    msg +=\n      '\\nrequire() of ES modules is not supported.\\nrequire() of ' +\n      `${filename} ${parentPath ? `from ${parentPath} ` : ''}` +\n      `is an ES module file as it is a ${ext} file whose nearest parent ` +\n      `package.json contains \"type\": \"module\" which defines all ${ext} ` +\n      'files in that package scope as ES modules.\\nInstead ' +\n      'change the requiring code to use ' +\n      'import(), or remove \"type\": \"module\" from ' +\n      `${packageJsonPath}.\\n`;\n    return msg;\n  }\n  return msg;\n}\n",
    "dist-raw/node-internal-constants.js": "// Copied from https://github.com/nodejs/node/blob/master/lib/internal/constants.js\nmodule.exports = {\n  CHAR_FORWARD_SLASH: 47, /* / */\n};\n"
  },
  "externals": [
    "path",
    "module",
    "util",
    "url",
    "make-error",
    "@cspotcode/source-map-support",
    "yn",
    "create-require",
    "os",
    "repl",
    "vm",
    "fs",
    "console",
    "assert",
    "diff",
    "@tsconfig/node16/tsconfig.json",
    "@tsconfig/node14/tsconfig.json",
    "@tsconfig/node12/tsconfig.json",
    "@tsconfig/node10/tsconfig.json",
    "acorn",
    "acorn-walk",
    "arg"
  ]
}
