{
  "packageName": "postcss-import",
  "packageVersion": "15.1.0",
  "request": "postcss-import",
  "resolved": "index.js",
  "files": {
    "index.js": "\"use strict\"\n// builtin tooling\nconst path = require(\"path\")\n\n// internal tooling\nconst joinMedia = require(\"./lib/join-media\")\nconst joinLayer = require(\"./lib/join-layer\")\nconst resolveId = require(\"./lib/resolve-id\")\nconst loadContent = require(\"./lib/load-content\")\nconst processContent = require(\"./lib/process-content\")\nconst parseStatements = require(\"./lib/parse-statements\")\nconst assignLayerNames = require(\"./lib/assign-layer-names\")\nconst dataURL = require(\"./lib/data-url\")\n\nfunction AtImport(options) {\n  options = {\n    root: process.cwd(),\n    path: [],\n    skipDuplicates: true,\n    resolve: resolveId,\n    load: loadContent,\n    plugins: [],\n    addModulesDirectories: [],\n    nameLayer: null,\n    ...options,\n  }\n\n  options.root = path.resolve(options.root)\n\n  // convert string to an array of a single element\n  if (typeof options.path === \"string\") options.path = [options.path]\n\n  if (!Array.isArray(options.path)) options.path = []\n\n  options.path = options.path.map(p => path.resolve(options.root, p))\n\n  return {\n    postcssPlugin: \"postcss-import\",\n    Once(styles, { result, atRule, postcss }) {\n      const state = {\n        importedFiles: {},\n        hashFiles: {},\n        rootFilename: null,\n        anonymousLayerCounter: 0,\n      }\n\n      if (styles.source?.input?.file) {\n        state.rootFilename = styles.source.input.file\n        state.importedFiles[styles.source.input.file] = {}\n      }\n\n      if (options.plugins && !Array.isArray(options.plugins)) {\n        throw new Error(\"plugins option must be an array\")\n      }\n\n      if (options.nameLayer && typeof options.nameLayer !== \"function\") {\n        throw new Error(\"nameLayer option must be a function\")\n      }\n\n      return parseStyles(result, styles, options, state, [], []).then(\n        bundle => {\n          applyRaws(bundle)\n          applyMedia(bundle)\n          applyStyles(bundle, styles)\n        }\n      )\n\n      function applyRaws(bundle) {\n        bundle.forEach((stmt, index) => {\n          if (index === 0) return\n\n          if (stmt.parent) {\n            const { before } = stmt.parent.node.raws\n            if (stmt.type === \"nodes\") stmt.nodes[0].raws.before = before\n            else stmt.node.raws.before = before\n          } else if (stmt.type === \"nodes\") {\n            stmt.nodes[0].raws.before = stmt.nodes[0].raws.before || \"\\n\"\n          }\n        })\n      }\n\n      function applyMedia(bundle) {\n        bundle.forEach(stmt => {\n          if (\n            (!stmt.media.length && !stmt.layer.length) ||\n            stmt.type === \"charset\"\n          ) {\n            return\n          }\n\n          if (stmt.layer.length > 1) {\n            assignLayerNames(stmt.layer, stmt.node, state, options)\n          }\n\n          if (stmt.type === \"import\") {\n            const parts = [stmt.fullUri]\n\n            const media = stmt.media.join(\", \")\n\n            if (stmt.layer.length) {\n              const layerName = stmt.layer.join(\".\")\n\n              let layerParams = \"layer\"\n              if (layerName) {\n                layerParams = `layer(${layerName})`\n              }\n\n              parts.push(layerParams)\n            }\n\n            if (media) {\n              parts.push(media)\n            }\n\n            stmt.node.params = parts.join(\" \")\n          } else if (stmt.type === \"media\") {\n            if (stmt.layer.length) {\n              const layerNode = atRule({\n                name: \"layer\",\n                params: stmt.layer.join(\".\"),\n                source: stmt.node.source,\n              })\n\n              if (stmt.parentMedia?.length) {\n                const mediaNode = atRule({\n                  name: \"media\",\n                  params: stmt.parentMedia.join(\", \"),\n                  source: stmt.node.source,\n                })\n\n                mediaNode.append(layerNode)\n                layerNode.append(stmt.node)\n                stmt.node = mediaNode\n              } else {\n                layerNode.append(stmt.node)\n                stmt.node = layerNode\n              }\n            } else {\n              stmt.node.params = stmt.media.join(\", \")\n            }\n          } else {\n            const { nodes } = stmt\n            const { parent } = nodes[0]\n\n            let outerAtRule\n            let innerAtRule\n            if (stmt.media.length && stmt.layer.length) {\n              const mediaNode = atRule({\n                name: \"media\",\n                params: stmt.media.join(\", \"),\n                source: parent.source,\n              })\n\n              const layerNode = atRule({\n                name: \"layer\",\n                params: stmt.layer.join(\".\"),\n                source: parent.source,\n              })\n\n              mediaNode.append(layerNode)\n              innerAtRule = layerNode\n              outerAtRule = mediaNode\n            } else if (stmt.media.length) {\n              const mediaNode = atRule({\n                name: \"media\",\n                params: stmt.media.join(\", \"),\n                source: parent.source,\n              })\n\n              innerAtRule = mediaNode\n              outerAtRule = mediaNode\n            } else if (stmt.layer.length) {\n              const layerNode = atRule({\n                name: \"layer\",\n                params: stmt.layer.join(\".\"),\n                source: parent.source,\n              })\n\n              innerAtRule = layerNode\n              outerAtRule = layerNode\n            }\n\n            parent.insertBefore(nodes[0], outerAtRule)\n\n            // remove nodes\n            nodes.forEach(node => {\n              node.parent = undefined\n            })\n\n            // better output\n            nodes[0].raws.before = nodes[0].raws.before || \"\\n\"\n\n            // wrap new rules with media query and/or layer at rule\n            innerAtRule.append(nodes)\n\n            stmt.type = \"media\"\n            stmt.node = outerAtRule\n            delete stmt.nodes\n          }\n        })\n      }\n\n      function applyStyles(bundle, styles) {\n        styles.nodes = []\n\n        // Strip additional statements.\n        bundle.forEach(stmt => {\n          if ([\"charset\", \"import\", \"media\"].includes(stmt.type)) {\n            stmt.node.parent = undefined\n            styles.append(stmt.node)\n          } else if (stmt.type === \"nodes\") {\n            stmt.nodes.forEach(node => {\n              node.parent = undefined\n              styles.append(node)\n            })\n          }\n        })\n      }\n\n      function parseStyles(result, styles, options, state, media, layer) {\n        const statements = parseStatements(result, styles)\n\n        return Promise.resolve(statements)\n          .then(stmts => {\n            // process each statement in series\n            return stmts.reduce((promise, stmt) => {\n              return promise.then(() => {\n                stmt.media = joinMedia(media, stmt.media || [])\n                stmt.parentMedia = media\n                stmt.layer = joinLayer(layer, stmt.layer || [])\n\n                // skip protocol base uri (protocol://url) or protocol-relative\n                if (\n                  stmt.type !== \"import\" ||\n                  /^(?:[a-z]+:)?\\/\\//i.test(stmt.uri)\n                ) {\n                  return\n                }\n\n                if (options.filter && !options.filter(stmt.uri)) {\n                  // rejected by filter\n                  return\n                }\n\n                return resolveImportId(result, stmt, options, state)\n              })\n            }, Promise.resolve())\n          })\n          .then(() => {\n            let charset\n            const imports = []\n            const bundle = []\n\n            function handleCharset(stmt) {\n              if (!charset) charset = stmt\n              // charsets aren't case-sensitive, so convert to lower case to compare\n              else if (\n                stmt.node.params.toLowerCase() !==\n                charset.node.params.toLowerCase()\n              ) {\n                throw new Error(\n                  `Incompatable @charset statements:\n  ${stmt.node.params} specified in ${stmt.node.source.input.file}\n  ${charset.node.params} specified in ${charset.node.source.input.file}`\n                )\n              }\n            }\n\n            // squash statements and their children\n            statements.forEach(stmt => {\n              if (stmt.type === \"charset\") handleCharset(stmt)\n              else if (stmt.type === \"import\") {\n                if (stmt.children) {\n                  stmt.children.forEach((child, index) => {\n                    if (child.type === \"import\") imports.push(child)\n                    else if (child.type === \"charset\") handleCharset(child)\n                    else bundle.push(child)\n                    // For better output\n                    if (index === 0) child.parent = stmt\n                  })\n                } else imports.push(stmt)\n              } else if (stmt.type === \"media\" || stmt.type === \"nodes\") {\n                bundle.push(stmt)\n              }\n            })\n\n            return charset\n              ? [charset, ...imports.concat(bundle)]\n              : imports.concat(bundle)\n          })\n      }\n\n      function resolveImportId(result, stmt, options, state) {\n        if (dataURL.isValid(stmt.uri)) {\n          return loadImportContent(result, stmt, stmt.uri, options, state).then(\n            result => {\n              stmt.children = result\n            }\n          )\n        }\n\n        const atRule = stmt.node\n        let sourceFile\n        if (atRule.source?.input?.file) {\n          sourceFile = atRule.source.input.file\n        }\n        const base = sourceFile\n          ? path.dirname(atRule.source.input.file)\n          : options.root\n\n        return Promise.resolve(options.resolve(stmt.uri, base, options))\n          .then(paths => {\n            if (!Array.isArray(paths)) paths = [paths]\n            // Ensure that each path is absolute:\n            return Promise.all(\n              paths.map(file => {\n                return !path.isAbsolute(file)\n                  ? resolveId(file, base, options)\n                  : file\n              })\n            )\n          })\n          .then(resolved => {\n            // Add dependency messages:\n            resolved.forEach(file => {\n              result.messages.push({\n                type: \"dependency\",\n                plugin: \"postcss-import\",\n                file,\n                parent: sourceFile,\n              })\n            })\n\n            return Promise.all(\n              resolved.map(file => {\n                return loadImportContent(result, stmt, file, options, state)\n              })\n            )\n          })\n          .then(result => {\n            // Merge loaded statements\n            stmt.children = result.reduce((result, statements) => {\n              return statements ? result.concat(statements) : result\n            }, [])\n          })\n      }\n\n      function loadImportContent(result, stmt, filename, options, state) {\n        const atRule = stmt.node\n        const { media, layer } = stmt\n\n        assignLayerNames(layer, atRule, state, options)\n\n        if (options.skipDuplicates) {\n          // skip files already imported at the same scope\n          if (state.importedFiles[filename]?.[media]?.[layer]) {\n            return\n          }\n\n          // save imported files to skip them next time\n          if (!state.importedFiles[filename]) {\n            state.importedFiles[filename] = {}\n          }\n          if (!state.importedFiles[filename][media]) {\n            state.importedFiles[filename][media] = {}\n          }\n          state.importedFiles[filename][media][layer] = true\n        }\n\n        return Promise.resolve(options.load(filename, options)).then(\n          content => {\n            if (content.trim() === \"\") {\n              result.warn(`${filename} is empty`, { node: atRule })\n              return\n            }\n\n            // skip previous imported files not containing @import rules\n            if (state.hashFiles[content]?.[media]?.[layer]) {\n              return\n            }\n\n            return processContent(\n              result,\n              content,\n              filename,\n              options,\n              postcss\n            ).then(importedResult => {\n              const styles = importedResult.root\n              result.messages = result.messages.concat(importedResult.messages)\n\n              if (options.skipDuplicates) {\n                const hasImport = styles.some(child => {\n                  return child.type === \"atrule\" && child.name === \"import\"\n                })\n                if (!hasImport) {\n                  // save hash files to skip them next time\n                  if (!state.hashFiles[content]) {\n                    state.hashFiles[content] = {}\n                  }\n                  if (!state.hashFiles[content][media]) {\n                    state.hashFiles[content][media] = {}\n                  }\n                  state.hashFiles[content][media][layer] = true\n                }\n              }\n\n              // recursion: import @import from imported file\n              return parseStyles(result, styles, options, state, media, layer)\n            })\n          }\n        )\n      }\n    },\n  }\n}\n\nAtImport.postcss = true\n\nmodule.exports = AtImport\n",
    "package.json": "{\n  \"name\": \"postcss-import\",\n  \"version\": \"15.1.0\",\n  \"description\": \"PostCSS plugin to import CSS files\",\n  \"keywords\": [\n    \"css\",\n    \"postcss\",\n    \"postcss-plugin\",\n    \"import\",\n    \"node modules\",\n    \"npm\"\n  ],\n  \"author\": \"Maxime Thirouin\",\n  \"license\": \"MIT\",\n  \"repository\": \"https://github.com/postcss/postcss-import.git\",\n  \"files\": [\n    \"index.js\",\n    \"lib\"\n  ],\n  \"engines\": {\n    \"node\": \">=14.0.0\"\n  },\n  \"dependencies\": {\n    \"postcss-value-parser\": \"^4.0.0\",\n    \"read-cache\": \"^1.0.0\",\n    \"resolve\": \"^1.1.7\"\n  },\n  \"devDependencies\": {\n    \"ava\": \"^5.0.0\",\n    \"eslint\": \"^8.2.0\",\n    \"eslint-config-problems\": \"^7.0.0\",\n    \"eslint-plugin-prettier\": \"^4.0.0\",\n    \"postcss\": \"^8.0.0\",\n    \"postcss-scss\": \"^4.0.0\",\n    \"prettier\": \"~2.8.0\",\n    \"sugarss\": \"^4.0.0\"\n  },\n  \"peerDependencies\": {\n    \"postcss\": \"^8.0.0\"\n  },\n  \"scripts\": {\n    \"ci\": \"eslint . && ava\",\n    \"lint\": \"eslint . --fix\",\n    \"pretest\": \"npm run lint\",\n    \"test\": \"ava\"\n  },\n  \"eslintConfig\": {\n    \"extends\": \"eslint-config-problems\",\n    \"env\": {\n      \"node\": true\n    },\n    \"plugins\": [\n      \"prettier\"\n    ],\n    \"rules\": {\n      \"prettier/prettier\": [\n        \"error\",\n        {\n          \"semi\": false,\n          \"arrowParens\": \"avoid\"\n        }\n      ]\n    }\n  }\n}\n",
    "lib/join-media.js": "\"use strict\"\n\nconst startsWithKeywordRegexp = /^(all|not|only|print|screen)/i\n\nmodule.exports = function (parentMedia, childMedia) {\n  if (!parentMedia.length && childMedia.length) return childMedia\n  if (parentMedia.length && !childMedia.length) return parentMedia\n  if (!parentMedia.length && !childMedia.length) return []\n\n  const media = []\n\n  parentMedia.forEach(parentItem => {\n    const parentItemStartsWithKeyword = startsWithKeywordRegexp.test(parentItem)\n\n    childMedia.forEach(childItem => {\n      const childItemStartsWithKeyword = startsWithKeywordRegexp.test(childItem)\n      if (parentItem !== childItem) {\n        if (childItemStartsWithKeyword && !parentItemStartsWithKeyword) {\n          media.push(`${childItem} and ${parentItem}`)\n        } else {\n          media.push(`${parentItem} and ${childItem}`)\n        }\n      }\n    })\n  })\n\n  return media\n}\n",
    "lib/join-layer.js": "\"use strict\"\n\nmodule.exports = function (parentLayer, childLayer) {\n  if (!parentLayer.length && childLayer.length) return childLayer\n  if (parentLayer.length && !childLayer.length) return parentLayer\n  if (!parentLayer.length && !childLayer.length) return []\n\n  return parentLayer.concat(childLayer)\n}\n",
    "lib/resolve-id.js": "\"use strict\"\n\n// external tooling\nconst resolve = require(\"resolve\")\n\nconst moduleDirectories = [\"web_modules\", \"node_modules\"]\n\nfunction resolveModule(id, opts) {\n  return new Promise((res, rej) => {\n    resolve(id, opts, (err, path) => (err ? rej(err) : res(path)))\n  })\n}\n\nmodule.exports = function (id, base, options) {\n  const paths = options.path\n\n  const resolveOpts = {\n    basedir: base,\n    moduleDirectory: moduleDirectories.concat(options.addModulesDirectories),\n    paths,\n    extensions: [\".css\"],\n    packageFilter: function processPackage(pkg) {\n      if (pkg.style) pkg.main = pkg.style\n      else if (!pkg.main || !/\\.css$/.test(pkg.main)) pkg.main = \"index.css\"\n      return pkg\n    },\n    preserveSymlinks: false,\n  }\n\n  return resolveModule(`./${id}`, resolveOpts)\n    .catch(() => resolveModule(id, resolveOpts))\n    .catch(() => {\n      if (paths.indexOf(base) === -1) paths.unshift(base)\n\n      throw new Error(\n        `Failed to find '${id}'\n  in [\n    ${paths.join(\",\\n        \")}\n  ]`\n      )\n    })\n}\n",
    "lib/load-content.js": "\"use strict\"\n\nconst readCache = require(\"read-cache\")\nconst dataURL = require(\"./data-url\")\n\nmodule.exports = filename => {\n  if (dataURL.isValid(filename)) {\n    return dataURL.contents(filename)\n  }\n\n  return readCache(filename, \"utf-8\")\n}\n",
    "lib/process-content.js": "\"use strict\"\n\n// builtin tooling\nconst path = require(\"path\")\n\n// placeholder tooling\nlet sugarss\n\nmodule.exports = function processContent(\n  result,\n  content,\n  filename,\n  options,\n  postcss\n) {\n  const { plugins } = options\n  const ext = path.extname(filename)\n\n  const parserList = []\n\n  // SugarSS support:\n  if (ext === \".sss\") {\n    if (!sugarss) {\n      try {\n        sugarss = require(\"sugarss\")\n      } catch {} // Ignore\n    }\n    if (sugarss)\n      return runPostcss(postcss, content, filename, plugins, [sugarss])\n  }\n\n  // Syntax support:\n  if (result.opts.syntax?.parse) {\n    parserList.push(result.opts.syntax.parse)\n  }\n\n  // Parser support:\n  if (result.opts.parser) parserList.push(result.opts.parser)\n  // Try the default as a last resort:\n  parserList.push(null)\n\n  return runPostcss(postcss, content, filename, plugins, parserList)\n}\n\nfunction runPostcss(postcss, content, filename, plugins, parsers, index) {\n  if (!index) index = 0\n  return postcss(plugins)\n    .process(content, {\n      from: filename,\n      parser: parsers[index],\n    })\n    .catch(err => {\n      // If there's an error, try the next parser\n      index++\n      // If there are no parsers left, throw it\n      if (index === parsers.length) throw err\n      return runPostcss(postcss, content, filename, plugins, parsers, index)\n    })\n}\n",
    "lib/parse-statements.js": "\"use strict\"\n\n// external tooling\nconst valueParser = require(\"postcss-value-parser\")\n\n// extended tooling\nconst { stringify } = valueParser\n\nfunction split(params, start) {\n  const list = []\n  const last = params.reduce((item, node, index) => {\n    if (index < start) return \"\"\n    if (node.type === \"div\" && node.value === \",\") {\n      list.push(item)\n      return \"\"\n    }\n    return item + stringify(node)\n  }, \"\")\n  list.push(last)\n  return list\n}\n\nmodule.exports = function (result, styles) {\n  const statements = []\n  let nodes = []\n\n  styles.each(node => {\n    let stmt\n    if (node.type === \"atrule\") {\n      if (node.name === \"import\") stmt = parseImport(result, node)\n      else if (node.name === \"media\") stmt = parseMedia(result, node)\n      else if (node.name === \"charset\") stmt = parseCharset(result, node)\n    }\n\n    if (stmt) {\n      if (nodes.length) {\n        statements.push({\n          type: \"nodes\",\n          nodes,\n          media: [],\n          layer: [],\n        })\n        nodes = []\n      }\n      statements.push(stmt)\n    } else nodes.push(node)\n  })\n\n  if (nodes.length) {\n    statements.push({\n      type: \"nodes\",\n      nodes,\n      media: [],\n      layer: [],\n    })\n  }\n\n  return statements\n}\n\nfunction parseMedia(result, atRule) {\n  const params = valueParser(atRule.params).nodes\n  return {\n    type: \"media\",\n    node: atRule,\n    media: split(params, 0),\n    layer: [],\n  }\n}\n\nfunction parseCharset(result, atRule) {\n  if (atRule.prev()) {\n    return result.warn(\"@charset must precede all other statements\", {\n      node: atRule,\n    })\n  }\n  return {\n    type: \"charset\",\n    node: atRule,\n    media: [],\n    layer: [],\n  }\n}\n\nfunction parseImport(result, atRule) {\n  let prev = atRule.prev()\n  if (prev) {\n    do {\n      if (\n        prev.type !== \"comment\" &&\n        (prev.type !== \"atrule\" ||\n          (prev.name !== \"import\" &&\n            prev.name !== \"charset\" &&\n            !(prev.name === \"layer\" && !prev.nodes)))\n      ) {\n        return result.warn(\n          \"@import must precede all other statements (besides @charset or empty @layer)\",\n          { node: atRule }\n        )\n      }\n      prev = prev.prev()\n    } while (prev)\n  }\n\n  if (atRule.nodes) {\n    return result.warn(\n      \"It looks like you didn't end your @import statement correctly. \" +\n        \"Child nodes are attached to it.\",\n      { node: atRule }\n    )\n  }\n\n  const params = valueParser(atRule.params).nodes\n  const stmt = {\n    type: \"import\",\n    node: atRule,\n    media: [],\n    layer: [],\n  }\n\n  // prettier-ignore\n  if (\n    !params.length ||\n    (\n      params[0].type !== \"string\" ||\n      !params[0].value\n    ) &&\n    (\n      params[0].type !== \"function\" ||\n      params[0].value !== \"url\" ||\n      !params[0].nodes.length ||\n      !params[0].nodes[0].value\n    )\n  ) {\n    return result.warn(`Unable to find uri in '${  atRule.toString()  }'`, {\n      node: atRule,\n    })\n  }\n\n  if (params[0].type === \"string\") stmt.uri = params[0].value\n  else stmt.uri = params[0].nodes[0].value\n  stmt.fullUri = stringify(params[0])\n\n  let remainder = params\n  if (remainder.length > 2) {\n    if (\n      (remainder[2].type === \"word\" || remainder[2].type === \"function\") &&\n      remainder[2].value === \"layer\"\n    ) {\n      if (remainder[1].type !== \"space\") {\n        return result.warn(\"Invalid import layer statement\", { node: atRule })\n      }\n\n      if (remainder[2].nodes) {\n        stmt.layer = [stringify(remainder[2].nodes)]\n      } else {\n        stmt.layer = [\"\"]\n      }\n      remainder = remainder.slice(2)\n    }\n  }\n\n  if (remainder.length > 2) {\n    if (remainder[1].type !== \"space\") {\n      return result.warn(\"Invalid import media statement\", { node: atRule })\n    }\n\n    stmt.media = split(remainder, 2)\n  }\n\n  return stmt\n}\n",
    "lib/assign-layer-names.js": "\"use strict\"\n\nmodule.exports = function (layer, node, state, options) {\n  layer.forEach((layerPart, i) => {\n    if (layerPart.trim() === \"\") {\n      if (options.nameLayer) {\n        layer[i] = options\n          .nameLayer(state.anonymousLayerCounter++, state.rootFilename)\n          .toString()\n      } else {\n        throw node.error(\n          `When using anonymous layers in @import you must also set the \"nameLayer\" plugin option`\n        )\n      }\n    }\n  })\n}\n",
    "lib/data-url.js": "\"use strict\"\n\nconst dataURLRegexp = /^data:text\\/css;base64,/i\n\nfunction isValid(url) {\n  return dataURLRegexp.test(url)\n}\n\nfunction contents(url) {\n  // \"data:text/css;base64,\".length === 21\n  return Buffer.from(url.slice(21), \"base64\").toString()\n}\n\nmodule.exports = {\n  isValid,\n  contents,\n}\n"
  },
  "externals": [
    "path",
    "resolve",
    "read-cache",
    "postcss-value-parser"
  ]
}
