{
  "packageName": "lilconfig",
  "packageVersion": "2.1.0",
  "request": "lilconfig",
  "resolved": "dist/index.js",
  "files": {
    "dist/index.js": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.lilconfigSync = exports.lilconfig = exports.defaultLoaders = void 0;\nconst path = require(\"path\");\nconst fs = require(\"fs\");\nconst os = require(\"os\");\nconst fsReadFileAsync = fs.promises.readFile;\nfunction getDefaultSearchPlaces(name) {\n    return [\n        'package.json',\n        `.${name}rc.json`,\n        `.${name}rc.js`,\n        `.${name}rc.cjs`,\n        `.config/${name}rc`,\n        `.config/${name}rc.json`,\n        `.config/${name}rc.js`,\n        `.config/${name}rc.cjs`,\n        `${name}.config.js`,\n        `${name}.config.cjs`,\n    ];\n}\nfunction getSearchPaths(startDir, stopDir) {\n    return startDir\n        .split(path.sep)\n        .reduceRight((acc, _, ind, arr) => {\n        const currentPath = arr.slice(0, ind + 1).join(path.sep);\n        if (!acc.passedStopDir)\n            acc.searchPlaces.push(currentPath || path.sep);\n        if (currentPath === stopDir)\n            acc.passedStopDir = true;\n        return acc;\n    }, { searchPlaces: [], passedStopDir: false }).searchPlaces;\n}\nexports.defaultLoaders = Object.freeze({\n    '.js': require,\n    '.json': require,\n    '.cjs': require,\n    noExt(_, content) {\n        return JSON.parse(content);\n    },\n});\nfunction getExtDesc(ext) {\n    return ext === 'noExt' ? 'files without extensions' : `extension \"${ext}\"`;\n}\nfunction getOptions(name, options = {}) {\n    const conf = {\n        stopDir: os.homedir(),\n        searchPlaces: getDefaultSearchPlaces(name),\n        ignoreEmptySearchPlaces: true,\n        transform: (x) => x,\n        packageProp: [name],\n        ...options,\n        loaders: { ...exports.defaultLoaders, ...options.loaders },\n    };\n    conf.searchPlaces.forEach(place => {\n        const key = path.extname(place) || 'noExt';\n        const loader = conf.loaders[key];\n        if (!loader) {\n            throw new Error(`No loader specified for ${getExtDesc(key)}, so searchPlaces item \"${place}\" is invalid`);\n        }\n        if (typeof loader !== 'function') {\n            throw new Error(`loader for ${getExtDesc(key)} is not a function (type provided: \"${typeof loader}\"), so searchPlaces item \"${place}\" is invalid`);\n        }\n    });\n    return conf;\n}\nfunction getPackageProp(props, obj) {\n    if (typeof props === 'string' && props in obj)\n        return obj[props];\n    return ((Array.isArray(props) ? props : props.split('.')).reduce((acc, prop) => (acc === undefined ? acc : acc[prop]), obj) || null);\n}\nfunction getSearchItems(searchPlaces, searchPaths) {\n    return searchPaths.reduce((acc, searchPath) => {\n        searchPlaces.forEach(sp => acc.push({\n            searchPlace: sp,\n            filepath: path.join(searchPath, sp),\n            loaderKey: path.extname(sp) || 'noExt',\n        }));\n        return acc;\n    }, []);\n}\nfunction validateFilePath(filepath) {\n    if (!filepath)\n        throw new Error('load must pass a non-empty string');\n}\nfunction validateLoader(loader, ext) {\n    if (!loader)\n        throw new Error(`No loader specified for extension \"${ext}\"`);\n    if (typeof loader !== 'function')\n        throw new Error('loader is not a function');\n}\nfunction lilconfig(name, options) {\n    const { ignoreEmptySearchPlaces, loaders, packageProp, searchPlaces, stopDir, transform, } = getOptions(name, options);\n    return {\n        async search(searchFrom = process.cwd()) {\n            const searchPaths = getSearchPaths(searchFrom, stopDir);\n            const result = {\n                config: null,\n                filepath: '',\n            };\n            const searchItems = getSearchItems(searchPlaces, searchPaths);\n            for (const { searchPlace, filepath, loaderKey } of searchItems) {\n                try {\n                    await fs.promises.access(filepath);\n                }\n                catch (_a) {\n                    continue;\n                }\n                const content = String(await fsReadFileAsync(filepath));\n                const loader = loaders[loaderKey];\n                if (searchPlace === 'package.json') {\n                    const pkg = await loader(filepath, content);\n                    const maybeConfig = getPackageProp(packageProp, pkg);\n                    if (maybeConfig != null) {\n                        result.config = maybeConfig;\n                        result.filepath = filepath;\n                        break;\n                    }\n                    continue;\n                }\n                const isEmpty = content.trim() === '';\n                if (isEmpty && ignoreEmptySearchPlaces)\n                    continue;\n                if (isEmpty) {\n                    result.isEmpty = true;\n                    result.config = undefined;\n                }\n                else {\n                    validateLoader(loader, loaderKey);\n                    result.config = await loader(filepath, content);\n                }\n                result.filepath = filepath;\n                break;\n            }\n            if (result.filepath === '' && result.config === null)\n                return transform(null);\n            return transform(result);\n        },\n        async load(filepath) {\n            validateFilePath(filepath);\n            const absPath = path.resolve(process.cwd(), filepath);\n            const { base, ext } = path.parse(absPath);\n            const loaderKey = ext || 'noExt';\n            const loader = loaders[loaderKey];\n            validateLoader(loader, loaderKey);\n            const content = String(await fsReadFileAsync(absPath));\n            if (base === 'package.json') {\n                const pkg = await loader(absPath, content);\n                return transform({\n                    config: getPackageProp(packageProp, pkg),\n                    filepath: absPath,\n                });\n            }\n            const result = {\n                config: null,\n                filepath: absPath,\n            };\n            const isEmpty = content.trim() === '';\n            if (isEmpty && ignoreEmptySearchPlaces)\n                return transform({\n                    config: undefined,\n                    filepath: absPath,\n                    isEmpty: true,\n                });\n            result.config = isEmpty\n                ? undefined\n                : await loader(absPath, content);\n            return transform(isEmpty ? { ...result, isEmpty, config: undefined } : result);\n        },\n    };\n}\nexports.lilconfig = lilconfig;\nfunction lilconfigSync(name, options) {\n    const { ignoreEmptySearchPlaces, loaders, packageProp, searchPlaces, stopDir, transform, } = getOptions(name, options);\n    return {\n        search(searchFrom = process.cwd()) {\n            const searchPaths = getSearchPaths(searchFrom, stopDir);\n            const result = {\n                config: null,\n                filepath: '',\n            };\n            const searchItems = getSearchItems(searchPlaces, searchPaths);\n            for (const { searchPlace, filepath, loaderKey } of searchItems) {\n                try {\n                    fs.accessSync(filepath);\n                }\n                catch (_a) {\n                    continue;\n                }\n                const loader = loaders[loaderKey];\n                const content = String(fs.readFileSync(filepath));\n                if (searchPlace === 'package.json') {\n                    const pkg = loader(filepath, content);\n                    const maybeConfig = getPackageProp(packageProp, pkg);\n                    if (maybeConfig != null) {\n                        result.config = maybeConfig;\n                        result.filepath = filepath;\n                        break;\n                    }\n                    continue;\n                }\n                const isEmpty = content.trim() === '';\n                if (isEmpty && ignoreEmptySearchPlaces)\n                    continue;\n                if (isEmpty) {\n                    result.isEmpty = true;\n                    result.config = undefined;\n                }\n                else {\n                    validateLoader(loader, loaderKey);\n                    result.config = loader(filepath, content);\n                }\n                result.filepath = filepath;\n                break;\n            }\n            if (result.filepath === '' && result.config === null)\n                return transform(null);\n            return transform(result);\n        },\n        load(filepath) {\n            validateFilePath(filepath);\n            const absPath = path.resolve(process.cwd(), filepath);\n            const { base, ext } = path.parse(absPath);\n            const loaderKey = ext || 'noExt';\n            const loader = loaders[loaderKey];\n            validateLoader(loader, loaderKey);\n            const content = String(fs.readFileSync(absPath));\n            if (base === 'package.json') {\n                const pkg = loader(absPath, content);\n                return transform({\n                    config: getPackageProp(packageProp, pkg),\n                    filepath: absPath,\n                });\n            }\n            const result = {\n                config: null,\n                filepath: absPath,\n            };\n            const isEmpty = content.trim() === '';\n            if (isEmpty && ignoreEmptySearchPlaces)\n                return transform({\n                    filepath: absPath,\n                    config: undefined,\n                    isEmpty: true,\n                });\n            result.config = isEmpty ? undefined : loader(absPath, content);\n            return transform(isEmpty ? { ...result, isEmpty, config: undefined } : result);\n        },\n    };\n}\nexports.lilconfigSync = lilconfigSync;\n",
    "package.json": "{\n    \"name\": \"lilconfig\",\n    \"version\": \"2.1.0\",\n    \"description\": \"A zero-dependency alternative to cosmiconfig\",\n    \"main\": \"dist/index.js\",\n    \"types\": \"dist/index.d.ts\",\n    \"scripts\": {\n        \"prebuild\": \"npm run clean\",\n        \"build\": \"tsc --declaration\",\n        \"postbuild\": \"du -h ./dist/*\",\n        \"clean\": \"rm -rf ./dist\",\n        \"test\": \"jest --coverage\",\n        \"lint\": \"eslint ./src/*.ts\"\n    },\n    \"keywords\": [\n        \"cosmiconfig\",\n        \"config\",\n        \"configuration\",\n        \"search\"\n    ],\n    \"files\": [\n        \"dist/*\"\n    ],\n    \"repository\": {\n        \"type\": \"git\",\n        \"url\": \"https://github.com/antonk52/lilconfig\"\n    },\n    \"bugs\": \"https://github.com/antonk52/lilconfig/issues\",\n    \"author\": \"antonk52\",\n    \"license\": \"MIT\",\n    \"devDependencies\": {\n        \"@types/jest\": \"^27.0.2\",\n        \"@types/node\": \"^14.18.36\",\n        \"@typescript-eslint/eslint-plugin\": \"^5.54.0\",\n        \"@typescript-eslint/parser\": \"^5.54.0\",\n        \"cosmiconfig\": \"^7.1.0\",\n        \"eslint\": \"^8.35.0\",\n        \"eslint-config-prettier\": \"^8.6.0\",\n        \"eslint-plugin-prettier\": \"^4.2.1\",\n        \"jest\": \"^27.3.1\",\n        \"prettier\": \"^2.8.4\",\n        \"ts-jest\": \"27.0.7\",\n        \"typescript\": \"4.4.4\"\n    },\n    \"engines\": {\n        \"node\": \">=10\"\n    }\n}\n"
  },
  "externals": [
    "path",
    "fs",
    "os"
  ]
}
