{
  "packageName": "update-browserslist-db",
  "packageVersion": "1.0.13",
  "request": "update-browserslist-db",
  "resolved": "index.js",
  "files": {
    "index.js": "let { existsSync, readFileSync, writeFileSync } = require('fs')\nlet { execSync } = require('child_process')\nlet { join } = require('path')\nlet escalade = require('escalade/sync')\nlet pico = require('picocolors')\n\nconst { detectEOL, detectIndent } = require('./utils')\n\nfunction BrowserslistUpdateError(message) {\n  this.name = 'BrowserslistUpdateError'\n  this.message = message\n  this.browserslist = true\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, BrowserslistUpdateError)\n  }\n}\n\nBrowserslistUpdateError.prototype = Error.prototype\n\n/* c8 ignore next 3 */\nfunction defaultPrint(str) {\n  process.stdout.write(str)\n}\n\nfunction detectLockfile() {\n  let packageDir = escalade('.', (dir, names) => {\n    return names.indexOf('package.json') !== -1 ? dir : ''\n  })\n\n  if (!packageDir) {\n    throw new BrowserslistUpdateError(\n      'Cannot find package.json. ' +\n        'Is this the right directory to run `npx update-browserslist-db` in?'\n    )\n  }\n\n  let lockfileNpm = join(packageDir, 'package-lock.json')\n  let lockfileShrinkwrap = join(packageDir, 'npm-shrinkwrap.json')\n  let lockfileYarn = join(packageDir, 'yarn.lock')\n  let lockfilePnpm = join(packageDir, 'pnpm-lock.yaml')\n\n  if (existsSync(lockfilePnpm)) {\n    return { file: lockfilePnpm, mode: 'pnpm' }\n  } else if (existsSync(lockfileNpm)) {\n    return { file: lockfileNpm, mode: 'npm' }\n  } else if (existsSync(lockfileYarn)) {\n    let lock = { file: lockfileYarn, mode: 'yarn' }\n    lock.content = readFileSync(lock.file).toString()\n    lock.version = /# yarn lockfile v1/.test(lock.content) ? 1 : 2\n    return lock\n  } else if (existsSync(lockfileShrinkwrap)) {\n    return { file: lockfileShrinkwrap, mode: 'npm' }\n  }\n  throw new BrowserslistUpdateError(\n    'No lockfile found. Run \"npm install\", \"yarn install\" or \"pnpm install\"'\n  )\n}\n\nfunction getLatestInfo(lock) {\n  if (lock.mode === 'yarn') {\n    if (lock.version === 1) {\n      return JSON.parse(execSync('yarnpkg info caniuse-lite --json').toString())\n        .data\n    } else {\n      return JSON.parse(\n        execSync('yarnpkg npm info caniuse-lite --json').toString()\n      )\n    }\n  }\n  if (lock.mode === 'pnpm') {\n    return JSON.parse(execSync('pnpm info caniuse-lite --json').toString())\n  }\n  return JSON.parse(execSync('npm show caniuse-lite --json').toString())\n}\n\nfunction getBrowsers() {\n  let browserslist = require('browserslist')\n  return browserslist().reduce((result, entry) => {\n    if (!result[entry[0]]) {\n      result[entry[0]] = []\n    }\n    result[entry[0]].push(entry[1])\n    return result\n  }, {})\n}\n\nfunction diffBrowsers(old, current) {\n  let browsers = Object.keys(old).concat(\n    Object.keys(current).filter(browser => old[browser] === undefined)\n  )\n  return browsers\n    .map(browser => {\n      let oldVersions = old[browser] || []\n      let currentVersions = current[browser] || []\n      let common = oldVersions.filter(v => currentVersions.includes(v))\n      let added = currentVersions.filter(v => !common.includes(v))\n      let removed = oldVersions.filter(v => !common.includes(v))\n      return removed\n        .map(v => pico.red('- ' + browser + ' ' + v))\n        .concat(added.map(v => pico.green('+ ' + browser + ' ' + v)))\n    })\n    .reduce((result, array) => result.concat(array), [])\n    .join('\\n')\n}\n\nfunction updateNpmLockfile(lock, latest) {\n  let metadata = { latest, versions: [] }\n  let content = deletePackage(JSON.parse(lock.content), metadata)\n  metadata.content = JSON.stringify(content, null, detectIndent(lock.content))\n  return metadata\n}\n\nfunction deletePackage(node, metadata) {\n  if (node.dependencies) {\n    if (node.dependencies['caniuse-lite']) {\n      let version = node.dependencies['caniuse-lite'].version\n      metadata.versions[version] = true\n      delete node.dependencies['caniuse-lite']\n    }\n    for (let i in node.dependencies) {\n      node.dependencies[i] = deletePackage(node.dependencies[i], metadata)\n    }\n  }\n  if (node.packages) {\n    for (let path in node.packages) {\n      if (path.endsWith('/caniuse-lite')) {\n        metadata.versions[node.packages[path].version] = true\n        delete node.packages[path]\n      }\n    }\n  }\n  return node\n}\n\nlet yarnVersionRe = /version \"(.*?)\"/\n\nfunction updateYarnLockfile(lock, latest) {\n  let blocks = lock.content.split(/(\\n{2,})/).map(block => {\n    return block.split('\\n')\n  })\n  let versions = {}\n  blocks.forEach(lines => {\n    if (lines[0].indexOf('caniuse-lite@') !== -1) {\n      let match = yarnVersionRe.exec(lines[1])\n      versions[match[1]] = true\n      if (match[1] !== latest.version) {\n        lines[1] = lines[1].replace(\n          /version \"[^\"]+\"/,\n          'version \"' + latest.version + '\"'\n        )\n        lines[2] = lines[2].replace(\n          /resolved \"[^\"]+\"/,\n          'resolved \"' + latest.dist.tarball + '\"'\n        )\n        if (lines.length === 4) {\n          lines[3] = latest.dist.integrity\n            ? lines[3].replace(\n                /integrity .+/,\n                'integrity ' + latest.dist.integrity\n              )\n            : ''\n        }\n      }\n    }\n  })\n  let content = blocks.map(lines => lines.join('\\n')).join('')\n  return { content, versions }\n}\n\nfunction updateLockfile(lock, latest) {\n  if (!lock.content) lock.content = readFileSync(lock.file).toString()\n\n  let updatedLockFile\n  if (lock.mode === 'yarn') {\n    updatedLockFile = updateYarnLockfile(lock, latest)\n  } else {\n    updatedLockFile = updateNpmLockfile(lock, latest)\n  }\n  updatedLockFile.content = updatedLockFile.content.replace(\n    /\\n/g,\n    detectEOL(lock.content)\n  )\n  return updatedLockFile\n}\n\nfunction updatePackageManually(print, lock, latest) {\n  let lockfileData = updateLockfile(lock, latest)\n  let caniuseVersions = Object.keys(lockfileData.versions).sort()\n  if (caniuseVersions.length === 1 && caniuseVersions[0] === latest.version) {\n    print(\n      'Installed version:  ' +\n        pico.bold(pico.green(caniuseVersions[0])) +\n        '\\n' +\n        pico.bold(pico.green('caniuse-lite is up to date')) +\n        '\\n'\n    )\n    return\n  }\n\n  if (caniuseVersions.length === 0) {\n    caniuseVersions[0] = 'none'\n  }\n  print(\n    'Installed version' +\n      (caniuseVersions.length === 1 ? ':  ' : 's: ') +\n      pico.bold(pico.red(caniuseVersions.join(', '))) +\n      '\\n' +\n      'Removing old caniuse-lite from lock file\\n'\n  )\n  writeFileSync(lock.file, lockfileData.content)\n\n  let install = lock.mode === 'yarn' ? 'yarnpkg add -W' : lock.mode + ' install'\n  print(\n    'Installing new caniuse-lite version\\n' +\n      pico.yellow('$ ' + install.replace('yarnpkg', 'yarn') + ' caniuse-lite') +\n      '\\n'\n  )\n  try {\n    execSync(install + ' caniuse-lite')\n  } catch (e) /* c8 ignore start */ {\n    print(\n      pico.red(\n        '\\n' +\n          e.stack +\n          '\\n\\n' +\n          'Problem with `' +\n          install +\n          ' caniuse-lite` call. ' +\n          'Run it manually.\\n'\n      )\n    )\n    process.exit(1)\n  } /* c8 ignore end */\n\n  let del =\n    lock.mode === 'yarn' ? 'yarnpkg remove -W' : lock.mode + ' uninstall'\n  print(\n    'Cleaning package.json dependencies from caniuse-lite\\n' +\n      pico.yellow('$ ' + del.replace('yarnpkg', 'yarn') + ' caniuse-lite') +\n      '\\n'\n  )\n  execSync(del + ' caniuse-lite')\n}\n\nfunction updateWith(print, cmd) {\n  print(\n    'Updating caniuse-lite version\\n' +\n      pico.yellow('$ ' + cmd.replace('yarnpkg', 'yarn')) +\n      '\\n'\n  )\n  try {\n    execSync(cmd)\n  } catch (e) /* c8 ignore start */ {\n    print(pico.red(e.stdout.toString()))\n    print(\n      pico.red(\n        '\\n' +\n          e.stack +\n          '\\n\\n' +\n          'Problem with `' +\n          cmd +\n          '` call. ' +\n          'Run it manually.\\n'\n      )\n    )\n    process.exit(1)\n  } /* c8 ignore end */\n}\n\nmodule.exports = function updateDB(print = defaultPrint) {\n  let lock = detectLockfile()\n  let latest = getLatestInfo(lock)\n\n  let listError\n  let oldList\n  try {\n    oldList = getBrowsers()\n  } catch (e) {\n    listError = e\n  }\n\n  print('Latest version:     ' + pico.bold(pico.green(latest.version)) + '\\n')\n\n  if (lock.mode === 'yarn' && lock.version !== 1) {\n    updateWith(print, 'yarnpkg up -R caniuse-lite')\n  } else if (lock.mode === 'pnpm') {\n    updateWith(print, 'pnpm up caniuse-lite')\n  } else {\n    updatePackageManually(print, lock, latest)\n  }\n\n  print('caniuse-lite has been successfully updated\\n')\n\n  let newList\n  if (!listError) {\n    try {\n      newList = getBrowsers()\n    } catch (e) /* c8 ignore start */ {\n      listError = e\n    } /* c8 ignore end */\n  }\n\n  if (listError) {\n    print(\n      pico.red(\n        '\\n' +\n          listError.stack +\n          '\\n\\n' +\n          'Problem with browser list retrieval.\\n' +\n          'Target browser changes wonâ€™t be shown.\\n'\n      )\n    )\n  } else {\n    let changes = diffBrowsers(oldList, newList)\n    if (changes) {\n      print('\\nTarget browser changes:\\n')\n      print(changes + '\\n')\n    } else {\n      print('\\n' + pico.green('No target browser changes') + '\\n')\n    }\n  }\n}\n",
    "package.json": "{\n  \"name\": \"update-browserslist-db\",\n  \"version\": \"1.0.13\",\n  \"description\": \"CLI tool to update caniuse-lite to refresh target browsers from Browserslist config\",\n  \"keywords\": [\n    \"caniuse\",\n    \"browsers\",\n    \"target\"\n  ],\n  \"funding\": [\n    {\n      \"type\": \"opencollective\",\n      \"url\": \"https://opencollective.com/browserslist\"\n    },\n    {\n      \"type\": \"tidelift\",\n      \"url\": \"https://tidelift.com/funding/github/npm/browserslist\"\n    },\n    {\n      \"type\": \"github\",\n      \"url\": \"https://github.com/sponsors/ai\"\n    }\n  ],\n  \"author\": \"Andrey Sitnik <andrey@sitnik.ru>\",\n  \"license\": \"MIT\",\n  \"repository\": \"browserslist/update-db\",\n  \"types\": \"./index.d.ts\",\n  \"exports\": {\n    \".\": \"./index.js\",\n    \"./package.json\": \"./package.json\"\n  },\n  \"dependencies\": {\n    \"escalade\": \"^3.1.1\",\n    \"picocolors\": \"^1.0.0\"\n  },\n  \"peerDependencies\": {\n    \"browserslist\": \">= 4.21.0\"\n  },\n  \"bin\": \"cli.js\"\n}\n",
    "utils.js": "const { EOL } = require('os')\n\nconst getFirstRegexpMatchOrDefault = (text, regexp, defaultValue) => {\n  regexp.lastIndex = 0 // https://stackoverflow.com/a/11477448/4536543\n  let match = regexp.exec(text)\n  if (match !== null) return match[1]\n  return defaultValue\n}\n\nconst DEFAULT_INDENT = '  '\nconst INDENT_REGEXP = /^([ \\t]+)[^\\s]/m\n\nmodule.exports.detectIndent = text =>\n  getFirstRegexpMatchOrDefault(text, INDENT_REGEXP, DEFAULT_INDENT)\nmodule.exports.DEFAULT_INDENT = DEFAULT_INDENT\n\nconst DEFAULT_EOL = EOL\nconst EOL_REGEXP = /(\\r\\n|\\n|\\r)/g\n\nmodule.exports.detectEOL = text =>\n  getFirstRegexpMatchOrDefault(text, EOL_REGEXP, DEFAULT_EOL)\nmodule.exports.DEFAULT_EOL = DEFAULT_EOL\n"
  },
  "externals": [
    "fs",
    "child_process",
    "path",
    "escalade/sync",
    "picocolors",
    "browserslist",
    "os"
  ]
}
